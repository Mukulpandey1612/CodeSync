{"ast":null,"code":"ace.define(\"ace/ext/hardwrap\", [\"require\", \"exports\", \"module\", \"ace/range\", \"ace/editor\", \"ace/config\"], function (require, exports, module) {\n  \"use strict\";\n\n  var Range = require(\"../range\").Range;\n\n  function hardWrap(editor, options) {\n    var max = options.column || editor.getOption(\"printMarginColumn\");\n    var allowMerge = options.allowMerge != false;\n    var row = Math.min(options.startRow, options.endRow);\n    var endRow = Math.max(options.startRow, options.endRow);\n    var session = editor.session;\n\n    while (row <= endRow) {\n      var line = session.getLine(row);\n\n      if (line.length > max) {\n        var space = findSpace(line, max, 5);\n\n        if (space) {\n          var indentation = /^\\s*/.exec(line)[0];\n          session.replace(new Range(row, space.start, row, space.end), \"\\n\" + indentation);\n        }\n\n        endRow++;\n      } else if (allowMerge && /\\S/.test(line) && row != endRow) {\n        var nextLine = session.getLine(row + 1);\n\n        if (nextLine && /\\S/.test(nextLine)) {\n          var trimmedLine = line.replace(/\\s+$/, \"\");\n          var trimmedNextLine = nextLine.replace(/^\\s+/, \"\");\n          var mergedLine = trimmedLine + \" \" + trimmedNextLine;\n          var space = findSpace(mergedLine, max, 5);\n\n          if (space && space.start > trimmedLine.length || mergedLine.length < max) {\n            var replaceRange = new Range(row, trimmedLine.length, row + 1, nextLine.length - trimmedNextLine.length);\n            session.replace(replaceRange, \" \");\n            row--;\n            endRow--;\n          } else if (trimmedLine.length < line.length) {\n            session.remove(new Range(row, trimmedLine.length, row, line.length));\n          }\n        }\n      }\n\n      row++;\n    }\n\n    function findSpace(line, max, min) {\n      if (line.length < max) return;\n      var before = line.slice(0, max);\n      var after = line.slice(max);\n      var spaceAfter = /^(?:(\\s+)|(\\S+)(\\s+))/.exec(after);\n      var spaceBefore = /(?:(\\s+)|(\\s+)(\\S+))$/.exec(before);\n      var start = 0;\n      var end = 0;\n\n      if (spaceBefore && !spaceBefore[2]) {\n        start = max - spaceBefore[1].length;\n        end = max;\n      }\n\n      if (spaceAfter && !spaceAfter[2]) {\n        if (!start) start = max;\n        end = max + spaceAfter[1].length;\n      }\n\n      if (start) {\n        return {\n          start: start,\n          end: end\n        };\n      }\n\n      if (spaceBefore && spaceBefore[2] && spaceBefore.index > min) {\n        return {\n          start: spaceBefore.index,\n          end: spaceBefore.index + spaceBefore[2].length\n        };\n      }\n\n      if (spaceAfter && spaceAfter[2]) {\n        start = max + spaceAfter[2].length;\n        return {\n          start: start,\n          end: start + spaceAfter[3].length\n        };\n      }\n    }\n  }\n\n  function wrapAfterInput(e) {\n    if (e.command.name == \"insertstring\" && /\\S/.test(e.args)) {\n      var editor = e.editor;\n      var cursor = editor.selection.cursor;\n      if (cursor.column <= editor.renderer.$printMarginColumn) return;\n      var lastDelta = editor.session.$undoManager.$lastDelta;\n      hardWrap(editor, {\n        startRow: cursor.row,\n        endRow: cursor.row,\n        allowMerge: false\n      });\n      if (lastDelta != editor.session.$undoManager.$lastDelta) editor.session.markUndoGroup();\n    }\n  }\n\n  var Editor = require(\"../editor\").Editor;\n\n  require(\"../config\").defineOptions(Editor.prototype, \"editor\", {\n    hardWrap: {\n      set: function (val) {\n        if (val) {\n          this.commands.on(\"afterExec\", wrapAfterInput);\n        } else {\n          this.commands.off(\"afterExec\", wrapAfterInput);\n        }\n      },\n      value: false\n    }\n  });\n\n  exports.hardWrap = hardWrap;\n});\nace.define(\"ace/keyboard/vim\", [\"require\", \"exports\", \"module\", \"ace/range\", \"ace/lib/event_emitter\", \"ace/lib/dom\", \"ace/lib/oop\", \"ace/lib/keys\", \"ace/lib/event\", \"ace/search\", \"ace/lib/useragent\", \"ace/search_highlight\", \"ace/commands/multi_select_commands\", \"ace/mode/text\", \"ace/ext/hardwrap\", \"ace/multi_select\"], function (require, exports, module) {\n  // CodeMirror, copyright (c) by Marijn Haverbeke and others\n  'use strict';\n\n  function log() {\n    var d = \"\";\n\n    function format(p) {\n      if (typeof p != \"object\") return p + \"\";\n\n      if (\"line\" in p) {\n        return p.line + \":\" + p.ch;\n      }\n\n      if (\"anchor\" in p) {\n        return format(p.anchor) + \"->\" + format(p.head);\n      }\n\n      if (Array.isArray(p)) return \"[\" + p.map(function (x) {\n        return format(x);\n      }) + \"]\";\n      return JSON.stringify(p);\n    }\n\n    for (var i = 0; i < arguments.length; i++) {\n      var p = arguments[i];\n      var f = format(p);\n      d += f + \"  \";\n    }\n\n    console.log(d);\n  }\n\n  var Range = require(\"../range\").Range;\n\n  var EventEmitter = require(\"../lib/event_emitter\").EventEmitter;\n\n  var domLib = require(\"../lib/dom\");\n\n  var oop = require(\"../lib/oop\");\n\n  var KEYS = require(\"../lib/keys\");\n\n  var event = require(\"../lib/event\");\n\n  var Search = require(\"../search\").Search;\n\n  var useragent = require(\"../lib/useragent\");\n\n  var SearchHighlight = require(\"../search_highlight\").SearchHighlight;\n\n  var multiSelectCommands = require(\"../commands/multi_select_commands\");\n\n  var TextModeTokenRe = require(\"../mode/text\").Mode.prototype.tokenRe;\n\n  var hardWrap = require(\"../ext/hardwrap\").hardWrap;\n\n  require(\"../multi_select\");\n\n  var CodeMirror = function (ace) {\n    this.ace = ace;\n    this.state = {};\n    this.marks = {};\n    this.options = {};\n    this.$uid = 0;\n    this.onChange = this.onChange.bind(this);\n    this.onSelectionChange = this.onSelectionChange.bind(this);\n    this.onBeforeEndOperation = this.onBeforeEndOperation.bind(this);\n    this.ace.on('change', this.onChange);\n    this.ace.on('changeSelection', this.onSelectionChange);\n    this.ace.on('beforeEndOperation', this.onBeforeEndOperation);\n  };\n\n  CodeMirror.Pos = function (line, ch) {\n    if (!(this instanceof Pos)) return new Pos(line, ch);\n    this.line = line;\n    this.ch = ch;\n  };\n\n  CodeMirror.defineOption = function (name, val, setter) {};\n\n  CodeMirror.commands = {\n    redo: function (cm) {\n      cm.ace.redo();\n    },\n    undo: function (cm) {\n      cm.ace.undo();\n    },\n    newlineAndIndent: function (cm) {\n      cm.ace.insert(\"\\n\");\n    },\n    goLineLeft: function (cm) {\n      cm.ace.selection.moveCursorLineStart();\n    },\n    goLineRight: function (cm) {\n      cm.ace.selection.moveCursorLineEnd();\n    }\n  };\n  CodeMirror.keyMap = {};\n\n  CodeMirror.addClass = CodeMirror.rmClass = function () {};\n\n  CodeMirror.e_stop = CodeMirror.e_preventDefault = event.stopEvent;\n\n  CodeMirror.keyName = function (e) {\n    var key = KEYS[e.keyCode] || e.key || \"\";\n    if (key.length == 1) key = key.toUpperCase();\n    key = event.getModifierString(e).replace(/(^|-)\\w/g, function (m) {\n      return m.toUpperCase();\n    }) + key;\n    return key;\n  };\n\n  CodeMirror.keyMap['default'] = function (key) {\n    return function (cm) {\n      var cmd = cm.ace.commands.commandKeyBinding[key.toLowerCase()];\n      return cmd && cm.ace.execCommand(cmd) !== false;\n    };\n  };\n\n  CodeMirror.lookupKey = function lookupKey(key, map, handle) {\n    if (!map) map = \"default\";\n    if (typeof map == \"string\") map = CodeMirror.keyMap[map];\n    var found = typeof map == \"function\" ? map(key) : map[key];\n    if (found === false) return \"nothing\";\n    if (found === \"...\") return \"multi\";\n    if (found != null && handle(found)) return \"handled\";\n\n    if (map.fallthrough) {\n      if (!Array.isArray(map.fallthrough)) return lookupKey(key, map.fallthrough, handle);\n\n      for (var i = 0; i < map.fallthrough.length; i++) {\n        var result = lookupKey(key, map.fallthrough[i], handle);\n        if (result) return result;\n      }\n    }\n  };\n\n  CodeMirror.findMatchingTag = function (cm, head) {\n    return cm.findMatchingTag(head);\n  };\n\n  CodeMirror.findEnclosingTag = function (cm, head) {};\n\n  CodeMirror.signal = function (o, name, e) {\n    return o._signal(name, e);\n  };\n\n  CodeMirror.on = event.addListener;\n  CodeMirror.off = event.removeListener;\n\n  CodeMirror.isWordChar = function (ch) {\n    if (ch < \"\\x7f\") return /^\\w$/.test(ch);\n    TextModeTokenRe.lastIndex = 0;\n    return TextModeTokenRe.test(ch);\n  };\n\n  (function () {\n    oop.implement(CodeMirror.prototype, EventEmitter);\n\n    this.destroy = function () {\n      this.ace.off('change', this.onChange);\n      this.ace.off('changeSelection', this.onSelectionChange);\n      this.ace.off('beforeEndOperation', this.onBeforeEndOperation);\n      this.removeOverlay();\n    };\n\n    this.virtualSelectionMode = function () {\n      return this.ace.inVirtualSelectionMode && this.ace.selection.index;\n    };\n\n    this.onChange = function (delta) {\n      var change = {\n        text: delta.action[0] == 'i' ? delta.lines : []\n      };\n      var curOp = this.curOp = this.curOp || {};\n      if (!curOp.changeHandlers) curOp.changeHandlers = this._eventRegistry[\"change\"] && this._eventRegistry[\"change\"].slice();\n\n      if (!curOp.lastChange) {\n        curOp.lastChange = curOp.change = change;\n      } else {\n        curOp.lastChange.next = curOp.lastChange = change;\n      }\n\n      this.$updateMarkers(delta);\n    };\n\n    this.onSelectionChange = function () {\n      var curOp = this.curOp = this.curOp || {};\n      if (!curOp.cursorActivityHandlers) curOp.cursorActivityHandlers = this._eventRegistry[\"cursorActivity\"] && this._eventRegistry[\"cursorActivity\"].slice();\n      this.curOp.cursorActivity = true;\n\n      if (this.ace.inMultiSelectMode) {\n        this.ace.keyBinding.removeKeyboardHandler(multiSelectCommands.keyboardHandler);\n      }\n    };\n\n    this.operation = function (fn, force) {\n      if (!force && this.curOp || force && this.curOp && this.curOp.force) {\n        return fn();\n      }\n\n      if (force || !this.ace.curOp) {\n        if (this.curOp) this.onBeforeEndOperation();\n      }\n\n      if (!this.ace.curOp) {\n        var prevOp = this.ace.prevOp;\n        this.ace.startOperation({\n          command: {\n            name: \"vim\",\n            scrollIntoView: \"cursor\"\n          }\n        });\n      }\n\n      var curOp = this.curOp = this.curOp || {};\n      this.curOp.force = force;\n      var result = fn();\n\n      if (this.ace.curOp && this.ace.curOp.command.name == \"vim\") {\n        if (this.state.dialog) this.ace.curOp.command.scrollIntoView = this.ace.curOp.vimDialogScroll;\n        this.ace.endOperation();\n        if (!curOp.cursorActivity && !curOp.lastChange && prevOp) this.ace.prevOp = prevOp;\n      }\n\n      if (force || !this.ace.curOp) {\n        if (this.curOp) this.onBeforeEndOperation();\n      }\n\n      return result;\n    };\n\n    this.onBeforeEndOperation = function () {\n      var op = this.curOp;\n\n      if (op) {\n        if (op.change) {\n          this.signal(\"change\", op.change, op);\n        }\n\n        if (op && op.cursorActivity) {\n          this.signal(\"cursorActivity\", null, op);\n        }\n\n        this.curOp = null;\n      }\n    };\n\n    this.signal = function (eventName, e, handlers) {\n      var listeners = handlers ? handlers[eventName + \"Handlers\"] : (this._eventRegistry || {})[eventName];\n      if (!listeners) return;\n      listeners = listeners.slice();\n\n      for (var i = 0; i < listeners.length; i++) listeners[i](this, e);\n    };\n\n    this.firstLine = function () {\n      return 0;\n    };\n\n    this.lastLine = function () {\n      return this.ace.session.getLength() - 1;\n    };\n\n    this.lineCount = function () {\n      return this.ace.session.getLength();\n    };\n\n    this.setCursor = function (line, ch) {\n      if (typeof line === 'object') {\n        ch = line.ch;\n        line = line.line;\n      }\n\n      var shouldScroll = !this.curOp && !this.ace.inVirtualSelectionMode;\n      if (!this.ace.inVirtualSelectionMode) this.ace.exitMultiSelectMode();\n      this.ace.session.unfold({\n        row: line,\n        column: ch\n      });\n      this.ace.selection.moveTo(line, ch);\n\n      if (shouldScroll) {\n        this.ace.renderer.scrollCursorIntoView();\n        this.ace.endOperation();\n      }\n    };\n\n    this.getCursor = function (p) {\n      var sel = this.ace.selection;\n      var pos = p == 'anchor' ? sel.isEmpty() ? sel.lead : sel.anchor : p == 'head' || !p ? sel.lead : sel.getRange()[p];\n      return toCmPos(pos);\n    };\n\n    this.listSelections = function (p) {\n      var ranges = this.ace.multiSelect.rangeList.ranges;\n      if (!ranges.length || this.ace.inVirtualSelectionMode) return [{\n        anchor: this.getCursor('anchor'),\n        head: this.getCursor('head')\n      }];\n      return ranges.map(function (r) {\n        return {\n          anchor: this.clipPos(toCmPos(r.cursor == r.end ? r.start : r.end)),\n          head: this.clipPos(toCmPos(r.cursor))\n        };\n      }, this);\n    };\n\n    this.setSelections = function (p, primIndex) {\n      var sel = this.ace.multiSelect;\n      var ranges = p.map(function (x) {\n        var anchor = toAcePos(x.anchor);\n        var head = toAcePos(x.head);\n        var r = Range.comparePoints(anchor, head) < 0 ? new Range.fromPoints(anchor, head) : new Range.fromPoints(head, anchor);\n        r.cursor = Range.comparePoints(r.start, head) ? r.end : r.start;\n        return r;\n      });\n\n      if (this.ace.inVirtualSelectionMode) {\n        this.ace.selection.fromOrientedRange(ranges[0]);\n        return;\n      }\n\n      if (!primIndex) {\n        ranges = ranges.reverse();\n      } else if (ranges[primIndex]) {\n        ranges.push(ranges.splice(primIndex, 1)[0]);\n      }\n\n      sel.toSingleRange(ranges[0].clone());\n      var session = this.ace.session;\n\n      for (var i = 0; i < ranges.length; i++) {\n        var range = session.$clipRangeToDocument(ranges[i]); // todo why ace doesn't do this?\n\n        sel.addRange(range);\n      }\n    };\n\n    this.setSelection = function (a, h, options) {\n      var sel = this.ace.selection;\n      sel.moveTo(a.line, a.ch);\n      sel.selectTo(h.line, h.ch);\n\n      if (options && options.origin == '*mouse') {\n        this.onBeforeEndOperation();\n      }\n    };\n\n    this.somethingSelected = function (p) {\n      return !this.ace.selection.isEmpty();\n    };\n\n    this.clipPos = function (p) {\n      var pos = this.ace.session.$clipPositionToDocument(p.line, p.ch);\n      return toCmPos(pos);\n    };\n\n    this.foldCode = function (pos) {\n      this.ace.session.$toggleFoldWidget(pos.line, {});\n    };\n\n    this.markText = function (cursor) {\n      return {\n        clear: function () {},\n        find: function () {}\n      };\n    };\n\n    this.$updateMarkers = function (delta) {\n      var isInsert = delta.action == \"insert\";\n      var start = delta.start;\n      var end = delta.end;\n      var rowShift = (end.row - start.row) * (isInsert ? 1 : -1);\n      var colShift = (end.column - start.column) * (isInsert ? 1 : -1);\n      if (isInsert) end = start;\n\n      for (var i in this.marks) {\n        var point = this.marks[i];\n        var cmp = Range.comparePoints(point, start);\n\n        if (cmp < 0) {\n          continue; // delta starts after the range\n        }\n\n        if (cmp === 0) {\n          if (isInsert) {\n            if (point.bias == 1) {\n              cmp = 1;\n            } else {\n              point.bias = -1;\n              continue;\n            }\n          }\n        }\n\n        var cmp2 = isInsert ? cmp : Range.comparePoints(point, end);\n\n        if (cmp2 > 0) {\n          point.row += rowShift;\n          point.column += point.row == end.row ? colShift : 0;\n          continue;\n        }\n\n        if (!isInsert && cmp2 <= 0) {\n          point.row = start.row;\n          point.column = start.column;\n          if (cmp2 === 0) point.bias = 1;\n        }\n      }\n    };\n\n    var Marker = function (cm, id, row, column) {\n      this.cm = cm;\n      this.id = id;\n      this.row = row;\n      this.column = column;\n      cm.marks[this.id] = this;\n    };\n\n    Marker.prototype.clear = function () {\n      delete this.cm.marks[this.id];\n    };\n\n    Marker.prototype.find = function () {\n      return toCmPos(this);\n    };\n\n    this.setBookmark = function (cursor, options) {\n      var bm = new Marker(this, this.$uid++, cursor.line, cursor.ch);\n      if (!options || !options.insertLeft) bm.$insertRight = true;\n      this.marks[bm.id] = bm;\n      return bm;\n    };\n\n    this.moveH = function (increment, unit) {\n      if (unit == 'char') {\n        var sel = this.ace.selection;\n        sel.clearSelection();\n        sel.moveCursorBy(0, increment);\n      }\n    };\n\n    this.findPosV = function (start, amount, unit, goalColumn) {\n      if (unit == 'page') {\n        var renderer = this.ace.renderer;\n        var config = renderer.layerConfig;\n        amount = amount * Math.floor(config.height / config.lineHeight);\n        unit = 'line';\n      }\n\n      if (unit == 'line') {\n        var screenPos = this.ace.session.documentToScreenPosition(start.line, start.ch);\n        if (goalColumn != null) screenPos.column = goalColumn;\n        screenPos.row += amount;\n        screenPos.row = Math.min(Math.max(0, screenPos.row), this.ace.session.getScreenLength() - 1);\n        var pos = this.ace.session.screenToDocumentPosition(screenPos.row, screenPos.column);\n        return toCmPos(pos);\n      } else {\n        debugger;\n      }\n    };\n\n    this.charCoords = function (pos, mode) {\n      if (mode == 'div' || !mode) {\n        var sc = this.ace.session.documentToScreenPosition(pos.line, pos.ch);\n        return {\n          left: sc.column,\n          top: sc.row\n        };\n      }\n\n      if (mode == 'local') {\n        var renderer = this.ace.renderer;\n        var sc = this.ace.session.documentToScreenPosition(pos.line, pos.ch);\n        var lh = renderer.layerConfig.lineHeight;\n        var cw = renderer.layerConfig.characterWidth;\n        var top = lh * sc.row;\n        return {\n          left: sc.column * cw,\n          top: top,\n          bottom: top + lh\n        };\n      }\n    };\n\n    this.coordsChar = function (pos, mode) {\n      var renderer = this.ace.renderer;\n\n      if (mode == 'local') {\n        var row = Math.max(0, Math.floor(pos.top / renderer.lineHeight));\n        var col = Math.max(0, Math.floor(pos.left / renderer.characterWidth));\n        var ch = renderer.session.screenToDocumentPosition(row, col);\n        return toCmPos(ch);\n      } else if (mode == 'div') {\n        throw \"not implemented\";\n      }\n    };\n\n    this.getSearchCursor = function (query, pos, caseFold) {\n      var caseSensitive = false;\n      var isRegexp = false;\n\n      if (query instanceof RegExp && !query.global) {\n        caseSensitive = !query.ignoreCase;\n        query = query.source;\n        isRegexp = true;\n      }\n\n      if (query == \"\\\\n\") {\n        query = \"\\n\";\n        isRegexp = false;\n      }\n\n      var search = new Search();\n      if (pos.ch == undefined) pos.ch = Number.MAX_VALUE;\n      var acePos = {\n        row: pos.line,\n        column: pos.ch\n      };\n      var cm = this;\n      var last = null;\n      return {\n        findNext: function () {\n          return this.find(false);\n        },\n        findPrevious: function () {\n          return this.find(true);\n        },\n        find: function (back) {\n          search.setOptions({\n            needle: query,\n            caseSensitive: caseSensitive,\n            wrap: false,\n            backwards: back,\n            regExp: isRegexp,\n            start: last || acePos\n          });\n          var range = search.find(cm.ace.session);\n          last = range;\n          return last && [!last.isEmpty()];\n        },\n        from: function () {\n          return last && toCmPos(last.start);\n        },\n        to: function () {\n          return last && toCmPos(last.end);\n        },\n        replace: function (text) {\n          if (last) {\n            last.end = cm.ace.session.doc.replace(last, text);\n          }\n        }\n      };\n    };\n\n    this.scrollTo = function (x, y) {\n      var renderer = this.ace.renderer;\n      var config = renderer.layerConfig;\n      var maxHeight = config.maxHeight;\n      maxHeight -= (renderer.$size.scrollerHeight - renderer.lineHeight) * renderer.$scrollPastEnd;\n      if (y != null) this.ace.session.setScrollTop(Math.max(0, Math.min(y, maxHeight)));\n      if (x != null) this.ace.session.setScrollLeft(Math.max(0, Math.min(x, config.width)));\n    };\n\n    this.scrollInfo = function () {\n      return 0;\n    };\n\n    this.scrollIntoView = function (pos, margin) {\n      if (pos) {\n        var renderer = this.ace.renderer;\n        var viewMargin = {\n          \"top\": 0,\n          \"bottom\": margin\n        };\n        renderer.scrollCursorIntoView(toAcePos(pos), renderer.lineHeight * 2 / renderer.$size.scrollerHeight, viewMargin);\n      }\n    };\n\n    this.getLine = function (row) {\n      return this.ace.session.getLine(row);\n    };\n\n    this.getRange = function (s, e) {\n      return this.ace.session.getTextRange(new Range(s.line, s.ch, e.line, e.ch));\n    };\n\n    this.replaceRange = function (text, s, e) {\n      if (!e) e = s;\n      var range = new Range(s.line, s.ch, e.line, e.ch);\n      this.ace.session.$clipRangeToDocument(range);\n      return this.ace.session.replace(range, text);\n    };\n\n    this.replaceSelection = this.replaceSelections = function (p) {\n      var sel = this.ace.selection;\n\n      if (this.ace.inVirtualSelectionMode) {\n        this.ace.session.replace(sel.getRange(), p[0] || \"\");\n        return;\n      }\n\n      sel.inVirtualSelectionMode = true;\n      var ranges = sel.rangeList.ranges;\n      if (!ranges.length) ranges = [this.ace.multiSelect.getRange()];\n\n      for (var i = ranges.length; i--;) this.ace.session.replace(ranges[i], p[i] || \"\");\n\n      sel.inVirtualSelectionMode = false;\n    };\n\n    this.getSelection = function () {\n      return this.ace.getSelectedText();\n    };\n\n    this.getSelections = function () {\n      return this.listSelections().map(function (x) {\n        return this.getRange(x.anchor, x.head);\n      }, this);\n    };\n\n    this.getInputField = function () {\n      return this.ace.textInput.getElement();\n    };\n\n    this.getWrapperElement = function () {\n      return this.ace.container;\n    };\n\n    var optMap = {\n      indentWithTabs: \"useSoftTabs\",\n      indentUnit: \"tabSize\",\n      tabSize: \"tabSize\",\n      firstLineNumber: \"firstLineNumber\",\n      readOnly: \"readOnly\"\n    };\n\n    this.setOption = function (name, val) {\n      this.state[name] = val;\n\n      switch (name) {\n        case 'indentWithTabs':\n          name = optMap[name];\n          val = !val;\n          break;\n\n        case 'keyMap':\n          this.state.$keyMap = val;\n          return;\n          break;\n\n        default:\n          name = optMap[name];\n      }\n\n      if (name) this.ace.setOption(name, val);\n    };\n\n    this.getOption = function (name) {\n      var val;\n      var aceOpt = optMap[name];\n      if (aceOpt) val = this.ace.getOption(aceOpt);\n\n      switch (name) {\n        case 'indentWithTabs':\n          name = optMap[name];\n          return !val;\n\n        case 'keyMap':\n          return this.state.$keyMap || 'vim';\n      }\n\n      return aceOpt ? val : this.state[name];\n    };\n\n    this.toggleOverwrite = function (on) {\n      this.state.overwrite = on;\n      return this.ace.setOverwrite(on);\n    };\n\n    this.addOverlay = function (o) {\n      if (!this.$searchHighlight || !this.$searchHighlight.session) {\n        var highlight = new SearchHighlight(null, \"ace_highlight-marker\", \"text\");\n        var marker = this.ace.session.addDynamicMarker(highlight);\n        highlight.id = marker.id;\n        highlight.session = this.ace.session;\n\n        highlight.destroy = function (o) {\n          highlight.session.off(\"change\", highlight.updateOnChange);\n          highlight.session.off(\"changeEditor\", highlight.destroy);\n          highlight.session.removeMarker(highlight.id);\n          highlight.session = null;\n        };\n\n        highlight.updateOnChange = function (delta) {\n          var row = delta.start.row;\n          if (row == delta.end.row) highlight.cache[row] = undefined;else highlight.cache.splice(row, highlight.cache.length);\n        };\n\n        highlight.session.on(\"changeEditor\", highlight.destroy);\n        highlight.session.on(\"change\", highlight.updateOnChange);\n      }\n\n      var re = new RegExp(o.query.source, \"gmi\");\n      this.$searchHighlight = o.highlight = highlight;\n      this.$searchHighlight.setRegexp(re);\n      this.ace.renderer.updateBackMarkers();\n    };\n\n    this.removeOverlay = function (o) {\n      if (this.$searchHighlight && this.$searchHighlight.session) {\n        this.$searchHighlight.destroy();\n      }\n    };\n\n    this.getScrollInfo = function () {\n      var renderer = this.ace.renderer;\n      var config = renderer.layerConfig;\n      return {\n        left: renderer.scrollLeft,\n        top: renderer.scrollTop,\n        height: config.maxHeight,\n        width: config.width,\n        clientHeight: config.height,\n        clientWidth: config.width\n      };\n    };\n\n    this.getValue = function () {\n      return this.ace.getValue();\n    };\n\n    this.setValue = function (v) {\n      return this.ace.setValue(v, -1);\n    };\n\n    this.getTokenTypeAt = function (pos) {\n      var token = this.ace.session.getTokenAt(pos.line, pos.ch);\n      return token && /comment|string/.test(token.type) ? \"string\" : \"\";\n    };\n\n    this.findMatchingBracket = function (pos) {\n      var m = this.ace.session.findMatchingBracket(toAcePos(pos));\n      return {\n        to: m && toCmPos(m)\n      };\n    };\n\n    this.findMatchingTag = function (pos) {\n      var m = this.ace.session.getMatchingTags(toAcePos(pos));\n      if (!m) return;\n      return {\n        open: {\n          from: toCmPos(m.openTag.start),\n          to: toCmPos(m.openTag.end)\n        },\n        close: {\n          from: toCmPos(m.closeTag.start),\n          to: toCmPos(m.closeTag.end)\n        }\n      };\n    };\n\n    this.indentLine = function (line, method) {\n      if (method === true) this.ace.session.indentRows(line, line, \"\\t\");else if (method === false) this.ace.session.outdentRows(new Range(line, 0, line, 0));\n    };\n\n    this.indexFromPos = function (pos) {\n      return this.ace.session.doc.positionToIndex(toAcePos(pos));\n    };\n\n    this.posFromIndex = function (index) {\n      return toCmPos(this.ace.session.doc.indexToPosition(index));\n    };\n\n    this.focus = function (index) {\n      return this.ace.textInput.focus();\n    };\n\n    this.blur = function (index) {\n      return this.ace.blur();\n    };\n\n    this.defaultTextHeight = function (index) {\n      return this.ace.renderer.layerConfig.lineHeight;\n    };\n\n    this.scanForBracket = function (pos, dir, _, options) {\n      var re = options.bracketRegex.source;\n      var tokenRe = /paren|text|operator|tag/;\n\n      if (dir == 1) {\n        var m = this.ace.session.$findClosingBracket(re.slice(1, 2), toAcePos(pos), tokenRe);\n      } else {\n        var m = this.ace.session.$findOpeningBracket(re.slice(-2, -1), {\n          row: pos.line,\n          column: pos.ch + 1\n        }, tokenRe);\n      }\n\n      return m && {\n        pos: toCmPos(m)\n      };\n    };\n\n    this.refresh = function () {\n      return this.ace.resize(true);\n    };\n\n    this.getMode = function () {\n      return {\n        name: this.getOption(\"mode\")\n      };\n    };\n\n    this.execCommand = function (name) {\n      if (CodeMirror.commands.hasOwnProperty(name)) return CodeMirror.commands[name](this);\n      if (name == \"indentAuto\") return this.ace.execCommand(\"autoindent\");\n      console.log(name + \" is not implemented\");\n    };\n\n    this.getLineNumber = function (handle) {\n      return handle.row;\n    };\n\n    this.getLineHandle = function (row) {\n      return {\n        text: this.ace.session.getLine(row),\n        row: row\n      };\n    };\n  }).call(CodeMirror.prototype);\n\n  function toAcePos(cmPos) {\n    return {\n      row: cmPos.line,\n      column: cmPos.ch\n    };\n  }\n\n  function toCmPos(acePos) {\n    return new Pos(acePos.row, acePos.column);\n  }\n\n  var StringStream = CodeMirror.StringStream = function (string, tabSize) {\n    this.pos = this.start = 0;\n    this.string = string;\n    this.tabSize = tabSize || 8;\n    this.lastColumnPos = this.lastColumnValue = 0;\n    this.lineStart = 0;\n  };\n\n  StringStream.prototype = {\n    eol: function () {\n      return this.pos >= this.string.length;\n    },\n    sol: function () {\n      return this.pos == this.lineStart;\n    },\n    peek: function () {\n      return this.string.charAt(this.pos) || undefined;\n    },\n    next: function () {\n      if (this.pos < this.string.length) return this.string.charAt(this.pos++);\n    },\n    eat: function (match) {\n      var ch = this.string.charAt(this.pos);\n      if (typeof match == \"string\") var ok = ch == match;else var ok = ch && (match.test ? match.test(ch) : match(ch));\n\n      if (ok) {\n        ++this.pos;\n        return ch;\n      }\n    },\n    eatWhile: function (match) {\n      var start = this.pos;\n\n      while (this.eat(match)) {}\n\n      return this.pos > start;\n    },\n    eatSpace: function () {\n      var start = this.pos;\n\n      while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;\n\n      return this.pos > start;\n    },\n    skipToEnd: function () {\n      this.pos = this.string.length;\n    },\n    skipTo: function (ch) {\n      var found = this.string.indexOf(ch, this.pos);\n\n      if (found > -1) {\n        this.pos = found;\n        return true;\n      }\n    },\n    backUp: function (n) {\n      this.pos -= n;\n    },\n    column: function () {\n      throw \"not implemented\";\n    },\n    indentation: function () {\n      throw \"not implemented\";\n    },\n    match: function (pattern, consume, caseInsensitive) {\n      if (typeof pattern == \"string\") {\n        var cased = function (str) {\n          return caseInsensitive ? str.toLowerCase() : str;\n        };\n\n        var substr = this.string.substr(this.pos, pattern.length);\n\n        if (cased(substr) == cased(pattern)) {\n          if (consume !== false) this.pos += pattern.length;\n          return true;\n        }\n      } else {\n        var match = this.string.slice(this.pos).match(pattern);\n        if (match && match.index > 0) return null;\n        if (match && consume !== false) this.pos += match[0].length;\n        return match;\n      }\n    },\n    current: function () {\n      return this.string.slice(this.start, this.pos);\n    },\n    hideFirstChars: function (n, inner) {\n      this.lineStart += n;\n\n      try {\n        return inner();\n      } finally {\n        this.lineStart -= n;\n      }\n    }\n  };\n\n  CodeMirror.defineExtension = function (name, fn) {\n    CodeMirror.prototype[name] = fn;\n  };\n\n  domLib.importCssString(\".normal-mode .ace_cursor{\\n    border: none;\\n    background-color: rgba(255,0,0,0.5);\\n}\\n.normal-mode .ace_hidden-cursors .ace_cursor{\\n  background-color: transparent;\\n  border: 1px solid red;\\n  opacity: 0.7\\n}\\n.ace_dialog {\\n  position: absolute;\\n  left: 0; right: 0;\\n  background: inherit;\\n  z-index: 15;\\n  padding: .1em .8em;\\n  overflow: hidden;\\n  color: inherit;\\n}\\n.ace_dialog-top {\\n  border-bottom: 1px solid #444;\\n  top: 0;\\n}\\n.ace_dialog-bottom {\\n  border-top: 1px solid #444;\\n  bottom: 0;\\n}\\n.ace_dialog input {\\n  border: none;\\n  outline: none;\\n  background: transparent;\\n  width: 20em;\\n  color: inherit;\\n  font-family: monospace;\\n}\", \"vimMode\", false);\n\n  (function () {\n    function dialogDiv(cm, template, bottom) {\n      var wrap = cm.ace.container;\n      var dialog;\n      dialog = wrap.appendChild(document.createElement(\"div\"));\n      if (bottom) dialog.className = \"ace_dialog ace_dialog-bottom\";else dialog.className = \"ace_dialog ace_dialog-top\";\n\n      if (typeof template == \"string\") {\n        dialog.innerHTML = template;\n      } else {\n        // Assuming it's a detached DOM element.\n        dialog.appendChild(template);\n      }\n\n      return dialog;\n    }\n\n    function closeNotification(cm, newVal) {\n      if (cm.state.currentNotificationClose) cm.state.currentNotificationClose();\n      cm.state.currentNotificationClose = newVal;\n    }\n\n    CodeMirror.defineExtension(\"openDialog\", function (template, callback, options) {\n      if (this.virtualSelectionMode()) return;\n      if (!options) options = {};\n      closeNotification(this, null);\n      var dialog = dialogDiv(this, template, options.bottom);\n      var closed = false,\n          me = this;\n      this.state.dialog = dialog;\n\n      function close(newVal) {\n        if (typeof newVal == 'string') {\n          inp.value = newVal;\n        } else {\n          if (closed) return;\n\n          if (newVal && newVal.type == \"blur\") {\n            if (document.activeElement === inp) return;\n          }\n\n          if (me.state.dialog == dialog) {\n            me.state.dialog = null;\n            me.focus();\n          }\n\n          closed = true;\n          dialog.remove();\n          if (options.onClose) options.onClose(dialog);\n          var cm = me;\n\n          if (cm.state.vim) {\n            cm.state.vim.status = null;\n\n            cm.ace._signal(\"changeStatus\");\n\n            cm.ace.renderer.$loop.schedule(cm.ace.renderer.CHANGE_CURSOR);\n          }\n        }\n      }\n\n      var inp = dialog.getElementsByTagName(\"input\")[0],\n          button;\n\n      if (inp) {\n        if (options.value) {\n          inp.value = options.value;\n          if (options.selectValueOnOpen !== false) inp.select();\n        }\n\n        if (options.onInput) CodeMirror.on(inp, \"input\", function (e) {\n          options.onInput(e, inp.value, close);\n        });\n        if (options.onKeyUp) CodeMirror.on(inp, \"keyup\", function (e) {\n          options.onKeyUp(e, inp.value, close);\n        });\n        CodeMirror.on(inp, \"keydown\", function (e) {\n          if (options && options.onKeyDown && options.onKeyDown(e, inp.value, close)) {\n            return;\n          }\n\n          if (e.keyCode == 13) callback(inp.value);\n\n          if (e.keyCode == 27 || options.closeOnEnter !== false && e.keyCode == 13) {\n            CodeMirror.e_stop(e);\n            close();\n          }\n        });\n        if (options.closeOnBlur !== false) CodeMirror.on(inp, \"blur\", close);\n        inp.focus();\n      } else if (button = dialog.getElementsByTagName(\"button\")[0]) {\n        CodeMirror.on(button, \"click\", function () {\n          close();\n          me.focus();\n        });\n        if (options.closeOnBlur !== false) CodeMirror.on(button, \"blur\", close);\n        button.focus();\n      }\n\n      return close;\n    });\n    CodeMirror.defineExtension(\"openNotification\", function (template, options) {\n      if (this.virtualSelectionMode()) return;\n      closeNotification(this, close);\n      var dialog = dialogDiv(this, template, options && options.bottom);\n      var closed = false,\n          doneTimer;\n      var duration = options && typeof options.duration !== \"undefined\" ? options.duration : 5000;\n\n      function close() {\n        if (closed) return;\n        closed = true;\n        clearTimeout(doneTimer);\n        dialog.remove();\n      }\n\n      CodeMirror.on(dialog, 'click', function (e) {\n        CodeMirror.e_preventDefault(e);\n        close();\n      });\n      if (duration) doneTimer = setTimeout(close, duration);\n      return close;\n    });\n  })();\n\n  var Pos = CodeMirror.Pos;\n\n  function transformCursor(cm, range) {\n    var vim = cm.state.vim;\n    if (!vim || vim.insertMode) return range.head;\n    var head = vim.sel.head;\n    if (!head) return range.head;\n\n    if (vim.visualBlock) {\n      if (range.head.line != head.line) {\n        return;\n      }\n    }\n\n    if (range.from() == range.anchor && !range.empty()) {\n      if (range.head.line == head.line && range.head.ch != head.ch) return new Pos(range.head.line, range.head.ch - 1);\n    }\n\n    return range.head;\n  }\n\n  function updateSelectionForSurrogateCharacters(cm, curStart, curEnd) {\n    if (curStart.line === curEnd.line && curStart.ch >= curEnd.ch - 1) {\n      var text = cm.getLine(curStart.line);\n      var charCode = text.charCodeAt(curStart.ch);\n\n      if (0xD800 <= charCode && charCode <= 0xD8FF) {\n        curEnd.ch += 1;\n      }\n    }\n\n    return {\n      start: curStart,\n      end: curEnd\n    };\n  }\n\n  var defaultKeymap = [{\n    keys: '<Left>',\n    type: 'keyToKey',\n    toKeys: 'h'\n  }, {\n    keys: '<Right>',\n    type: 'keyToKey',\n    toKeys: 'l'\n  }, {\n    keys: '<Up>',\n    type: 'keyToKey',\n    toKeys: 'k'\n  }, {\n    keys: '<Down>',\n    type: 'keyToKey',\n    toKeys: 'j'\n  }, {\n    keys: 'g<Up>',\n    type: 'keyToKey',\n    toKeys: 'gk'\n  }, {\n    keys: 'g<Down>',\n    type: 'keyToKey',\n    toKeys: 'gj'\n  }, {\n    keys: '<Space>',\n    type: 'keyToKey',\n    toKeys: 'l'\n  }, {\n    keys: '<BS>',\n    type: 'keyToKey',\n    toKeys: 'h',\n    context: 'normal'\n  }, {\n    keys: '<Del>',\n    type: 'keyToKey',\n    toKeys: 'x',\n    context: 'normal'\n  }, {\n    keys: '<C-Space>',\n    type: 'keyToKey',\n    toKeys: 'W'\n  }, {\n    keys: '<C-BS>',\n    type: 'keyToKey',\n    toKeys: 'B',\n    context: 'normal'\n  }, {\n    keys: '<S-Space>',\n    type: 'keyToKey',\n    toKeys: 'w'\n  }, {\n    keys: '<S-BS>',\n    type: 'keyToKey',\n    toKeys: 'b',\n    context: 'normal'\n  }, {\n    keys: '<C-n>',\n    type: 'keyToKey',\n    toKeys: 'j'\n  }, {\n    keys: '<C-p>',\n    type: 'keyToKey',\n    toKeys: 'k'\n  }, {\n    keys: '<C-[>',\n    type: 'keyToKey',\n    toKeys: '<Esc>'\n  }, {\n    keys: '<C-c>',\n    type: 'keyToKey',\n    toKeys: '<Esc>'\n  }, {\n    keys: '<C-[>',\n    type: 'keyToKey',\n    toKeys: '<Esc>',\n    context: 'insert'\n  }, {\n    keys: '<C-c>',\n    type: 'keyToKey',\n    toKeys: '<Esc>',\n    context: 'insert'\n  }, {\n    keys: '<C-Esc>',\n    type: 'keyToKey',\n    toKeys: '<Esc>'\n  }, {\n    keys: '<C-Esc>',\n    type: 'keyToKey',\n    toKeys: '<Esc>',\n    context: 'insert'\n  }, {\n    keys: 's',\n    type: 'keyToKey',\n    toKeys: 'cl',\n    context: 'normal'\n  }, {\n    keys: 's',\n    type: 'keyToKey',\n    toKeys: 'c',\n    context: 'visual'\n  }, {\n    keys: 'S',\n    type: 'keyToKey',\n    toKeys: 'cc',\n    context: 'normal'\n  }, {\n    keys: 'S',\n    type: 'keyToKey',\n    toKeys: 'VdO',\n    context: 'visual'\n  }, {\n    keys: '<Home>',\n    type: 'keyToKey',\n    toKeys: '0'\n  }, {\n    keys: '<End>',\n    type: 'keyToKey',\n    toKeys: '$'\n  }, {\n    keys: '<PageUp>',\n    type: 'keyToKey',\n    toKeys: '<C-b>'\n  }, {\n    keys: '<PageDown>',\n    type: 'keyToKey',\n    toKeys: '<C-f>'\n  }, {\n    keys: '<CR>',\n    type: 'keyToKey',\n    toKeys: 'j^',\n    context: 'normal'\n  }, {\n    keys: '<Ins>',\n    type: 'keyToKey',\n    toKeys: 'i',\n    context: 'normal'\n  }, {\n    keys: '<Ins>',\n    type: 'action',\n    action: 'toggleOverwrite',\n    context: 'insert'\n  }, {\n    keys: 'H',\n    type: 'motion',\n    motion: 'moveToTopLine',\n    motionArgs: {\n      linewise: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'M',\n    type: 'motion',\n    motion: 'moveToMiddleLine',\n    motionArgs: {\n      linewise: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'L',\n    type: 'motion',\n    motion: 'moveToBottomLine',\n    motionArgs: {\n      linewise: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'h',\n    type: 'motion',\n    motion: 'moveByCharacters',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: 'l',\n    type: 'motion',\n    motion: 'moveByCharacters',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: 'j',\n    type: 'motion',\n    motion: 'moveByLines',\n    motionArgs: {\n      forward: true,\n      linewise: true\n    }\n  }, {\n    keys: 'k',\n    type: 'motion',\n    motion: 'moveByLines',\n    motionArgs: {\n      forward: false,\n      linewise: true\n    }\n  }, {\n    keys: 'gj',\n    type: 'motion',\n    motion: 'moveByDisplayLines',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: 'gk',\n    type: 'motion',\n    motion: 'moveByDisplayLines',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: 'w',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: true,\n      wordEnd: false\n    }\n  }, {\n    keys: 'W',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: true,\n      wordEnd: false,\n      bigWord: true\n    }\n  }, {\n    keys: 'e',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: true,\n      wordEnd: true,\n      inclusive: true\n    }\n  }, {\n    keys: 'E',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: true,\n      wordEnd: true,\n      bigWord: true,\n      inclusive: true\n    }\n  }, {\n    keys: 'b',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: false,\n      wordEnd: false\n    }\n  }, {\n    keys: 'B',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: false,\n      wordEnd: false,\n      bigWord: true\n    }\n  }, {\n    keys: 'ge',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: false,\n      wordEnd: true,\n      inclusive: true\n    }\n  }, {\n    keys: 'gE',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: false,\n      wordEnd: true,\n      bigWord: true,\n      inclusive: true\n    }\n  }, {\n    keys: '{',\n    type: 'motion',\n    motion: 'moveByParagraph',\n    motionArgs: {\n      forward: false,\n      toJumplist: true\n    }\n  }, {\n    keys: '}',\n    type: 'motion',\n    motion: 'moveByParagraph',\n    motionArgs: {\n      forward: true,\n      toJumplist: true\n    }\n  }, {\n    keys: '(',\n    type: 'motion',\n    motion: 'moveBySentence',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: ')',\n    type: 'motion',\n    motion: 'moveBySentence',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: '<C-f>',\n    type: 'motion',\n    motion: 'moveByPage',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: '<C-b>',\n    type: 'motion',\n    motion: 'moveByPage',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: '<C-d>',\n    type: 'motion',\n    motion: 'moveByScroll',\n    motionArgs: {\n      forward: true,\n      explicitRepeat: true\n    }\n  }, {\n    keys: '<C-u>',\n    type: 'motion',\n    motion: 'moveByScroll',\n    motionArgs: {\n      forward: false,\n      explicitRepeat: true\n    }\n  }, {\n    keys: 'gg',\n    type: 'motion',\n    motion: 'moveToLineOrEdgeOfDocument',\n    motionArgs: {\n      forward: false,\n      explicitRepeat: true,\n      linewise: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'G',\n    type: 'motion',\n    motion: 'moveToLineOrEdgeOfDocument',\n    motionArgs: {\n      forward: true,\n      explicitRepeat: true,\n      linewise: true,\n      toJumplist: true\n    }\n  }, {\n    keys: \"g$\",\n    type: \"motion\",\n    motion: \"moveToEndOfDisplayLine\"\n  }, {\n    keys: \"g^\",\n    type: \"motion\",\n    motion: \"moveToStartOfDisplayLine\"\n  }, {\n    keys: \"g0\",\n    type: \"motion\",\n    motion: \"moveToStartOfDisplayLine\"\n  }, {\n    keys: '0',\n    type: 'motion',\n    motion: 'moveToStartOfLine'\n  }, {\n    keys: '^',\n    type: 'motion',\n    motion: 'moveToFirstNonWhiteSpaceCharacter'\n  }, {\n    keys: '+',\n    type: 'motion',\n    motion: 'moveByLines',\n    motionArgs: {\n      forward: true,\n      toFirstChar: true\n    }\n  }, {\n    keys: '-',\n    type: 'motion',\n    motion: 'moveByLines',\n    motionArgs: {\n      forward: false,\n      toFirstChar: true\n    }\n  }, {\n    keys: '_',\n    type: 'motion',\n    motion: 'moveByLines',\n    motionArgs: {\n      forward: true,\n      toFirstChar: true,\n      repeatOffset: -1\n    }\n  }, {\n    keys: '$',\n    type: 'motion',\n    motion: 'moveToEol',\n    motionArgs: {\n      inclusive: true\n    }\n  }, {\n    keys: '%',\n    type: 'motion',\n    motion: 'moveToMatchedSymbol',\n    motionArgs: {\n      inclusive: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'f<character>',\n    type: 'motion',\n    motion: 'moveToCharacter',\n    motionArgs: {\n      forward: true,\n      inclusive: true\n    }\n  }, {\n    keys: 'F<character>',\n    type: 'motion',\n    motion: 'moveToCharacter',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: 't<character>',\n    type: 'motion',\n    motion: 'moveTillCharacter',\n    motionArgs: {\n      forward: true,\n      inclusive: true\n    }\n  }, {\n    keys: 'T<character>',\n    type: 'motion',\n    motion: 'moveTillCharacter',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: ';',\n    type: 'motion',\n    motion: 'repeatLastCharacterSearch',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: ',',\n    type: 'motion',\n    motion: 'repeatLastCharacterSearch',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: '\\'<character>',\n    type: 'motion',\n    motion: 'goToMark',\n    motionArgs: {\n      toJumplist: true,\n      linewise: true\n    }\n  }, {\n    keys: '`<character>',\n    type: 'motion',\n    motion: 'goToMark',\n    motionArgs: {\n      toJumplist: true\n    }\n  }, {\n    keys: ']`',\n    type: 'motion',\n    motion: 'jumpToMark',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: '[`',\n    type: 'motion',\n    motion: 'jumpToMark',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: ']\\'',\n    type: 'motion',\n    motion: 'jumpToMark',\n    motionArgs: {\n      forward: true,\n      linewise: true\n    }\n  }, {\n    keys: '[\\'',\n    type: 'motion',\n    motion: 'jumpToMark',\n    motionArgs: {\n      forward: false,\n      linewise: true\n    }\n  }, {\n    keys: ']p',\n    type: 'action',\n    action: 'paste',\n    isEdit: true,\n    actionArgs: {\n      after: true,\n      isEdit: true,\n      matchIndent: true\n    }\n  }, {\n    keys: '[p',\n    type: 'action',\n    action: 'paste',\n    isEdit: true,\n    actionArgs: {\n      after: false,\n      isEdit: true,\n      matchIndent: true\n    }\n  }, {\n    keys: ']<character>',\n    type: 'motion',\n    motion: 'moveToSymbol',\n    motionArgs: {\n      forward: true,\n      toJumplist: true\n    }\n  }, {\n    keys: '[<character>',\n    type: 'motion',\n    motion: 'moveToSymbol',\n    motionArgs: {\n      forward: false,\n      toJumplist: true\n    }\n  }, {\n    keys: '|',\n    type: 'motion',\n    motion: 'moveToColumn'\n  }, {\n    keys: 'o',\n    type: 'motion',\n    motion: 'moveToOtherHighlightedEnd',\n    context: 'visual'\n  }, {\n    keys: 'O',\n    type: 'motion',\n    motion: 'moveToOtherHighlightedEnd',\n    motionArgs: {\n      sameLine: true\n    },\n    context: 'visual'\n  }, {\n    keys: 'd',\n    type: 'operator',\n    operator: 'delete'\n  }, {\n    keys: 'y',\n    type: 'operator',\n    operator: 'yank'\n  }, {\n    keys: 'c',\n    type: 'operator',\n    operator: 'change'\n  }, {\n    keys: '=',\n    type: 'operator',\n    operator: 'indentAuto'\n  }, {\n    keys: '>',\n    type: 'operator',\n    operator: 'indent',\n    operatorArgs: {\n      indentRight: true\n    }\n  }, {\n    keys: '<',\n    type: 'operator',\n    operator: 'indent',\n    operatorArgs: {\n      indentRight: false\n    }\n  }, {\n    keys: 'g~',\n    type: 'operator',\n    operator: 'changeCase'\n  }, {\n    keys: 'gu',\n    type: 'operator',\n    operator: 'changeCase',\n    operatorArgs: {\n      toLower: true\n    },\n    isEdit: true\n  }, {\n    keys: 'gU',\n    type: 'operator',\n    operator: 'changeCase',\n    operatorArgs: {\n      toLower: false\n    },\n    isEdit: true\n  }, {\n    keys: 'n',\n    type: 'motion',\n    motion: 'findNext',\n    motionArgs: {\n      forward: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'N',\n    type: 'motion',\n    motion: 'findNext',\n    motionArgs: {\n      forward: false,\n      toJumplist: true\n    }\n  }, {\n    keys: 'gn',\n    type: 'motion',\n    motion: 'findAndSelectNextInclusive',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: 'gN',\n    type: 'motion',\n    motion: 'findAndSelectNextInclusive',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: 'x',\n    type: 'operatorMotion',\n    operator: 'delete',\n    motion: 'moveByCharacters',\n    motionArgs: {\n      forward: true\n    },\n    operatorMotionArgs: {\n      visualLine: false\n    }\n  }, {\n    keys: 'X',\n    type: 'operatorMotion',\n    operator: 'delete',\n    motion: 'moveByCharacters',\n    motionArgs: {\n      forward: false\n    },\n    operatorMotionArgs: {\n      visualLine: true\n    }\n  }, {\n    keys: 'D',\n    type: 'operatorMotion',\n    operator: 'delete',\n    motion: 'moveToEol',\n    motionArgs: {\n      inclusive: true\n    },\n    context: 'normal'\n  }, {\n    keys: 'D',\n    type: 'operator',\n    operator: 'delete',\n    operatorArgs: {\n      linewise: true\n    },\n    context: 'visual'\n  }, {\n    keys: 'Y',\n    type: 'operatorMotion',\n    operator: 'yank',\n    motion: 'expandToLine',\n    motionArgs: {\n      linewise: true\n    },\n    context: 'normal'\n  }, {\n    keys: 'Y',\n    type: 'operator',\n    operator: 'yank',\n    operatorArgs: {\n      linewise: true\n    },\n    context: 'visual'\n  }, {\n    keys: 'C',\n    type: 'operatorMotion',\n    operator: 'change',\n    motion: 'moveToEol',\n    motionArgs: {\n      inclusive: true\n    },\n    context: 'normal'\n  }, {\n    keys: 'C',\n    type: 'operator',\n    operator: 'change',\n    operatorArgs: {\n      linewise: true\n    },\n    context: 'visual'\n  }, {\n    keys: '~',\n    type: 'operatorMotion',\n    operator: 'changeCase',\n    motion: 'moveByCharacters',\n    motionArgs: {\n      forward: true\n    },\n    operatorArgs: {\n      shouldMoveCursor: true\n    },\n    context: 'normal'\n  }, {\n    keys: '~',\n    type: 'operator',\n    operator: 'changeCase',\n    context: 'visual'\n  }, {\n    keys: '<C-u>',\n    type: 'operatorMotion',\n    operator: 'delete',\n    motion: 'moveToStartOfLine',\n    context: 'insert'\n  }, {\n    keys: '<C-w>',\n    type: 'operatorMotion',\n    operator: 'delete',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: false,\n      wordEnd: false\n    },\n    context: 'insert'\n  }, {\n    keys: '<C-w>',\n    type: 'idle',\n    context: 'normal'\n  }, {\n    keys: '<C-i>',\n    type: 'action',\n    action: 'jumpListWalk',\n    actionArgs: {\n      forward: true\n    }\n  }, {\n    keys: '<C-o>',\n    type: 'action',\n    action: 'jumpListWalk',\n    actionArgs: {\n      forward: false\n    }\n  }, {\n    keys: '<C-e>',\n    type: 'action',\n    action: 'scroll',\n    actionArgs: {\n      forward: true,\n      linewise: true\n    }\n  }, {\n    keys: '<C-y>',\n    type: 'action',\n    action: 'scroll',\n    actionArgs: {\n      forward: false,\n      linewise: true\n    }\n  }, {\n    keys: 'a',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'charAfter'\n    },\n    context: 'normal'\n  }, {\n    keys: 'A',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'eol'\n    },\n    context: 'normal'\n  }, {\n    keys: 'A',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'endOfSelectedArea'\n    },\n    context: 'visual'\n  }, {\n    keys: 'i',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'inplace'\n    },\n    context: 'normal'\n  }, {\n    keys: 'gi',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'lastEdit'\n    },\n    context: 'normal'\n  }, {\n    keys: 'I',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'firstNonBlank'\n    },\n    context: 'normal'\n  }, {\n    keys: 'gI',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'bol'\n    },\n    context: 'normal'\n  }, {\n    keys: 'I',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'startOfSelectedArea'\n    },\n    context: 'visual'\n  }, {\n    keys: 'o',\n    type: 'action',\n    action: 'newLineAndEnterInsertMode',\n    isEdit: true,\n    interlaceInsertRepeat: true,\n    actionArgs: {\n      after: true\n    },\n    context: 'normal'\n  }, {\n    keys: 'O',\n    type: 'action',\n    action: 'newLineAndEnterInsertMode',\n    isEdit: true,\n    interlaceInsertRepeat: true,\n    actionArgs: {\n      after: false\n    },\n    context: 'normal'\n  }, {\n    keys: 'v',\n    type: 'action',\n    action: 'toggleVisualMode'\n  }, {\n    keys: 'V',\n    type: 'action',\n    action: 'toggleVisualMode',\n    actionArgs: {\n      linewise: true\n    }\n  }, {\n    keys: '<C-v>',\n    type: 'action',\n    action: 'toggleVisualMode',\n    actionArgs: {\n      blockwise: true\n    }\n  }, {\n    keys: '<C-q>',\n    type: 'action',\n    action: 'toggleVisualMode',\n    actionArgs: {\n      blockwise: true\n    }\n  }, {\n    keys: 'gv',\n    type: 'action',\n    action: 'reselectLastSelection'\n  }, {\n    keys: 'J',\n    type: 'action',\n    action: 'joinLines',\n    isEdit: true\n  }, {\n    keys: 'gJ',\n    type: 'action',\n    action: 'joinLines',\n    actionArgs: {\n      keepSpaces: true\n    },\n    isEdit: true\n  }, {\n    keys: 'p',\n    type: 'action',\n    action: 'paste',\n    isEdit: true,\n    actionArgs: {\n      after: true,\n      isEdit: true\n    }\n  }, {\n    keys: 'P',\n    type: 'action',\n    action: 'paste',\n    isEdit: true,\n    actionArgs: {\n      after: false,\n      isEdit: true\n    }\n  }, {\n    keys: 'r<character>',\n    type: 'action',\n    action: 'replace',\n    isEdit: true\n  }, {\n    keys: '@<character>',\n    type: 'action',\n    action: 'replayMacro'\n  }, {\n    keys: 'q<character>',\n    type: 'action',\n    action: 'enterMacroRecordMode'\n  }, {\n    keys: 'R',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      replace: true\n    },\n    context: 'normal'\n  }, {\n    keys: 'R',\n    type: 'operator',\n    operator: 'change',\n    operatorArgs: {\n      linewise: true,\n      fullLine: true\n    },\n    context: 'visual',\n    exitVisualBlock: true\n  }, {\n    keys: 'u',\n    type: 'action',\n    action: 'undo',\n    context: 'normal'\n  }, {\n    keys: 'u',\n    type: 'operator',\n    operator: 'changeCase',\n    operatorArgs: {\n      toLower: true\n    },\n    context: 'visual',\n    isEdit: true\n  }, {\n    keys: 'U',\n    type: 'operator',\n    operator: 'changeCase',\n    operatorArgs: {\n      toLower: false\n    },\n    context: 'visual',\n    isEdit: true\n  }, {\n    keys: '<C-r>',\n    type: 'action',\n    action: 'redo'\n  }, {\n    keys: 'm<character>',\n    type: 'action',\n    action: 'setMark'\n  }, {\n    keys: '\"<character>',\n    type: 'action',\n    action: 'setRegister'\n  }, {\n    keys: 'zz',\n    type: 'action',\n    action: 'scrollToCursor',\n    actionArgs: {\n      position: 'center'\n    }\n  }, {\n    keys: 'z.',\n    type: 'action',\n    action: 'scrollToCursor',\n    actionArgs: {\n      position: 'center'\n    },\n    motion: 'moveToFirstNonWhiteSpaceCharacter'\n  }, {\n    keys: 'zt',\n    type: 'action',\n    action: 'scrollToCursor',\n    actionArgs: {\n      position: 'top'\n    }\n  }, {\n    keys: 'z<CR>',\n    type: 'action',\n    action: 'scrollToCursor',\n    actionArgs: {\n      position: 'top'\n    },\n    motion: 'moveToFirstNonWhiteSpaceCharacter'\n  }, {\n    keys: 'zb',\n    type: 'action',\n    action: 'scrollToCursor',\n    actionArgs: {\n      position: 'bottom'\n    }\n  }, {\n    keys: 'z-',\n    type: 'action',\n    action: 'scrollToCursor',\n    actionArgs: {\n      position: 'bottom'\n    },\n    motion: 'moveToFirstNonWhiteSpaceCharacter'\n  }, {\n    keys: '.',\n    type: 'action',\n    action: 'repeatLastEdit'\n  }, {\n    keys: '<C-a>',\n    type: 'action',\n    action: 'incrementNumberToken',\n    isEdit: true,\n    actionArgs: {\n      increase: true,\n      backtrack: false\n    }\n  }, {\n    keys: '<C-x>',\n    type: 'action',\n    action: 'incrementNumberToken',\n    isEdit: true,\n    actionArgs: {\n      increase: false,\n      backtrack: false\n    }\n  }, {\n    keys: '<C-t>',\n    type: 'action',\n    action: 'indent',\n    actionArgs: {\n      indentRight: true\n    },\n    context: 'insert'\n  }, {\n    keys: '<C-d>',\n    type: 'action',\n    action: 'indent',\n    actionArgs: {\n      indentRight: false\n    },\n    context: 'insert'\n  }, {\n    keys: 'a<character>',\n    type: 'motion',\n    motion: 'textObjectManipulation'\n  }, {\n    keys: 'i<character>',\n    type: 'motion',\n    motion: 'textObjectManipulation',\n    motionArgs: {\n      textObjectInner: true\n    }\n  }, {\n    keys: '/',\n    type: 'search',\n    searchArgs: {\n      forward: true,\n      querySrc: 'prompt',\n      toJumplist: true\n    }\n  }, {\n    keys: '?',\n    type: 'search',\n    searchArgs: {\n      forward: false,\n      querySrc: 'prompt',\n      toJumplist: true\n    }\n  }, {\n    keys: '*',\n    type: 'search',\n    searchArgs: {\n      forward: true,\n      querySrc: 'wordUnderCursor',\n      wholeWordOnly: true,\n      toJumplist: true\n    }\n  }, {\n    keys: '#',\n    type: 'search',\n    searchArgs: {\n      forward: false,\n      querySrc: 'wordUnderCursor',\n      wholeWordOnly: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'g*',\n    type: 'search',\n    searchArgs: {\n      forward: true,\n      querySrc: 'wordUnderCursor',\n      toJumplist: true\n    }\n  }, {\n    keys: 'g#',\n    type: 'search',\n    searchArgs: {\n      forward: false,\n      querySrc: 'wordUnderCursor',\n      toJumplist: true\n    }\n  }, {\n    keys: ':',\n    type: 'ex'\n  }];\n  var defaultKeymapLength = defaultKeymap.length;\n  var defaultExCommandMap = [{\n    name: 'colorscheme',\n    shortName: 'colo'\n  }, {\n    name: 'map'\n  }, {\n    name: 'imap',\n    shortName: 'im'\n  }, {\n    name: 'nmap',\n    shortName: 'nm'\n  }, {\n    name: 'vmap',\n    shortName: 'vm'\n  }, {\n    name: 'unmap'\n  }, {\n    name: 'write',\n    shortName: 'w'\n  }, {\n    name: 'undo',\n    shortName: 'u'\n  }, {\n    name: 'redo',\n    shortName: 'red'\n  }, {\n    name: 'set',\n    shortName: 'se'\n  }, {\n    name: 'setlocal',\n    shortName: 'setl'\n  }, {\n    name: 'setglobal',\n    shortName: 'setg'\n  }, {\n    name: 'sort',\n    shortName: 'sor'\n  }, {\n    name: 'substitute',\n    shortName: 's',\n    possiblyAsync: true\n  }, {\n    name: 'nohlsearch',\n    shortName: 'noh'\n  }, {\n    name: 'yank',\n    shortName: 'y'\n  }, {\n    name: 'delmarks',\n    shortName: 'delm'\n  }, {\n    name: 'registers',\n    shortName: 'reg',\n    excludeFromCommandHistory: true\n  }, {\n    name: 'vglobal',\n    shortName: 'v'\n  }, {\n    name: 'global',\n    shortName: 'g'\n  }];\n\n  function enterVimMode(cm) {\n    cm.setOption('disableInput', true);\n    cm.setOption('showCursorWhenSelecting', false);\n    CodeMirror.signal(cm, \"vim-mode-change\", {\n      mode: \"normal\"\n    });\n    cm.on('cursorActivity', onCursorActivity);\n    maybeInitVimState(cm);\n    CodeMirror.on(cm.getInputField(), 'paste', getOnPasteFn(cm));\n  }\n\n  function leaveVimMode(cm) {\n    cm.setOption('disableInput', false);\n    cm.off('cursorActivity', onCursorActivity);\n    CodeMirror.off(cm.getInputField(), 'paste', getOnPasteFn(cm));\n    cm.state.vim = null;\n    if (highlightTimeout) clearTimeout(highlightTimeout);\n  }\n\n  function detachVimMap(cm, next) {\n    if (this == CodeMirror.keyMap.vim) {\n      cm.options.$customCursor = null;\n      CodeMirror.rmClass(cm.getWrapperElement(), \"cm-fat-cursor\");\n    }\n\n    if (!next || next.attach != attachVimMap) leaveVimMode(cm);\n  }\n\n  function attachVimMap(cm, prev) {\n    if (this == CodeMirror.keyMap.vim) {\n      if (cm.curOp) cm.curOp.selectionChanged = true;\n      cm.options.$customCursor = transformCursor;\n      CodeMirror.addClass(cm.getWrapperElement(), \"cm-fat-cursor\");\n    }\n\n    if (!prev || prev.attach != attachVimMap) enterVimMode(cm);\n  }\n\n  CodeMirror.defineOption('vimMode', false, function (cm, val, prev) {\n    if (val && cm.getOption(\"keyMap\") != \"vim\") cm.setOption(\"keyMap\", \"vim\");else if (!val && prev != CodeMirror.Init && /^vim/.test(cm.getOption(\"keyMap\"))) cm.setOption(\"keyMap\", \"default\");\n  });\n\n  function cmKey(key, cm) {\n    if (!cm) {\n      return undefined;\n    }\n\n    if (this[key]) {\n      return this[key];\n    }\n\n    var vimKey = cmKeyToVimKey(key);\n\n    if (!vimKey) {\n      return false;\n    }\n\n    var cmd = vimApi.findKey(cm, vimKey);\n\n    if (typeof cmd == 'function') {\n      CodeMirror.signal(cm, 'vim-keypress', vimKey);\n    }\n\n    return cmd;\n  }\n\n  var modifiers = {\n    Shift: 'S',\n    Ctrl: 'C',\n    Alt: 'A',\n    Cmd: 'D',\n    Mod: 'A',\n    CapsLock: ''\n  };\n  var specialKeys = {\n    Enter: 'CR',\n    Backspace: 'BS',\n    Delete: 'Del',\n    Insert: 'Ins'\n  };\n\n  function cmKeyToVimKey(key) {\n    if (key.charAt(0) == '\\'') {\n      return key.charAt(1);\n    }\n\n    var pieces = key.split(/-(?!$)/);\n    var lastPiece = pieces[pieces.length - 1];\n\n    if (pieces.length == 1 && pieces[0].length == 1) {\n      return false;\n    } else if (pieces.length == 2 && pieces[0] == 'Shift' && lastPiece.length == 1) {\n      return false;\n    }\n\n    var hasCharacter = false;\n\n    for (var i = 0; i < pieces.length; i++) {\n      var piece = pieces[i];\n\n      if (piece in modifiers) {\n        pieces[i] = modifiers[piece];\n      } else {\n        hasCharacter = true;\n      }\n\n      if (piece in specialKeys) {\n        pieces[i] = specialKeys[piece];\n      }\n    }\n\n    if (!hasCharacter) {\n      return false;\n    }\n\n    if (isUpperCase(lastPiece)) {\n      pieces[pieces.length - 1] = lastPiece.toLowerCase();\n    }\n\n    return '<' + pieces.join('-') + '>';\n  }\n\n  function getOnPasteFn(cm) {\n    var vim = cm.state.vim;\n\n    if (!vim.onPasteFn) {\n      vim.onPasteFn = function () {\n        if (!vim.insertMode) {\n          cm.setCursor(offsetCursor(cm.getCursor(), 0, 1));\n          actions.enterInsertMode(cm, {}, vim);\n        }\n      };\n    }\n\n    return vim.onPasteFn;\n  }\n\n  var numberRegex = /[\\d]/;\n  var wordCharTest = [CodeMirror.isWordChar, function (ch) {\n    return ch && !CodeMirror.isWordChar(ch) && !/\\s/.test(ch);\n  }],\n      bigWordCharTest = [function (ch) {\n    return /\\S/.test(ch);\n  }];\n\n  function makeKeyRange(start, size) {\n    var keys = [];\n\n    for (var i = start; i < start + size; i++) {\n      keys.push(String.fromCharCode(i));\n    }\n\n    return keys;\n  }\n\n  var upperCaseAlphabet = makeKeyRange(65, 26);\n  var lowerCaseAlphabet = makeKeyRange(97, 26);\n  var numbers = makeKeyRange(48, 10);\n  var validMarks = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['<', '>']);\n  var validRegisters = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['-', '\"', '.', ':', '_', '/', '+']);\n  var upperCaseChars;\n\n  try {\n    upperCaseChars = new RegExp(\"^[\\\\p{Lu}]$\", \"u\");\n  } catch (_) {\n    upperCaseChars = /^[A-Z]$/;\n  }\n\n  function isLine(cm, line) {\n    return line >= cm.firstLine() && line <= cm.lastLine();\n  }\n\n  function isLowerCase(k) {\n    return /^[a-z]$/.test(k);\n  }\n\n  function isMatchableSymbol(k) {\n    return '()[]{}'.indexOf(k) != -1;\n  }\n\n  function isNumber(k) {\n    return numberRegex.test(k);\n  }\n\n  function isUpperCase(k) {\n    return upperCaseChars.test(k);\n  }\n\n  function isWhiteSpaceString(k) {\n    return /^\\s*$/.test(k);\n  }\n\n  function isEndOfSentenceSymbol(k) {\n    return '.?!'.indexOf(k) != -1;\n  }\n\n  function inArray(val, arr) {\n    for (var i = 0; i < arr.length; i++) {\n      if (arr[i] == val) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  var options = {};\n\n  function defineOption(name, defaultValue, type, aliases, callback) {\n    if (defaultValue === undefined && !callback) {\n      throw Error('defaultValue is required unless callback is provided');\n    }\n\n    if (!type) {\n      type = 'string';\n    }\n\n    options[name] = {\n      type: type,\n      defaultValue: defaultValue,\n      callback: callback\n    };\n\n    if (aliases) {\n      for (var i = 0; i < aliases.length; i++) {\n        options[aliases[i]] = options[name];\n      }\n    }\n\n    if (defaultValue) {\n      setOption(name, defaultValue);\n    }\n  }\n\n  function setOption(name, value, cm, cfg) {\n    var option = options[name];\n    cfg = cfg || {};\n    var scope = cfg.scope;\n\n    if (!option) {\n      return new Error('Unknown option: ' + name);\n    }\n\n    if (option.type == 'boolean') {\n      if (value && value !== true) {\n        return new Error('Invalid argument: ' + name + '=' + value);\n      } else if (value !== false) {\n        value = true;\n      }\n    }\n\n    if (option.callback) {\n      if (scope !== 'local') {\n        option.callback(value, undefined);\n      }\n\n      if (scope !== 'global' && cm) {\n        option.callback(value, cm);\n      }\n    } else {\n      if (scope !== 'local') {\n        option.value = option.type == 'boolean' ? !!value : value;\n      }\n\n      if (scope !== 'global' && cm) {\n        cm.state.vim.options[name] = {\n          value: value\n        };\n      }\n    }\n  }\n\n  function getOption(name, cm, cfg) {\n    var option = options[name];\n    cfg = cfg || {};\n    var scope = cfg.scope;\n\n    if (!option) {\n      return new Error('Unknown option: ' + name);\n    }\n\n    if (option.callback) {\n      var local = cm && option.callback(undefined, cm);\n\n      if (scope !== 'global' && local !== undefined) {\n        return local;\n      }\n\n      if (scope !== 'local') {\n        return option.callback();\n      }\n\n      return;\n    } else {\n      var local = scope !== 'global' && cm && cm.state.vim.options[name];\n      return (local || scope !== 'local' && option || {}).value;\n    }\n  }\n\n  defineOption('filetype', undefined, 'string', ['ft'], function (name, cm) {\n    if (cm === undefined) {\n      return;\n    }\n\n    if (name === undefined) {\n      var mode = cm.getOption('mode');\n      return mode == 'null' ? '' : mode;\n    } else {\n      var mode = name == '' ? 'null' : name;\n      cm.setOption('mode', mode);\n    }\n  });\n\n  var createCircularJumpList = function () {\n    var size = 100;\n    var pointer = -1;\n    var head = 0;\n    var tail = 0;\n    var buffer = new Array(size);\n\n    function add(cm, oldCur, newCur) {\n      var current = pointer % size;\n      var curMark = buffer[current];\n\n      function useNextSlot(cursor) {\n        var next = ++pointer % size;\n        var trashMark = buffer[next];\n\n        if (trashMark) {\n          trashMark.clear();\n        }\n\n        buffer[next] = cm.setBookmark(cursor);\n      }\n\n      if (curMark) {\n        var markPos = curMark.find();\n\n        if (markPos && !cursorEqual(markPos, oldCur)) {\n          useNextSlot(oldCur);\n        }\n      } else {\n        useNextSlot(oldCur);\n      }\n\n      useNextSlot(newCur);\n      head = pointer;\n      tail = pointer - size + 1;\n\n      if (tail < 0) {\n        tail = 0;\n      }\n    }\n\n    function move(cm, offset) {\n      pointer += offset;\n\n      if (pointer > head) {\n        pointer = head;\n      } else if (pointer < tail) {\n        pointer = tail;\n      }\n\n      var mark = buffer[(size + pointer) % size];\n\n      if (mark && !mark.find()) {\n        var inc = offset > 0 ? 1 : -1;\n        var newCur;\n        var oldCur = cm.getCursor();\n\n        do {\n          pointer += inc;\n          mark = buffer[(size + pointer) % size];\n\n          if (mark && (newCur = mark.find()) && !cursorEqual(oldCur, newCur)) {\n            break;\n          }\n        } while (pointer < head && pointer > tail);\n      }\n\n      return mark;\n    }\n\n    function find(cm, offset) {\n      var oldPointer = pointer;\n      var mark = move(cm, offset);\n      pointer = oldPointer;\n      return mark && mark.find();\n    }\n\n    return {\n      cachedCursor: undefined,\n      add: add,\n      find: find,\n      move: move\n    };\n  };\n\n  var createInsertModeChanges = function (c) {\n    if (c) {\n      return {\n        changes: c.changes,\n        expectCursorActivityForChange: c.expectCursorActivityForChange\n      };\n    }\n\n    return {\n      changes: [],\n      expectCursorActivityForChange: false\n    };\n  };\n\n  function MacroModeState() {\n    this.latestRegister = undefined;\n    this.isPlaying = false;\n    this.isRecording = false;\n    this.replaySearchQueries = [];\n    this.onRecordingDone = undefined;\n    this.lastInsertModeChanges = createInsertModeChanges();\n  }\n\n  MacroModeState.prototype = {\n    exitMacroRecordMode: function () {\n      var macroModeState = vimGlobalState.macroModeState;\n\n      if (macroModeState.onRecordingDone) {\n        macroModeState.onRecordingDone(); // close dialog\n      }\n\n      macroModeState.onRecordingDone = undefined;\n      macroModeState.isRecording = false;\n    },\n    enterMacroRecordMode: function (cm, registerName) {\n      var register = vimGlobalState.registerController.getRegister(registerName);\n\n      if (register) {\n        register.clear();\n        this.latestRegister = registerName;\n\n        if (cm.openDialog) {\n          var template = dom('span', {\n            class: 'cm-vim-message'\n          }, 'recording @' + registerName);\n          this.onRecordingDone = cm.openDialog(template, null, {\n            bottom: true\n          });\n        }\n\n        this.isRecording = true;\n      }\n    }\n  };\n\n  function maybeInitVimState(cm) {\n    if (!cm.state.vim) {\n      cm.state.vim = {\n        inputState: new InputState(),\n        lastEditInputState: undefined,\n        lastEditActionCommand: undefined,\n        lastHPos: -1,\n        lastHSPos: -1,\n        lastMotion: null,\n        marks: {},\n        insertMode: false,\n        insertModeRepeat: undefined,\n        visualMode: false,\n        visualLine: false,\n        visualBlock: false,\n        lastSelection: null,\n        lastPastedText: null,\n        sel: {},\n        options: {}\n      };\n    }\n\n    return cm.state.vim;\n  }\n\n  var vimGlobalState;\n\n  function resetVimGlobalState() {\n    vimGlobalState = {\n      searchQuery: null,\n      searchIsReversed: false,\n      lastSubstituteReplacePart: undefined,\n      jumpList: createCircularJumpList(),\n      macroModeState: new MacroModeState(),\n      lastCharacterSearch: {\n        increment: 0,\n        forward: true,\n        selectedCharacter: ''\n      },\n      registerController: new RegisterController({}),\n      searchHistoryController: new HistoryController(),\n      exCommandHistoryController: new HistoryController()\n    };\n\n    for (var optionName in options) {\n      var option = options[optionName];\n      option.value = option.defaultValue;\n    }\n  }\n\n  var lastInsertModeKeyTimer;\n  var vimApi = {\n    enterVimMode: enterVimMode,\n    leaveVimMode: leaveVimMode,\n    buildKeyMap: function () {},\n    getRegisterController: function () {\n      return vimGlobalState.registerController;\n    },\n    resetVimGlobalState_: resetVimGlobalState,\n    getVimGlobalState_: function () {\n      return vimGlobalState;\n    },\n    maybeInitVimState_: maybeInitVimState,\n    suppressErrorLogging: false,\n    InsertModeKey: InsertModeKey,\n    map: function (lhs, rhs, ctx) {\n      exCommandDispatcher.map(lhs, rhs, ctx);\n    },\n    unmap: function (lhs, ctx) {\n      return exCommandDispatcher.unmap(lhs, ctx);\n    },\n    noremap: function (lhs, rhs, ctx) {\n      function toCtxArray(ctx) {\n        return ctx ? [ctx] : ['normal', 'insert', 'visual'];\n      }\n\n      var ctxsToMap = toCtxArray(ctx);\n      var actualLength = defaultKeymap.length,\n          origLength = defaultKeymapLength;\n\n      for (var i = actualLength - origLength; i < actualLength && ctxsToMap.length; i++) {\n        var mapping = defaultKeymap[i];\n\n        if (mapping.keys == rhs && (!ctx || !mapping.context || mapping.context === ctx) && mapping.type.substr(0, 2) !== 'ex' && mapping.type.substr(0, 3) !== 'key') {\n          var newMapping = {};\n\n          for (var key in mapping) {\n            newMapping[key] = mapping[key];\n          }\n\n          newMapping.keys = lhs;\n\n          if (ctx && !newMapping.context) {\n            newMapping.context = ctx;\n          }\n\n          this._mapCommand(newMapping);\n\n          var mappedCtxs = toCtxArray(mapping.context);\n          ctxsToMap = ctxsToMap.filter(function (el) {\n            return mappedCtxs.indexOf(el) === -1;\n          });\n        }\n      }\n    },\n    mapclear: function (ctx) {\n      var actualLength = defaultKeymap.length,\n          origLength = defaultKeymapLength;\n      var userKeymap = defaultKeymap.slice(0, actualLength - origLength);\n      defaultKeymap = defaultKeymap.slice(actualLength - origLength);\n\n      if (ctx) {\n        for (var i = userKeymap.length - 1; i >= 0; i--) {\n          var mapping = userKeymap[i];\n\n          if (ctx !== mapping.context) {\n            if (mapping.context) {\n              this._mapCommand(mapping);\n            } else {\n              var contexts = ['normal', 'insert', 'visual'];\n\n              for (var j in contexts) {\n                if (contexts[j] !== ctx) {\n                  var newMapping = {};\n\n                  for (var key in mapping) {\n                    newMapping[key] = mapping[key];\n                  }\n\n                  newMapping.context = contexts[j];\n\n                  this._mapCommand(newMapping);\n                }\n              }\n            }\n          }\n        }\n      }\n    },\n    setOption: setOption,\n    getOption: getOption,\n    defineOption: defineOption,\n    defineEx: function (name, prefix, func) {\n      if (!prefix) {\n        prefix = name;\n      } else if (name.indexOf(prefix) !== 0) {\n        throw new Error('(Vim.defineEx) \"' + prefix + '\" is not a prefix of \"' + name + '\", command not registered');\n      }\n\n      exCommands[name] = func;\n      exCommandDispatcher.commandMap_[prefix] = {\n        name: name,\n        shortName: prefix,\n        type: 'api'\n      };\n    },\n    handleKey: function (cm, key, origin) {\n      var command = this.findKey(cm, key, origin);\n\n      if (typeof command === 'function') {\n        return command();\n      }\n    },\n    multiSelectHandleKey: multiSelectHandleKey,\n    findKey: function (cm, key, origin) {\n      var vim = maybeInitVimState(cm);\n\n      function handleMacroRecording() {\n        var macroModeState = vimGlobalState.macroModeState;\n\n        if (macroModeState.isRecording) {\n          if (key == 'q') {\n            macroModeState.exitMacroRecordMode();\n            clearInputState(cm);\n            return true;\n          }\n\n          if (origin != 'mapping') {\n            logKey(macroModeState, key);\n          }\n        }\n      }\n\n      function handleEsc() {\n        if (key == '<Esc>') {\n          if (vim.visualMode) {\n            exitVisualMode(cm);\n          } else if (vim.insertMode) {\n            exitInsertMode(cm);\n          } else {\n            return;\n          }\n\n          clearInputState(cm);\n          return true;\n        }\n      }\n\n      function doKeyToKey(keys) {\n        var match;\n\n        while (keys) {\n          match = /<\\w+-.+?>|<\\w+>|./.exec(keys);\n          key = match[0];\n          keys = keys.substring(match.index + key.length);\n          vimApi.handleKey(cm, key, 'mapping');\n        }\n      }\n\n      function handleKeyInsertMode() {\n        if (handleEsc()) {\n          return true;\n        }\n\n        var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;\n        var keysAreChars = key.length == 1;\n        var match = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\n\n        while (keys.length > 1 && match.type != 'full') {\n          var keys = vim.inputState.keyBuffer = keys.slice(1);\n          var thisMatch = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\n\n          if (thisMatch.type != 'none') {\n            match = thisMatch;\n          }\n        }\n\n        if (match.type == 'none') {\n          clearInputState(cm);\n          return false;\n        } else if (match.type == 'partial') {\n          if (lastInsertModeKeyTimer) {\n            window.clearTimeout(lastInsertModeKeyTimer);\n          }\n\n          lastInsertModeKeyTimer = window.setTimeout(function () {\n            if (vim.insertMode && vim.inputState.keyBuffer) {\n              clearInputState(cm);\n            }\n          }, getOption('insertModeEscKeysTimeout'));\n          return !keysAreChars;\n        }\n\n        if (lastInsertModeKeyTimer) {\n          window.clearTimeout(lastInsertModeKeyTimer);\n        }\n\n        if (keysAreChars) {\n          var selections = cm.listSelections();\n\n          for (var i = 0; i < selections.length; i++) {\n            var here = selections[i].head;\n            cm.replaceRange('', offsetCursor(here, 0, -(keys.length - 1)), here, '+input');\n          }\n\n          vimGlobalState.macroModeState.lastInsertModeChanges.changes.pop();\n        }\n\n        clearInputState(cm);\n        return match.command;\n      }\n\n      function handleKeyNonInsertMode() {\n        if (handleMacroRecording() || handleEsc()) {\n          return true;\n        }\n\n        var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;\n\n        if (/^[1-9]\\d*$/.test(keys)) {\n          return true;\n        }\n\n        var keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n\n        if (!keysMatcher) {\n          clearInputState(cm);\n          return false;\n        }\n\n        var context = vim.visualMode ? 'visual' : 'normal';\n        var mainKey = keysMatcher[2] || keysMatcher[1];\n\n        if (vim.inputState.operatorShortcut && vim.inputState.operatorShortcut.slice(-1) == mainKey) {\n          mainKey = vim.inputState.operatorShortcut;\n        }\n\n        var match = commandDispatcher.matchCommand(mainKey, defaultKeymap, vim.inputState, context);\n\n        if (match.type == 'none') {\n          clearInputState(cm);\n          return false;\n        } else if (match.type == 'partial') {\n          return true;\n        } else if (match.type == 'clear') {\n          clearInputState(cm);\n          return true;\n        }\n\n        vim.inputState.keyBuffer = '';\n        keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n\n        if (keysMatcher[1] && keysMatcher[1] != '0') {\n          vim.inputState.pushRepeatDigit(keysMatcher[1]);\n        }\n\n        return match.command;\n      }\n\n      var command;\n\n      if (vim.insertMode) {\n        command = handleKeyInsertMode();\n      } else {\n        command = handleKeyNonInsertMode();\n      }\n\n      if (command === false) {\n        return undefined; //ace_patch\n      } else if (command === true) {\n        return function () {\n          return true;\n        };\n      } else {\n        return function () {\n          if ((command.operator || command.isEdit) && cm.getOption('readOnly')) return; // ace_patch\n\n          return cm.operation(function () {\n            cm.curOp.isVimOp = true;\n\n            try {\n              if (command.type == 'keyToKey') {\n                doKeyToKey(command.toKeys);\n              } else {\n                commandDispatcher.processCommand(cm, vim, command);\n              }\n            } catch (e) {\n              cm.state.vim = undefined;\n              maybeInitVimState(cm);\n\n              if (!vimApi.suppressErrorLogging) {\n                console['log'](e);\n              }\n\n              throw e;\n            }\n\n            return true;\n          });\n        };\n      }\n    },\n    handleEx: function (cm, input) {\n      exCommandDispatcher.processCommand(cm, input);\n    },\n    defineMotion: defineMotion,\n    defineAction: defineAction,\n    defineOperator: defineOperator,\n    mapCommand: mapCommand,\n    _mapCommand: _mapCommand,\n    defineRegister: defineRegister,\n    exitVisualMode: exitVisualMode,\n    exitInsertMode: exitInsertMode\n  };\n\n  function InputState() {\n    this.prefixRepeat = [];\n    this.motionRepeat = [];\n    this.operator = null;\n    this.operatorArgs = null;\n    this.motion = null;\n    this.motionArgs = null;\n    this.keyBuffer = []; // For matching multi-key commands.\n\n    this.registerName = null; // Defaults to the unnamed register.\n  }\n\n  InputState.prototype.pushRepeatDigit = function (n) {\n    if (!this.operator) {\n      this.prefixRepeat = this.prefixRepeat.concat(n);\n    } else {\n      this.motionRepeat = this.motionRepeat.concat(n);\n    }\n  };\n\n  InputState.prototype.getRepeat = function () {\n    var repeat = 0;\n\n    if (this.prefixRepeat.length > 0 || this.motionRepeat.length > 0) {\n      repeat = 1;\n\n      if (this.prefixRepeat.length > 0) {\n        repeat *= parseInt(this.prefixRepeat.join(''), 10);\n      }\n\n      if (this.motionRepeat.length > 0) {\n        repeat *= parseInt(this.motionRepeat.join(''), 10);\n      }\n    }\n\n    return repeat;\n  };\n\n  function clearInputState(cm, reason) {\n    cm.state.vim.inputState = new InputState();\n    CodeMirror.signal(cm, 'vim-command-done', reason);\n  }\n\n  function Register(text, linewise, blockwise) {\n    this.clear();\n    this.keyBuffer = [text || ''];\n    this.insertModeChanges = [];\n    this.searchQueries = [];\n    this.linewise = !!linewise;\n    this.blockwise = !!blockwise;\n  }\n\n  Register.prototype = {\n    setText: function (text, linewise, blockwise) {\n      this.keyBuffer = [text || ''];\n      this.linewise = !!linewise;\n      this.blockwise = !!blockwise;\n    },\n    pushText: function (text, linewise) {\n      if (linewise) {\n        if (!this.linewise) {\n          this.keyBuffer.push('\\n');\n        }\n\n        this.linewise = true;\n      }\n\n      this.keyBuffer.push(text);\n    },\n    pushInsertModeChanges: function (changes) {\n      this.insertModeChanges.push(createInsertModeChanges(changes));\n    },\n    pushSearchQuery: function (query) {\n      this.searchQueries.push(query);\n    },\n    clear: function () {\n      this.keyBuffer = [];\n      this.insertModeChanges = [];\n      this.searchQueries = [];\n      this.linewise = false;\n    },\n    toString: function () {\n      return this.keyBuffer.join('');\n    }\n  };\n\n  function defineRegister(name, register) {\n    var registers = vimGlobalState.registerController.registers;\n\n    if (!name || name.length != 1) {\n      throw Error('Register name must be 1 character');\n    }\n\n    registers[name] = register;\n    validRegisters.push(name);\n  }\n\n  function RegisterController(registers) {\n    this.registers = registers;\n    this.unnamedRegister = registers['\"'] = new Register();\n    registers['.'] = new Register();\n    registers[':'] = new Register();\n    registers['/'] = new Register();\n    registers['+'] = new Register();\n  }\n\n  RegisterController.prototype = {\n    pushText: function (registerName, operator, text, linewise, blockwise) {\n      if (registerName === '_') return;\n\n      if (linewise && text.charAt(text.length - 1) !== '\\n') {\n        text += '\\n';\n      }\n\n      var register = this.isValidRegister(registerName) ? this.getRegister(registerName) : null;\n\n      if (!register) {\n        switch (operator) {\n          case 'yank':\n            this.registers['0'] = new Register(text, linewise, blockwise);\n            break;\n\n          case 'delete':\n          case 'change':\n            if (text.indexOf('\\n') == -1) {\n              this.registers['-'] = new Register(text, linewise);\n            } else {\n              this.shiftNumericRegisters_();\n              this.registers['1'] = new Register(text, linewise);\n            }\n\n            break;\n        }\n\n        this.unnamedRegister.setText(text, linewise, blockwise);\n        return;\n      }\n\n      var append = isUpperCase(registerName);\n\n      if (append) {\n        register.pushText(text, linewise);\n      } else {\n        register.setText(text, linewise, blockwise);\n      }\n\n      if (registerName === '+' && typeof navigator !== 'undefined' && typeof navigator.clipboard !== 'undefined' && typeof navigator.clipboard.readText === 'function') {\n        navigator.clipboard.writeText(text);\n      }\n\n      this.unnamedRegister.setText(register.toString(), linewise);\n    },\n    getRegister: function (name) {\n      if (!this.isValidRegister(name)) {\n        return this.unnamedRegister;\n      }\n\n      name = name.toLowerCase();\n\n      if (!this.registers[name]) {\n        this.registers[name] = new Register();\n      }\n\n      return this.registers[name];\n    },\n    isValidRegister: function (name) {\n      return name && inArray(name, validRegisters);\n    },\n    shiftNumericRegisters_: function () {\n      for (var i = 9; i >= 2; i--) {\n        this.registers[i] = this.getRegister('' + (i - 1));\n      }\n    }\n  };\n\n  function HistoryController() {\n    this.historyBuffer = [];\n    this.iterator = 0;\n    this.initialPrefix = null;\n  }\n\n  HistoryController.prototype = {\n    nextMatch: function (input, up) {\n      var historyBuffer = this.historyBuffer;\n      var dir = up ? -1 : 1;\n      if (this.initialPrefix === null) this.initialPrefix = input;\n\n      for (var i = this.iterator + dir; up ? i >= 0 : i < historyBuffer.length; i += dir) {\n        var element = historyBuffer[i];\n\n        for (var j = 0; j <= element.length; j++) {\n          if (this.initialPrefix == element.substring(0, j)) {\n            this.iterator = i;\n            return element;\n          }\n        }\n      }\n\n      if (i >= historyBuffer.length) {\n        this.iterator = historyBuffer.length;\n        return this.initialPrefix;\n      }\n\n      if (i < 0) return input;\n    },\n    pushInput: function (input) {\n      var index = this.historyBuffer.indexOf(input);\n      if (index > -1) this.historyBuffer.splice(index, 1);\n      if (input.length) this.historyBuffer.push(input);\n    },\n    reset: function () {\n      this.initialPrefix = null;\n      this.iterator = this.historyBuffer.length;\n    }\n  };\n  var commandDispatcher = {\n    matchCommand: function (keys, keyMap, inputState, context) {\n      var matches = commandMatches(keys, keyMap, context, inputState);\n\n      if (!matches.full && !matches.partial) {\n        return {\n          type: 'none'\n        };\n      } else if (!matches.full && matches.partial) {\n        return {\n          type: 'partial'\n        };\n      }\n\n      var bestMatch;\n\n      for (var i = 0; i < matches.full.length; i++) {\n        var match = matches.full[i];\n\n        if (!bestMatch) {\n          bestMatch = match;\n        }\n      }\n\n      if (bestMatch.keys.slice(-11) == '<character>') {\n        var character = lastChar(keys);\n        if (!character || character.length > 1) return {\n          type: 'clear'\n        };\n        inputState.selectedCharacter = character;\n      }\n\n      return {\n        type: 'full',\n        command: bestMatch\n      };\n    },\n    processCommand: function (cm, vim, command) {\n      vim.inputState.repeatOverride = command.repeatOverride;\n\n      switch (command.type) {\n        case 'motion':\n          this.processMotion(cm, vim, command);\n          break;\n\n        case 'operator':\n          this.processOperator(cm, vim, command);\n          break;\n\n        case 'operatorMotion':\n          this.processOperatorMotion(cm, vim, command);\n          break;\n\n        case 'action':\n          this.processAction(cm, vim, command);\n          break;\n\n        case 'search':\n          this.processSearch(cm, vim, command);\n          break;\n\n        case 'ex':\n        case 'keyToEx':\n          this.processEx(cm, vim, command);\n          break;\n\n        default:\n          break;\n      }\n    },\n    processMotion: function (cm, vim, command) {\n      vim.inputState.motion = command.motion;\n      vim.inputState.motionArgs = copyArgs(command.motionArgs);\n      this.evalInput(cm, vim);\n    },\n    processOperator: function (cm, vim, command) {\n      var inputState = vim.inputState;\n\n      if (inputState.operator) {\n        if (inputState.operator == command.operator) {\n          inputState.motion = 'expandToLine';\n          inputState.motionArgs = {\n            linewise: true\n          };\n          this.evalInput(cm, vim);\n          return;\n        } else {\n          clearInputState(cm);\n        }\n      }\n\n      inputState.operator = command.operator;\n      inputState.operatorArgs = copyArgs(command.operatorArgs);\n\n      if (command.keys.length > 1) {\n        inputState.operatorShortcut = command.keys;\n      }\n\n      if (command.exitVisualBlock) {\n        vim.visualBlock = false;\n        updateCmSelection(cm);\n      }\n\n      if (vim.visualMode) {\n        this.evalInput(cm, vim);\n      }\n    },\n    processOperatorMotion: function (cm, vim, command) {\n      var visualMode = vim.visualMode;\n      var operatorMotionArgs = copyArgs(command.operatorMotionArgs);\n\n      if (operatorMotionArgs) {\n        if (visualMode && operatorMotionArgs.visualLine) {\n          vim.visualLine = true;\n        }\n      }\n\n      this.processOperator(cm, vim, command);\n\n      if (!visualMode) {\n        this.processMotion(cm, vim, command);\n      }\n    },\n    processAction: function (cm, vim, command) {\n      var inputState = vim.inputState;\n      var repeat = inputState.getRepeat();\n      var repeatIsExplicit = !!repeat;\n      var actionArgs = copyArgs(command.actionArgs) || {};\n\n      if (inputState.selectedCharacter) {\n        actionArgs.selectedCharacter = inputState.selectedCharacter;\n      }\n\n      if (command.operator) {\n        this.processOperator(cm, vim, command);\n      }\n\n      if (command.motion) {\n        this.processMotion(cm, vim, command);\n      }\n\n      if (command.motion || command.operator) {\n        this.evalInput(cm, vim);\n      }\n\n      actionArgs.repeat = repeat || 1;\n      actionArgs.repeatIsExplicit = repeatIsExplicit;\n      actionArgs.registerName = inputState.registerName;\n      clearInputState(cm);\n      vim.lastMotion = null;\n\n      if (command.isEdit) {\n        this.recordLastEdit(vim, inputState, command);\n      }\n\n      actions[command.action](cm, actionArgs, vim);\n    },\n    processSearch: function (cm, vim, command) {\n      if (!cm.getSearchCursor) {\n        return;\n      }\n\n      var forward = command.searchArgs.forward;\n      var wholeWordOnly = command.searchArgs.wholeWordOnly;\n      getSearchState(cm).setReversed(!forward);\n      var promptPrefix = forward ? '/' : '?';\n      var originalQuery = getSearchState(cm).getQuery();\n      var originalScrollPos = cm.getScrollInfo();\n\n      function handleQuery(query, ignoreCase, smartCase) {\n        vimGlobalState.searchHistoryController.pushInput(query);\n        vimGlobalState.searchHistoryController.reset();\n\n        try {\n          updateSearchQuery(cm, query, ignoreCase, smartCase);\n        } catch (e) {\n          showConfirm(cm, 'Invalid regex: ' + query);\n          clearInputState(cm);\n          return;\n        }\n\n        commandDispatcher.processMotion(cm, vim, {\n          type: 'motion',\n          motion: 'findNext',\n          motionArgs: {\n            forward: true,\n            toJumplist: command.searchArgs.toJumplist\n          }\n        });\n      }\n\n      function onPromptClose(query) {\n        handleQuery(query, true\n        /** ignoreCase */\n        , true\n        /** smartCase */\n        );\n        var macroModeState = vimGlobalState.macroModeState;\n\n        if (macroModeState.isRecording) {\n          logSearchQuery(macroModeState, query);\n        }\n      }\n\n      function onPromptKeyUp(e, query, close) {\n        var keyName = CodeMirror.keyName(e),\n            up,\n            offset;\n\n        if (keyName == 'Up' || keyName == 'Down') {\n          up = keyName == 'Up' ? true : false;\n          offset = e.target ? e.target.selectionEnd : 0;\n          query = vimGlobalState.searchHistoryController.nextMatch(query, up) || '';\n          close(query);\n          if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n        } else {\n          if (keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift') vimGlobalState.searchHistoryController.reset();\n        }\n\n        var parsedQuery;\n\n        try {\n          parsedQuery = updateSearchQuery(cm, query, true\n          /** ignoreCase */\n          , true\n          /** smartCase */\n          );\n        } catch (e) {}\n\n        if (parsedQuery) {\n          cm.scrollIntoView(findNext(cm, !forward, parsedQuery), 30);\n        } else {\n          clearSearchHighlight(cm);\n          cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n        }\n      }\n\n      function onPromptKeyDown(e, query, close) {\n        var keyName = CodeMirror.keyName(e);\n\n        if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' || keyName == 'Backspace' && query == '') {\n          vimGlobalState.searchHistoryController.pushInput(query);\n          vimGlobalState.searchHistoryController.reset();\n          updateSearchQuery(cm, originalQuery);\n          clearSearchHighlight(cm);\n          cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n          CodeMirror.e_stop(e);\n          clearInputState(cm);\n          close();\n          cm.focus();\n        } else if (keyName == 'Up' || keyName == 'Down') {\n          CodeMirror.e_stop(e);\n        } else if (keyName == 'Ctrl-U') {\n          CodeMirror.e_stop(e);\n          close('');\n        }\n      }\n\n      switch (command.searchArgs.querySrc) {\n        case 'prompt':\n          var macroModeState = vimGlobalState.macroModeState;\n\n          if (macroModeState.isPlaying) {\n            var query = macroModeState.replaySearchQueries.shift();\n            handleQuery(query, true\n            /** ignoreCase */\n            , false\n            /** smartCase */\n            );\n          } else {\n            showPrompt(cm, {\n              onClose: onPromptClose,\n              prefix: promptPrefix,\n              desc: '(JavaScript regexp)',\n              onKeyUp: onPromptKeyUp,\n              onKeyDown: onPromptKeyDown\n            });\n          }\n\n          break;\n\n        case 'wordUnderCursor':\n          var word = expandWordUnderCursor(cm, false\n          /** inclusive */\n          , true\n          /** forward */\n          , false\n          /** bigWord */\n          , true\n          /** noSymbol */\n          );\n          var isKeyword = true;\n\n          if (!word) {\n            word = expandWordUnderCursor(cm, false\n            /** inclusive */\n            , true\n            /** forward */\n            , false\n            /** bigWord */\n            , false\n            /** noSymbol */\n            );\n            isKeyword = false;\n          }\n\n          if (!word) {\n            return;\n          }\n\n          var query = cm.getLine(word.start.line).substring(word.start.ch, word.end.ch);\n\n          if (isKeyword && wholeWordOnly) {\n            query = '\\\\b' + query + '\\\\b';\n          } else {\n            query = escapeRegex(query);\n          }\n\n          vimGlobalState.jumpList.cachedCursor = cm.getCursor();\n          cm.setCursor(word.start);\n          handleQuery(query, true\n          /** ignoreCase */\n          , false\n          /** smartCase */\n          );\n          break;\n      }\n    },\n    processEx: function (cm, vim, command) {\n      function onPromptClose(input) {\n        vimGlobalState.exCommandHistoryController.pushInput(input);\n        vimGlobalState.exCommandHistoryController.reset();\n        exCommandDispatcher.processCommand(cm, input);\n        if (cm.state.vim) clearInputState(cm);\n      }\n\n      function onPromptKeyDown(e, input, close) {\n        var keyName = CodeMirror.keyName(e),\n            up,\n            offset;\n\n        if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' || keyName == 'Backspace' && input == '') {\n          vimGlobalState.exCommandHistoryController.pushInput(input);\n          vimGlobalState.exCommandHistoryController.reset();\n          CodeMirror.e_stop(e);\n          clearInputState(cm);\n          close();\n          cm.focus();\n        }\n\n        if (keyName == 'Up' || keyName == 'Down') {\n          CodeMirror.e_stop(e);\n          up = keyName == 'Up' ? true : false;\n          offset = e.target ? e.target.selectionEnd : 0;\n          input = vimGlobalState.exCommandHistoryController.nextMatch(input, up) || '';\n          close(input);\n          if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n        } else if (keyName == 'Ctrl-U') {\n          CodeMirror.e_stop(e);\n          close('');\n        } else {\n          if (keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift') vimGlobalState.exCommandHistoryController.reset();\n        }\n      }\n\n      if (command.type == 'keyToEx') {\n        exCommandDispatcher.processCommand(cm, command.exArgs.input);\n      } else {\n        if (vim.visualMode) {\n          showPrompt(cm, {\n            onClose: onPromptClose,\n            prefix: ':',\n            value: '\\'<,\\'>',\n            onKeyDown: onPromptKeyDown,\n            selectValueOnOpen: false\n          });\n        } else {\n          showPrompt(cm, {\n            onClose: onPromptClose,\n            prefix: ':',\n            onKeyDown: onPromptKeyDown\n          });\n        }\n      }\n    },\n    evalInput: function (cm, vim) {\n      var inputState = vim.inputState;\n      var motion = inputState.motion;\n      var motionArgs = inputState.motionArgs || {};\n      var operator = inputState.operator;\n      var operatorArgs = inputState.operatorArgs || {};\n      var registerName = inputState.registerName;\n      var sel = vim.sel;\n      var origHead = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.head) : cm.getCursor('head'));\n      var origAnchor = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.anchor) : cm.getCursor('anchor'));\n      var oldHead = copyCursor(origHead);\n      var oldAnchor = copyCursor(origAnchor);\n      var newHead, newAnchor;\n      var repeat;\n\n      if (operator) {\n        this.recordLastEdit(vim, inputState);\n      }\n\n      if (inputState.repeatOverride !== undefined) {\n        repeat = inputState.repeatOverride;\n      } else {\n        repeat = inputState.getRepeat();\n      }\n\n      if (repeat > 0 && motionArgs.explicitRepeat) {\n        motionArgs.repeatIsExplicit = true;\n      } else if (motionArgs.noRepeat || !motionArgs.explicitRepeat && repeat === 0) {\n        repeat = 1;\n        motionArgs.repeatIsExplicit = false;\n      }\n\n      if (inputState.selectedCharacter) {\n        motionArgs.selectedCharacter = operatorArgs.selectedCharacter = inputState.selectedCharacter;\n      }\n\n      motionArgs.repeat = repeat;\n      clearInputState(cm);\n\n      if (motion) {\n        var motionResult = motions[motion](cm, origHead, motionArgs, vim, inputState);\n        vim.lastMotion = motions[motion];\n\n        if (!motionResult) {\n          return;\n        }\n\n        if (motionArgs.toJumplist) {\n          if (!operator && cm.ace.curOp != null) cm.ace.curOp.command.scrollIntoView = \"center-animate\"; // ace_patch\n\n          var jumpList = vimGlobalState.jumpList;\n          var cachedCursor = jumpList.cachedCursor;\n\n          if (cachedCursor) {\n            recordJumpPosition(cm, cachedCursor, motionResult);\n            delete jumpList.cachedCursor;\n          } else {\n            recordJumpPosition(cm, origHead, motionResult);\n          }\n        }\n\n        if (motionResult instanceof Array) {\n          newAnchor = motionResult[0];\n          newHead = motionResult[1];\n        } else {\n          newHead = motionResult;\n        }\n\n        if (!newHead) {\n          newHead = copyCursor(origHead);\n        }\n\n        if (vim.visualMode) {\n          if (!(vim.visualBlock && newHead.ch === Infinity)) {\n            newHead = clipCursorToContent(cm, newHead, oldHead);\n          }\n\n          if (newAnchor) {\n            newAnchor = clipCursorToContent(cm, newAnchor);\n          }\n\n          newAnchor = newAnchor || oldAnchor;\n          sel.anchor = newAnchor;\n          sel.head = newHead;\n          updateCmSelection(cm);\n          updateMark(cm, vim, '<', cursorIsBefore(newAnchor, newHead) ? newAnchor : newHead);\n          updateMark(cm, vim, '>', cursorIsBefore(newAnchor, newHead) ? newHead : newAnchor);\n        } else if (!operator) {\n          if (cm.ace.curOp) cm.ace.curOp.vimDialogScroll = \"center-animate\"; // ace_patch\n\n          newHead = clipCursorToContent(cm, newHead, oldHead);\n          cm.setCursor(newHead.line, newHead.ch);\n        }\n      }\n\n      if (operator) {\n        if (operatorArgs.lastSel) {\n          newAnchor = oldAnchor;\n          var lastSel = operatorArgs.lastSel;\n          var lineOffset = Math.abs(lastSel.head.line - lastSel.anchor.line);\n          var chOffset = Math.abs(lastSel.head.ch - lastSel.anchor.ch);\n\n          if (lastSel.visualLine) {\n            newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n          } else if (lastSel.visualBlock) {\n            newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch + chOffset);\n          } else if (lastSel.head.line == lastSel.anchor.line) {\n            newHead = new Pos(oldAnchor.line, oldAnchor.ch + chOffset);\n          } else {\n            newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n          }\n\n          vim.visualMode = true;\n          vim.visualLine = lastSel.visualLine;\n          vim.visualBlock = lastSel.visualBlock;\n          sel = vim.sel = {\n            anchor: newAnchor,\n            head: newHead\n          };\n          updateCmSelection(cm);\n        } else if (vim.visualMode) {\n          operatorArgs.lastSel = {\n            anchor: copyCursor(sel.anchor),\n            head: copyCursor(sel.head),\n            visualBlock: vim.visualBlock,\n            visualLine: vim.visualLine\n          };\n        }\n\n        var curStart, curEnd, linewise, mode;\n        var cmSel;\n\n        if (vim.visualMode) {\n          curStart = cursorMin(sel.head, sel.anchor);\n          curEnd = cursorMax(sel.head, sel.anchor);\n          linewise = vim.visualLine || operatorArgs.linewise;\n          mode = vim.visualBlock ? 'block' : linewise ? 'line' : 'char';\n          var newPositions = updateSelectionForSurrogateCharacters(cm, curStart, curEnd);\n          cmSel = makeCmSelection(cm, {\n            anchor: newPositions.start,\n            head: newPositions.end\n          }, mode);\n\n          if (linewise) {\n            var ranges = cmSel.ranges;\n\n            if (mode == 'block') {\n              for (var i = 0; i < ranges.length; i++) {\n                ranges[i].head.ch = lineLength(cm, ranges[i].head.line);\n              }\n            } else if (mode == 'line') {\n              ranges[0].head = new Pos(ranges[0].head.line + 1, 0);\n            }\n          }\n        } else {\n          curStart = copyCursor(newAnchor || oldAnchor);\n          curEnd = copyCursor(newHead || oldHead);\n\n          if (cursorIsBefore(curEnd, curStart)) {\n            var tmp = curStart;\n            curStart = curEnd;\n            curEnd = tmp;\n          }\n\n          linewise = motionArgs.linewise || operatorArgs.linewise;\n\n          if (linewise) {\n            expandSelectionToLine(cm, curStart, curEnd);\n          } else if (motionArgs.forward) {\n            clipToLine(cm, curStart, curEnd);\n          }\n\n          mode = 'char';\n          var exclusive = !motionArgs.inclusive || linewise;\n          var newPositions = updateSelectionForSurrogateCharacters(cm, curStart, curEnd);\n          cmSel = makeCmSelection(cm, {\n            anchor: newPositions.start,\n            head: newPositions.end\n          }, mode, exclusive);\n        }\n\n        cm.setSelections(cmSel.ranges, cmSel.primary);\n        vim.lastMotion = null;\n        operatorArgs.repeat = repeat; // For indent in visual mode.\n\n        operatorArgs.registerName = registerName;\n        operatorArgs.linewise = linewise;\n        var operatorMoveTo = operators[operator](cm, operatorArgs, cmSel.ranges, oldAnchor, newHead);\n\n        if (vim.visualMode) {\n          exitVisualMode(cm, operatorMoveTo != null);\n        }\n\n        if (operatorMoveTo) {\n          cm.setCursor(operatorMoveTo);\n        }\n      }\n    },\n    recordLastEdit: function (vim, inputState, actionCommand) {\n      var macroModeState = vimGlobalState.macroModeState;\n\n      if (macroModeState.isPlaying) {\n        return;\n      }\n\n      vim.lastEditInputState = inputState;\n      vim.lastEditActionCommand = actionCommand;\n      macroModeState.lastInsertModeChanges.changes = [];\n      macroModeState.lastInsertModeChanges.expectCursorActivityForChange = false;\n      macroModeState.lastInsertModeChanges.visualBlock = vim.visualBlock ? vim.sel.head.line - vim.sel.anchor.line : 0;\n    }\n  };\n  var motions = {\n    moveToTopLine: function (cm, _head, motionArgs) {\n      var line = getUserVisibleLines(cm).top + motionArgs.repeat - 1;\n      return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n    },\n    moveToMiddleLine: function (cm) {\n      var range = getUserVisibleLines(cm);\n      var line = Math.floor((range.top + range.bottom) * 0.5);\n      return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n    },\n    moveToBottomLine: function (cm, _head, motionArgs) {\n      var line = getUserVisibleLines(cm).bottom - motionArgs.repeat + 1;\n      return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n    },\n    expandToLine: function (_cm, head, motionArgs) {\n      var cur = head;\n      return new Pos(cur.line + motionArgs.repeat - 1, Infinity);\n    },\n    findNext: function (cm, _head, motionArgs) {\n      var state = getSearchState(cm);\n      var query = state.getQuery();\n\n      if (!query) {\n        return;\n      }\n\n      var prev = !motionArgs.forward;\n      prev = state.isReversed() ? !prev : prev;\n      highlightSearchMatches(cm, query);\n      return findNext(cm, prev\n      /** prev */\n      , query, motionArgs.repeat);\n    },\n    findAndSelectNextInclusive: function (cm, _head, motionArgs, vim, prevInputState) {\n      var state = getSearchState(cm);\n      var query = state.getQuery();\n\n      if (!query) {\n        return;\n      }\n\n      var prev = !motionArgs.forward;\n      prev = state.isReversed() ? !prev : prev;\n      var next = findNextFromAndToInclusive(cm, prev, query, motionArgs.repeat, vim);\n\n      if (!next) {\n        return;\n      }\n\n      if (prevInputState.operator) {\n        return next;\n      }\n\n      var from = next[0];\n      var to = new Pos(next[1].line, next[1].ch - 1);\n\n      if (vim.visualMode) {\n        if (vim.visualLine || vim.visualBlock) {\n          vim.visualLine = false;\n          vim.visualBlock = false;\n          CodeMirror.signal(cm, \"vim-mode-change\", {\n            mode: \"visual\",\n            subMode: \"\"\n          });\n        }\n\n        var anchor = vim.sel.anchor;\n\n        if (anchor) {\n          if (state.isReversed()) {\n            if (motionArgs.forward) {\n              return [anchor, from];\n            }\n\n            return [anchor, to];\n          } else {\n            if (motionArgs.forward) {\n              return [anchor, to];\n            }\n\n            return [anchor, from];\n          }\n        }\n      } else {\n        vim.visualMode = true;\n        vim.visualLine = false;\n        vim.visualBlock = false;\n        CodeMirror.signal(cm, \"vim-mode-change\", {\n          mode: \"visual\",\n          subMode: \"\"\n        });\n      }\n\n      return prev ? [to, from] : [from, to];\n    },\n    goToMark: function (cm, _head, motionArgs, vim) {\n      var pos = getMarkPos(cm, vim, motionArgs.selectedCharacter);\n\n      if (pos) {\n        return motionArgs.linewise ? {\n          line: pos.line,\n          ch: findFirstNonWhiteSpaceCharacter(cm.getLine(pos.line))\n        } : pos;\n      }\n\n      return null;\n    },\n    moveToOtherHighlightedEnd: function (cm, _head, motionArgs, vim) {\n      if (vim.visualBlock && motionArgs.sameLine) {\n        var sel = vim.sel;\n        return [clipCursorToContent(cm, new Pos(sel.anchor.line, sel.head.ch)), clipCursorToContent(cm, new Pos(sel.head.line, sel.anchor.ch))];\n      } else {\n        return [vim.sel.head, vim.sel.anchor];\n      }\n    },\n    jumpToMark: function (cm, head, motionArgs, vim) {\n      var best = head;\n\n      for (var i = 0; i < motionArgs.repeat; i++) {\n        var cursor = best;\n\n        for (var key in vim.marks) {\n          if (!isLowerCase(key)) {\n            continue;\n          }\n\n          var mark = vim.marks[key].find();\n          var isWrongDirection = motionArgs.forward ? cursorIsBefore(mark, cursor) : cursorIsBefore(cursor, mark);\n\n          if (isWrongDirection) {\n            continue;\n          }\n\n          if (motionArgs.linewise && mark.line == cursor.line) {\n            continue;\n          }\n\n          var equal = cursorEqual(cursor, best);\n          var between = motionArgs.forward ? cursorIsBetween(cursor, mark, best) : cursorIsBetween(best, mark, cursor);\n\n          if (equal || between) {\n            best = mark;\n          }\n        }\n      }\n\n      if (motionArgs.linewise) {\n        best = new Pos(best.line, findFirstNonWhiteSpaceCharacter(cm.getLine(best.line)));\n      }\n\n      return best;\n    },\n    moveByCharacters: function (_cm, head, motionArgs) {\n      var cur = head;\n      var repeat = motionArgs.repeat;\n      var ch = motionArgs.forward ? cur.ch + repeat : cur.ch - repeat;\n      return new Pos(cur.line, ch);\n    },\n    moveByLines: function (cm, head, motionArgs, vim) {\n      var cur = head;\n      var endCh = cur.ch;\n\n      switch (vim.lastMotion) {\n        case this.moveByLines:\n        case this.moveByDisplayLines:\n        case this.moveByScroll:\n        case this.moveToColumn:\n        case this.moveToEol:\n          endCh = vim.lastHPos;\n          break;\n\n        default:\n          vim.lastHPos = endCh;\n      }\n\n      var repeat = motionArgs.repeat + (motionArgs.repeatOffset || 0);\n      var line = motionArgs.forward ? cur.line + repeat : cur.line - repeat;\n      var first = cm.firstLine();\n      var last = cm.lastLine();\n\n      if (line < first && cur.line == first) {\n        return this.moveToStartOfLine(cm, head, motionArgs, vim);\n      } else if (line > last && cur.line == last) {\n        return moveToEol(cm, head, motionArgs, vim, true);\n      }\n\n      var fold = cm.ace.session.getFoldLine(line);\n\n      if (fold) {\n        if (motionArgs.forward) {\n          if (line > fold.start.row) line = fold.end.row + 1;\n        } else {\n          line = fold.start.row;\n        }\n      }\n\n      if (motionArgs.toFirstChar) {\n        endCh = findFirstNonWhiteSpaceCharacter(cm.getLine(line));\n        vim.lastHPos = endCh;\n      }\n\n      vim.lastHSPos = cm.charCoords(new Pos(line, endCh), 'div').left;\n      return new Pos(line, endCh);\n    },\n    moveByDisplayLines: function (cm, head, motionArgs, vim) {\n      var cur = head;\n\n      switch (vim.lastMotion) {\n        case this.moveByDisplayLines:\n        case this.moveByScroll:\n        case this.moveByLines:\n        case this.moveToColumn:\n        case this.moveToEol:\n          break;\n\n        default:\n          vim.lastHSPos = cm.charCoords(cur, 'div').left;\n      }\n\n      var repeat = motionArgs.repeat;\n      var res = cm.findPosV(cur, motionArgs.forward ? repeat : -repeat, 'line', vim.lastHSPos);\n\n      if (res.hitSide) {\n        if (motionArgs.forward) {\n          var lastCharCoords = cm.charCoords(res, 'div');\n          var goalCoords = {\n            top: lastCharCoords.top + 8,\n            left: vim.lastHSPos\n          };\n          var res = cm.coordsChar(goalCoords, 'div');\n        } else {\n          var resCoords = cm.charCoords(new Pos(cm.firstLine(), 0), 'div');\n          resCoords.left = vim.lastHSPos;\n          res = cm.coordsChar(resCoords, 'div');\n        }\n      }\n\n      vim.lastHPos = res.ch;\n      return res;\n    },\n    moveByPage: function (cm, head, motionArgs) {\n      var curStart = head;\n      var repeat = motionArgs.repeat;\n      return cm.findPosV(curStart, motionArgs.forward ? repeat : -repeat, 'page');\n    },\n    moveByParagraph: function (cm, head, motionArgs) {\n      var dir = motionArgs.forward ? 1 : -1;\n      return findParagraph(cm, head, motionArgs.repeat, dir);\n    },\n    moveBySentence: function (cm, head, motionArgs) {\n      var dir = motionArgs.forward ? 1 : -1;\n      return findSentence(cm, head, motionArgs.repeat, dir);\n    },\n    moveByScroll: function (cm, head, motionArgs, vim) {\n      var scrollbox = cm.getScrollInfo();\n      var curEnd = null;\n      var repeat = motionArgs.repeat;\n\n      if (!repeat) {\n        repeat = scrollbox.clientHeight / (2 * cm.defaultTextHeight());\n      }\n\n      var orig = cm.charCoords(head, 'local');\n      motionArgs.repeat = repeat;\n      curEnd = motions.moveByDisplayLines(cm, head, motionArgs, vim);\n\n      if (!curEnd) {\n        return null;\n      }\n\n      var dest = cm.charCoords(curEnd, 'local');\n      cm.scrollTo(null, scrollbox.top + dest.top - orig.top);\n      return curEnd;\n    },\n    moveByWords: function (cm, head, motionArgs) {\n      return moveToWord(cm, head, motionArgs.repeat, !!motionArgs.forward, !!motionArgs.wordEnd, !!motionArgs.bigWord);\n    },\n    moveTillCharacter: function (cm, _head, motionArgs) {\n      var repeat = motionArgs.repeat;\n      var curEnd = moveToCharacter(cm, repeat, motionArgs.forward, motionArgs.selectedCharacter);\n      var increment = motionArgs.forward ? -1 : 1;\n      recordLastCharacterSearch(increment, motionArgs);\n      if (!curEnd) return null;\n      curEnd.ch += increment;\n      return curEnd;\n    },\n    moveToCharacter: function (cm, head, motionArgs) {\n      var repeat = motionArgs.repeat;\n      recordLastCharacterSearch(0, motionArgs);\n      return moveToCharacter(cm, repeat, motionArgs.forward, motionArgs.selectedCharacter) || head;\n    },\n    moveToSymbol: function (cm, head, motionArgs) {\n      var repeat = motionArgs.repeat;\n      return findSymbol(cm, repeat, motionArgs.forward, motionArgs.selectedCharacter) || head;\n    },\n    moveToColumn: function (cm, head, motionArgs, vim) {\n      var repeat = motionArgs.repeat;\n      vim.lastHPos = repeat - 1;\n      vim.lastHSPos = cm.charCoords(head, 'div').left;\n      return moveToColumn(cm, repeat);\n    },\n    moveToEol: function (cm, head, motionArgs, vim) {\n      return moveToEol(cm, head, motionArgs, vim, false);\n    },\n    moveToFirstNonWhiteSpaceCharacter: function (cm, head) {\n      var cursor = head;\n      return new Pos(cursor.line, findFirstNonWhiteSpaceCharacter(cm.getLine(cursor.line)));\n    },\n    moveToMatchedSymbol: function (cm, head) {\n      var cursor = head;\n      var line = cursor.line;\n      var ch = cursor.ch;\n      var lineText = cm.getLine(line);\n      var symbol;\n\n      for (; ch < lineText.length; ch++) {\n        symbol = lineText.charAt(ch);\n\n        if (symbol && isMatchableSymbol(symbol)) {\n          var style = cm.getTokenTypeAt(new Pos(line, ch + 1));\n\n          if (style !== \"string\" && style !== \"comment\") {\n            break;\n          }\n        }\n      }\n\n      if (ch < lineText.length) {\n        var re = /[<>]/.test(lineText[ch]) ? /[(){}[\\]<>]/ : /[(){}[\\]]/; //ace_patch?\n\n        var matched = cm.findMatchingBracket(new Pos(line, ch + 1), {\n          bracketRegex: re\n        });\n        return matched.to;\n      } else {\n        return cursor;\n      }\n    },\n    moveToStartOfLine: function (_cm, head) {\n      return new Pos(head.line, 0);\n    },\n    moveToLineOrEdgeOfDocument: function (cm, _head, motionArgs) {\n      var lineNum = motionArgs.forward ? cm.lastLine() : cm.firstLine();\n\n      if (motionArgs.repeatIsExplicit) {\n        lineNum = motionArgs.repeat - cm.getOption('firstLineNumber');\n      }\n\n      return new Pos(lineNum, findFirstNonWhiteSpaceCharacter(cm.getLine(lineNum)));\n    },\n    moveToStartOfDisplayLine: function (cm) {\n      cm.execCommand(\"goLineLeft\");\n      return cm.getCursor();\n    },\n    moveToEndOfDisplayLine: function (cm) {\n      cm.execCommand(\"goLineRight\");\n      var head = cm.getCursor();\n      if (head.sticky == \"before\") head.ch--;\n      return head;\n    },\n    textObjectManipulation: function (cm, head, motionArgs, vim) {\n      var mirroredPairs = {\n        '(': ')',\n        ')': '(',\n        '{': '}',\n        '}': '{',\n        '[': ']',\n        ']': '[',\n        '<': '>',\n        '>': '<'\n      };\n      var selfPaired = {\n        '\\'': true,\n        '\"': true,\n        '`': true\n      };\n      var character = motionArgs.selectedCharacter;\n\n      if (character == 'b') {\n        character = '(';\n      } else if (character == 'B') {\n        character = '{';\n      }\n\n      var inclusive = !motionArgs.textObjectInner;\n      var tmp;\n\n      if (mirroredPairs[character]) {\n        tmp = selectCompanionObject(cm, head, character, inclusive);\n      } else if (selfPaired[character]) {\n        tmp = findBeginningAndEnd(cm, head, character, inclusive);\n      } else if (character === 'W') {\n        tmp = expandWordUnderCursor(cm, inclusive, true\n        /** forward */\n        , true\n        /** bigWord */\n        );\n      } else if (character === 'w') {\n        tmp = expandWordUnderCursor(cm, inclusive, true\n        /** forward */\n        , false\n        /** bigWord */\n        );\n      } else if (character === 'p') {\n        tmp = findParagraph(cm, head, motionArgs.repeat, 0, inclusive);\n        motionArgs.linewise = true;\n\n        if (vim.visualMode) {\n          if (!vim.visualLine) {\n            vim.visualLine = true;\n          }\n        } else {\n          var operatorArgs = vim.inputState.operatorArgs;\n\n          if (operatorArgs) {\n            operatorArgs.linewise = true;\n          }\n\n          tmp.end.line--;\n        }\n      } else if (character === 't') {\n        tmp = expandTagUnderCursor(cm, head, inclusive);\n      } else if (character === 's') {\n        var content = cm.getLine(head.line);\n\n        if (head.ch > 0 && isEndOfSentenceSymbol(content[head.ch])) {\n          head.ch -= 1;\n        }\n\n        var end = getSentence(cm, head, motionArgs.repeat, 1, inclusive);\n        var start = getSentence(cm, head, motionArgs.repeat, -1, inclusive);\n\n        if (isWhiteSpaceString(cm.getLine(start.line)[start.ch]) && isWhiteSpaceString(cm.getLine(end.line)[end.ch - 1])) {\n          start = {\n            line: start.line,\n            ch: start.ch + 1\n          };\n        }\n\n        tmp = {\n          start: start,\n          end: end\n        };\n      } else {\n        return null;\n      }\n\n      if (!cm.state.vim.visualMode) {\n        return [tmp.start, tmp.end];\n      } else {\n        return expandSelection(cm, tmp.start, tmp.end);\n      }\n    },\n    repeatLastCharacterSearch: function (cm, head, motionArgs) {\n      var lastSearch = vimGlobalState.lastCharacterSearch;\n      var repeat = motionArgs.repeat;\n      var forward = motionArgs.forward === lastSearch.forward;\n      var increment = (lastSearch.increment ? 1 : 0) * (forward ? -1 : 1);\n      cm.moveH(-increment, 'char');\n      motionArgs.inclusive = forward ? true : false;\n      var curEnd = moveToCharacter(cm, repeat, forward, lastSearch.selectedCharacter);\n\n      if (!curEnd) {\n        cm.moveH(increment, 'char');\n        return head;\n      }\n\n      curEnd.ch += increment;\n      return curEnd;\n    }\n  };\n\n  function defineMotion(name, fn) {\n    motions[name] = fn;\n  }\n\n  function fillArray(val, times) {\n    var arr = [];\n\n    for (var i = 0; i < times; i++) {\n      arr.push(val);\n    }\n\n    return arr;\n  }\n\n  var operators = {\n    change: function (cm, args, ranges) {\n      var finalHead, text;\n      var vim = cm.state.vim;\n      var anchor = ranges[0].anchor,\n          head = ranges[0].head;\n\n      if (!vim.visualMode) {\n        text = cm.getRange(anchor, head);\n        var lastState = vim.lastEditInputState || {};\n\n        if (lastState.motion == \"moveByWords\" && !isWhiteSpaceString(text)) {\n          var match = /\\s+$/.exec(text);\n\n          if (match && lastState.motionArgs && lastState.motionArgs.forward) {\n            head = offsetCursor(head, 0, -match[0].length);\n            text = text.slice(0, -match[0].length);\n          }\n        }\n\n        var prevLineEnd = new Pos(anchor.line - 1, Number.MAX_VALUE);\n        var wasLastLine = cm.firstLine() == cm.lastLine();\n\n        if (head.line > cm.lastLine() && args.linewise && !wasLastLine) {\n          cm.replaceRange('', prevLineEnd, head);\n        } else {\n          cm.replaceRange('', anchor, head);\n        }\n\n        if (args.linewise) {\n          if (!wasLastLine) {\n            cm.setCursor(prevLineEnd);\n            CodeMirror.commands.newlineAndIndent(cm);\n          }\n\n          anchor.ch = Number.MAX_VALUE;\n        }\n\n        finalHead = anchor;\n      } else if (args.fullLine) {\n        head.ch = Number.MAX_VALUE;\n        head.line--;\n        cm.setSelection(anchor, head);\n        text = cm.getSelection();\n        cm.replaceSelection(\"\");\n        finalHead = anchor;\n      } else {\n        text = cm.getSelection();\n        var replacement = fillArray('', ranges.length);\n        cm.replaceSelections(replacement);\n        finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\n      }\n\n      vimGlobalState.registerController.pushText(args.registerName, 'change', text, args.linewise, ranges.length > 1);\n      actions.enterInsertMode(cm, {\n        head: finalHead\n      }, cm.state.vim);\n    },\n    'delete': function (cm, args, ranges) {\n      var finalHead, text;\n      var vim = cm.state.vim;\n\n      if (!vim.visualBlock) {\n        var anchor = ranges[0].anchor,\n            head = ranges[0].head;\n\n        if (args.linewise && head.line != cm.firstLine() && anchor.line == cm.lastLine() && anchor.line == head.line - 1) {\n          if (anchor.line == cm.firstLine()) {\n            anchor.ch = 0;\n          } else {\n            anchor = new Pos(anchor.line - 1, lineLength(cm, anchor.line - 1));\n          }\n        }\n\n        text = cm.getRange(anchor, head);\n        cm.replaceRange('', anchor, head);\n        finalHead = anchor;\n\n        if (args.linewise) {\n          finalHead = motions.moveToFirstNonWhiteSpaceCharacter(cm, anchor);\n        }\n      } else {\n        text = cm.getSelection();\n        var replacement = fillArray('', ranges.length);\n        cm.replaceSelections(replacement);\n        finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\n      }\n\n      vimGlobalState.registerController.pushText(args.registerName, 'delete', text, args.linewise, vim.visualBlock);\n      return clipCursorToContent(cm, finalHead);\n    },\n    indent: function (cm, args, ranges) {\n      var vim = cm.state.vim;\n\n      if (cm.indentMore) {\n        var repeat = vim.visualMode ? args.repeat : 1;\n\n        for (var j = 0; j < repeat; j++) {\n          if (args.indentRight) cm.indentMore();else cm.indentLess();\n        }\n      } else {\n        var startLine = ranges[0].anchor.line;\n        var endLine = vim.visualBlock ? ranges[ranges.length - 1].anchor.line : ranges[0].head.line;\n        var repeat = vim.visualMode ? args.repeat : 1;\n\n        if (args.linewise) {\n          endLine--;\n        }\n\n        for (var i = startLine; i <= endLine; i++) {\n          for (var j = 0; j < repeat; j++) {\n            cm.indentLine(i, args.indentRight);\n          }\n        }\n      }\n\n      return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n    },\n    indentAuto: function (cm, _args, ranges) {\n      if (ranges.length > 1) {\n        // ace_patch\n        cm.setSelection(ranges[0].anchor, ranges[ranges.length - 1].head);\n      }\n\n      cm.execCommand(\"indentAuto\");\n      return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n    },\n    changeCase: function (cm, args, ranges, oldAnchor, newHead) {\n      var selections = cm.getSelections();\n      var swapped = [];\n      var toLower = args.toLower;\n\n      for (var j = 0; j < selections.length; j++) {\n        var toSwap = selections[j];\n        var text = '';\n\n        if (toLower === true) {\n          text = toSwap.toLowerCase();\n        } else if (toLower === false) {\n          text = toSwap.toUpperCase();\n        } else {\n          for (var i = 0; i < toSwap.length; i++) {\n            var character = toSwap.charAt(i);\n            text += isUpperCase(character) ? character.toLowerCase() : character.toUpperCase();\n          }\n        }\n\n        swapped.push(text);\n      }\n\n      cm.replaceSelections(swapped);\n\n      if (args.shouldMoveCursor) {\n        return newHead;\n      } else if (!cm.state.vim.visualMode && args.linewise && ranges[0].anchor.line + 1 == ranges[0].head.line) {\n        return motions.moveToFirstNonWhiteSpaceCharacter(cm, oldAnchor);\n      } else if (args.linewise) {\n        return oldAnchor;\n      } else {\n        return cursorMin(ranges[0].anchor, ranges[0].head);\n      }\n    },\n    yank: function (cm, args, ranges, oldAnchor) {\n      var vim = cm.state.vim;\n      var text = cm.getSelection();\n      var endPos = vim.visualMode ? cursorMin(vim.sel.anchor, vim.sel.head, ranges[0].head, ranges[0].anchor) : oldAnchor;\n      vimGlobalState.registerController.pushText(args.registerName, 'yank', text, args.linewise, vim.visualBlock);\n      return endPos;\n    }\n  };\n\n  function defineOperator(name, fn) {\n    operators[name] = fn;\n  }\n\n  var actions = {\n    jumpListWalk: function (cm, actionArgs, vim) {\n      if (vim.visualMode) {\n        return;\n      }\n\n      var repeat = actionArgs.repeat;\n      var forward = actionArgs.forward;\n      var jumpList = vimGlobalState.jumpList;\n      var mark = jumpList.move(cm, forward ? repeat : -repeat);\n      var markPos = mark ? mark.find() : undefined;\n      markPos = markPos ? markPos : cm.getCursor();\n      cm.setCursor(markPos);\n      cm.ace.curOp.command.scrollIntoView = \"center-animate\"; // ace_patch\n    },\n    scroll: function (cm, actionArgs, vim) {\n      if (vim.visualMode) {\n        return;\n      }\n\n      var repeat = actionArgs.repeat || 1;\n      var lineHeight = cm.defaultTextHeight();\n      var top = cm.getScrollInfo().top;\n      var delta = lineHeight * repeat;\n      var newPos = actionArgs.forward ? top + delta : top - delta;\n      var cursor = copyCursor(cm.getCursor());\n      var cursorCoords = cm.charCoords(cursor, 'local');\n\n      if (actionArgs.forward) {\n        if (newPos > cursorCoords.top) {\n          cursor.line += (newPos - cursorCoords.top) / lineHeight;\n          cursor.line = Math.ceil(cursor.line);\n          cm.setCursor(cursor);\n          cursorCoords = cm.charCoords(cursor, 'local');\n          cm.scrollTo(null, cursorCoords.top);\n        } else {\n          cm.scrollTo(null, newPos);\n        }\n      } else {\n        var newBottom = newPos + cm.getScrollInfo().clientHeight;\n\n        if (newBottom < cursorCoords.bottom) {\n          cursor.line -= (cursorCoords.bottom - newBottom) / lineHeight;\n          cursor.line = Math.floor(cursor.line);\n          cm.setCursor(cursor);\n          cursorCoords = cm.charCoords(cursor, 'local');\n          cm.scrollTo(null, cursorCoords.bottom - cm.getScrollInfo().clientHeight);\n        } else {\n          cm.scrollTo(null, newPos);\n        }\n      }\n    },\n    scrollToCursor: function (cm, actionArgs) {\n      var lineNum = cm.getCursor().line;\n      var charCoords = cm.charCoords(new Pos(lineNum, 0), 'local');\n      var height = cm.getScrollInfo().clientHeight;\n      var y = charCoords.top;\n\n      switch (actionArgs.position) {\n        case 'center':\n          y = charCoords.bottom - height / 2;\n          break;\n\n        case 'bottom':\n          var lineLastCharPos = new Pos(lineNum, cm.getLine(lineNum).length - 1);\n          var lineLastCharCoords = cm.charCoords(lineLastCharPos, 'local');\n          var lineHeight = lineLastCharCoords.bottom - y;\n          y = y - height + lineHeight;\n          break;\n      }\n\n      cm.scrollTo(null, y);\n    },\n    replayMacro: function (cm, actionArgs, vim) {\n      var registerName = actionArgs.selectedCharacter;\n      var repeat = actionArgs.repeat;\n      var macroModeState = vimGlobalState.macroModeState;\n\n      if (registerName == '@') {\n        registerName = macroModeState.latestRegister;\n      } else {\n        macroModeState.latestRegister = registerName;\n      }\n\n      while (repeat--) {\n        executeMacroRegister(cm, vim, macroModeState, registerName);\n      }\n    },\n    enterMacroRecordMode: function (cm, actionArgs) {\n      var macroModeState = vimGlobalState.macroModeState;\n      var registerName = actionArgs.selectedCharacter;\n\n      if (vimGlobalState.registerController.isValidRegister(registerName)) {\n        macroModeState.enterMacroRecordMode(cm, registerName);\n      }\n    },\n    toggleOverwrite: function (cm) {\n      if (!cm.state.overwrite) {\n        cm.toggleOverwrite(true);\n        cm.setOption('keyMap', 'vim-replace');\n        CodeMirror.signal(cm, \"vim-mode-change\", {\n          mode: \"replace\"\n        });\n      } else {\n        cm.toggleOverwrite(false);\n        cm.setOption('keyMap', 'vim-insert');\n        CodeMirror.signal(cm, \"vim-mode-change\", {\n          mode: \"insert\"\n        });\n      }\n    },\n    enterInsertMode: function (cm, actionArgs, vim) {\n      if (cm.getOption('readOnly')) {\n        return;\n      }\n\n      vim.insertMode = true;\n      vim.insertModeRepeat = actionArgs && actionArgs.repeat || 1;\n      var insertAt = actionArgs ? actionArgs.insertAt : null;\n      var sel = vim.sel;\n      var head = actionArgs.head || cm.getCursor('head');\n      var height = cm.listSelections().length;\n\n      if (insertAt == 'eol') {\n        head = new Pos(head.line, lineLength(cm, head.line));\n      } else if (insertAt == 'bol') {\n        head = new Pos(head.line, 0);\n      } else if (insertAt == 'charAfter') {\n        var newPosition = updateSelectionForSurrogateCharacters(cm, head, offsetCursor(head, 0, 1));\n        head = newPosition.end;\n      } else if (insertAt == 'firstNonBlank') {\n        var newPosition = updateSelectionForSurrogateCharacters(cm, head, motions.moveToFirstNonWhiteSpaceCharacter(cm, head));\n        head = newPosition.end;\n      } else if (insertAt == 'startOfSelectedArea') {\n        if (!vim.visualMode) return;\n\n        if (!vim.visualBlock) {\n          if (sel.head.line < sel.anchor.line) {\n            head = sel.head;\n          } else {\n            head = new Pos(sel.anchor.line, 0);\n          }\n        } else {\n          head = new Pos(Math.min(sel.head.line, sel.anchor.line), Math.min(sel.head.ch, sel.anchor.ch));\n          height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n        }\n      } else if (insertAt == 'endOfSelectedArea') {\n        if (!vim.visualMode) return;\n\n        if (!vim.visualBlock) {\n          if (sel.head.line >= sel.anchor.line) {\n            head = offsetCursor(sel.head, 0, 1);\n          } else {\n            head = new Pos(sel.anchor.line, 0);\n          }\n        } else {\n          head = new Pos(Math.min(sel.head.line, sel.anchor.line), Math.max(sel.head.ch, sel.anchor.ch) + 1);\n          height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n        }\n      } else if (insertAt == 'inplace') {\n        if (vim.visualMode) {\n          return;\n        }\n      } else if (insertAt == 'lastEdit') {\n        head = getLastEditPos(cm) || head;\n      }\n\n      cm.setOption('disableInput', false);\n\n      if (actionArgs && actionArgs.replace) {\n        cm.toggleOverwrite(true);\n        cm.setOption('keyMap', 'vim-replace');\n        CodeMirror.signal(cm, \"vim-mode-change\", {\n          mode: \"replace\"\n        });\n      } else {\n        cm.toggleOverwrite(false);\n        cm.setOption('keyMap', 'vim-insert');\n        CodeMirror.signal(cm, \"vim-mode-change\", {\n          mode: \"insert\"\n        });\n      }\n\n      if (!vimGlobalState.macroModeState.isPlaying) {\n        cm.on('change', onChange);\n        CodeMirror.on(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n      }\n\n      if (vim.visualMode) {\n        exitVisualMode(cm);\n      }\n\n      selectForInsert(cm, head, height);\n    },\n    toggleVisualMode: function (cm, actionArgs, vim) {\n      var repeat = actionArgs.repeat;\n      var anchor = cm.getCursor();\n      var head;\n\n      if (!vim.visualMode) {\n        vim.visualMode = true;\n        vim.visualLine = !!actionArgs.linewise;\n        vim.visualBlock = !!actionArgs.blockwise;\n        head = clipCursorToContent(cm, new Pos(anchor.line, anchor.ch + repeat - 1));\n        var newPosition = updateSelectionForSurrogateCharacters(cm, anchor, head);\n        vim.sel = {\n          anchor: newPosition.start,\n          head: newPosition.end\n        };\n        CodeMirror.signal(cm, \"vim-mode-change\", {\n          mode: \"visual\",\n          subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"\n        });\n        updateCmSelection(cm);\n        updateMark(cm, vim, '<', cursorMin(anchor, head));\n        updateMark(cm, vim, '>', cursorMax(anchor, head));\n      } else if (vim.visualLine ^ actionArgs.linewise || vim.visualBlock ^ actionArgs.blockwise) {\n        vim.visualLine = !!actionArgs.linewise;\n        vim.visualBlock = !!actionArgs.blockwise;\n        CodeMirror.signal(cm, \"vim-mode-change\", {\n          mode: \"visual\",\n          subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"\n        });\n        updateCmSelection(cm);\n      } else {\n        exitVisualMode(cm);\n      }\n    },\n    reselectLastSelection: function (cm, _actionArgs, vim) {\n      var lastSelection = vim.lastSelection;\n\n      if (vim.visualMode) {\n        updateLastSelection(cm, vim);\n      }\n\n      if (lastSelection) {\n        var anchor = lastSelection.anchorMark.find();\n        var head = lastSelection.headMark.find();\n\n        if (!anchor || !head) {\n          return;\n        }\n\n        vim.sel = {\n          anchor: anchor,\n          head: head\n        };\n        vim.visualMode = true;\n        vim.visualLine = lastSelection.visualLine;\n        vim.visualBlock = lastSelection.visualBlock;\n        updateCmSelection(cm);\n        updateMark(cm, vim, '<', cursorMin(anchor, head));\n        updateMark(cm, vim, '>', cursorMax(anchor, head));\n        CodeMirror.signal(cm, 'vim-mode-change', {\n          mode: 'visual',\n          subMode: vim.visualLine ? 'linewise' : vim.visualBlock ? 'blockwise' : ''\n        });\n      }\n    },\n    joinLines: function (cm, actionArgs, vim) {\n      var curStart, curEnd;\n\n      if (vim.visualMode) {\n        curStart = cm.getCursor('anchor');\n        curEnd = cm.getCursor('head');\n\n        if (cursorIsBefore(curEnd, curStart)) {\n          var tmp = curEnd;\n          curEnd = curStart;\n          curStart = tmp;\n        }\n\n        curEnd.ch = lineLength(cm, curEnd.line) - 1;\n      } else {\n        var repeat = Math.max(actionArgs.repeat, 2);\n        curStart = cm.getCursor();\n        curEnd = clipCursorToContent(cm, new Pos(curStart.line + repeat - 1, Infinity));\n      }\n\n      var finalCh = 0;\n\n      for (var i = curStart.line; i < curEnd.line; i++) {\n        finalCh = lineLength(cm, curStart.line);\n        var text = '';\n        var nextStartCh = 0;\n\n        if (!actionArgs.keepSpaces) {\n          var nextLine = cm.getLine(curStart.line + 1);\n          nextStartCh = nextLine.search(/\\S/);\n\n          if (nextStartCh == -1) {\n            nextStartCh = nextLine.length;\n          } else {\n            text = \" \";\n          }\n        }\n\n        cm.replaceRange(text, new Pos(curStart.line, finalCh), new Pos(curStart.line + 1, nextStartCh));\n      }\n\n      var curFinalPos = clipCursorToContent(cm, new Pos(curStart.line, finalCh));\n\n      if (vim.visualMode) {\n        exitVisualMode(cm, false);\n      }\n\n      cm.setCursor(curFinalPos);\n    },\n    newLineAndEnterInsertMode: function (cm, actionArgs, vim) {\n      vim.insertMode = true;\n      var insertAt = copyCursor(cm.getCursor());\n\n      if (insertAt.line === cm.firstLine() && !actionArgs.after) {\n        cm.replaceRange('\\n', new Pos(cm.firstLine(), 0));\n        cm.setCursor(cm.firstLine(), 0);\n      } else {\n        insertAt.line = actionArgs.after ? insertAt.line : insertAt.line - 1;\n        insertAt.ch = lineLength(cm, insertAt.line);\n        cm.setCursor(insertAt);\n        var newlineFn = CodeMirror.commands.newlineAndIndentContinueComment || CodeMirror.commands.newlineAndIndent;\n        newlineFn(cm);\n      }\n\n      this.enterInsertMode(cm, {\n        repeat: actionArgs.repeat\n      }, vim);\n    },\n    paste: function (cm, actionArgs, vim) {\n      var _this = this;\n\n      var register = vimGlobalState.registerController.getRegister(actionArgs.registerName);\n\n      var fallback = function () {\n        var text = register.toString();\n\n        _this.continuePaste(cm, actionArgs, vim, text, register);\n      };\n\n      if (actionArgs.registerName === '+' && typeof navigator !== 'undefined' && typeof navigator.clipboard !== 'undefined' && typeof navigator.clipboard.readText === 'function') {\n        navigator.clipboard.readText().then(function (value) {\n          _this.continuePaste(cm, actionArgs, vim, value, register);\n        }, function () {\n          fallback();\n        });\n      } else {\n        fallback();\n      }\n    },\n    continuePaste: function (cm, actionArgs, vim, text, register) {\n      var cur = copyCursor(cm.getCursor());\n\n      if (!text) {\n        return;\n      }\n\n      if (actionArgs.matchIndent) {\n        var tabSize = cm.getOption(\"tabSize\");\n\n        var whitespaceLength = function (str) {\n          var tabs = str.split(\"\\t\").length - 1;\n          var spaces = str.split(\" \").length - 1;\n          return tabs * tabSize + spaces * 1;\n        };\n\n        var currentLine = cm.getLine(cm.getCursor().line);\n        var indent = whitespaceLength(currentLine.match(/^\\s*/)[0]);\n        var chompedText = text.replace(/\\n$/, '');\n        var wasChomped = text !== chompedText;\n        var firstIndent = whitespaceLength(text.match(/^\\s*/)[0]);\n        var text = chompedText.replace(/^\\s*/gm, function (wspace) {\n          var newIndent = indent + (whitespaceLength(wspace) - firstIndent);\n\n          if (newIndent < 0) {\n            return \"\";\n          } else if (cm.getOption(\"indentWithTabs\")) {\n            var quotient = Math.floor(newIndent / tabSize);\n            return Array(quotient + 1).join('\\t');\n          } else {\n            return Array(newIndent + 1).join(' ');\n          }\n        });\n        text += wasChomped ? \"\\n\" : \"\";\n      }\n\n      if (actionArgs.repeat > 1) {\n        var text = Array(actionArgs.repeat + 1).join(text);\n      }\n\n      var linewise = register.linewise;\n      var blockwise = register.blockwise;\n\n      if (blockwise) {\n        text = text.split('\\n');\n\n        if (linewise) {\n          text.pop();\n        }\n\n        for (var i = 0; i < text.length; i++) {\n          text[i] = text[i] == '' ? ' ' : text[i];\n        }\n\n        cur.ch += actionArgs.after ? 1 : 0;\n        cur.ch = Math.min(lineLength(cm, cur.line), cur.ch);\n      } else if (linewise) {\n        if (vim.visualMode) {\n          text = vim.visualLine ? text.slice(0, -1) : '\\n' + text.slice(0, text.length - 1) + '\\n';\n        } else if (actionArgs.after) {\n          text = '\\n' + text.slice(0, text.length - 1);\n          cur.ch = lineLength(cm, cur.line);\n        } else {\n          cur.ch = 0;\n        }\n      } else {\n        cur.ch += actionArgs.after ? 1 : 0;\n      }\n\n      var curPosFinal;\n      var idx;\n\n      if (vim.visualMode) {\n        vim.lastPastedText = text;\n        var lastSelectionCurEnd;\n        var selectedArea = getSelectedAreaRange(cm, vim);\n        var selectionStart = selectedArea[0];\n        var selectionEnd = selectedArea[1];\n        var selectedText = cm.getSelection();\n        var selections = cm.listSelections();\n        var emptyStrings = new Array(selections.length).join('1').split('1');\n\n        if (vim.lastSelection) {\n          lastSelectionCurEnd = vim.lastSelection.headMark.find();\n        }\n\n        vimGlobalState.registerController.unnamedRegister.setText(selectedText);\n\n        if (blockwise) {\n          cm.replaceSelections(emptyStrings);\n          selectionEnd = new Pos(selectionStart.line + text.length - 1, selectionStart.ch);\n          cm.setCursor(selectionStart);\n          selectBlock(cm, selectionEnd);\n          cm.replaceSelections(text);\n          curPosFinal = selectionStart;\n        } else if (vim.visualBlock) {\n          cm.replaceSelections(emptyStrings);\n          cm.setCursor(selectionStart);\n          cm.replaceRange(text, selectionStart, selectionStart);\n          curPosFinal = selectionStart;\n        } else {\n          cm.replaceRange(text, selectionStart, selectionEnd);\n          curPosFinal = cm.posFromIndex(cm.indexFromPos(selectionStart) + text.length - 1);\n        }\n\n        if (lastSelectionCurEnd) {\n          vim.lastSelection.headMark = cm.setBookmark(lastSelectionCurEnd);\n        }\n\n        if (linewise) {\n          curPosFinal.ch = 0;\n        }\n      } else {\n        if (blockwise) {\n          cm.setCursor(cur);\n\n          for (var i = 0; i < text.length; i++) {\n            var line = cur.line + i;\n\n            if (line > cm.lastLine()) {\n              cm.replaceRange('\\n', new Pos(line, 0));\n            }\n\n            var lastCh = lineLength(cm, line);\n\n            if (lastCh < cur.ch) {\n              extendLineToColumn(cm, line, cur.ch);\n            }\n          }\n\n          cm.setCursor(cur);\n          selectBlock(cm, new Pos(cur.line + text.length - 1, cur.ch));\n          cm.replaceSelections(text);\n          curPosFinal = cur;\n        } else {\n          cm.replaceRange(text, cur);\n\n          if (linewise && actionArgs.after) {\n            curPosFinal = new Pos(cur.line + 1, findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line + 1)));\n          } else if (linewise && !actionArgs.after) {\n            curPosFinal = new Pos(cur.line, findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line)));\n          } else if (!linewise && actionArgs.after) {\n            idx = cm.indexFromPos(cur);\n            curPosFinal = cm.posFromIndex(idx + text.length - 1);\n          } else {\n            idx = cm.indexFromPos(cur);\n            curPosFinal = cm.posFromIndex(idx + text.length);\n          }\n        }\n      }\n\n      if (vim.visualMode) {\n        exitVisualMode(cm, false);\n      }\n\n      cm.setCursor(curPosFinal);\n    },\n    undo: function (cm, actionArgs) {\n      cm.operation(function () {\n        repeatFn(cm, CodeMirror.commands.undo, actionArgs.repeat)();\n        cm.setCursor(clipCursorToContent(cm, cm.getCursor('start')));\n      });\n    },\n    redo: function (cm, actionArgs) {\n      repeatFn(cm, CodeMirror.commands.redo, actionArgs.repeat)();\n    },\n    setRegister: function (_cm, actionArgs, vim) {\n      vim.inputState.registerName = actionArgs.selectedCharacter;\n    },\n    setMark: function (cm, actionArgs, vim) {\n      var markName = actionArgs.selectedCharacter;\n      updateMark(cm, vim, markName, cm.getCursor());\n    },\n    replace: function (cm, actionArgs, vim) {\n      var replaceWith = actionArgs.selectedCharacter;\n      var curStart = cm.getCursor();\n      var replaceTo;\n      var curEnd;\n      var selections = cm.listSelections();\n\n      if (vim.visualMode) {\n        curStart = cm.getCursor('start');\n        curEnd = cm.getCursor('end');\n      } else {\n        var line = cm.getLine(curStart.line);\n        replaceTo = curStart.ch + actionArgs.repeat;\n\n        if (replaceTo > line.length) {\n          replaceTo = line.length;\n        }\n\n        curEnd = new Pos(curStart.line, replaceTo);\n      }\n\n      var newPositions = updateSelectionForSurrogateCharacters(cm, curStart, curEnd);\n      curStart = newPositions.start;\n      curEnd = newPositions.end;\n\n      if (replaceWith == '\\n') {\n        if (!vim.visualMode) cm.replaceRange('', curStart, curEnd);\n        (CodeMirror.commands.newlineAndIndentContinueComment || CodeMirror.commands.newlineAndIndent)(cm);\n      } else {\n        var replaceWithStr = cm.getRange(curStart, curEnd);\n        replaceWithStr = replaceWithStr.replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, replaceWith);\n        replaceWithStr = replaceWithStr.replace(/[^\\n]/g, replaceWith);\n\n        if (vim.visualBlock) {\n          var spaces = new Array(cm.getOption(\"tabSize\") + 1).join(' ');\n          replaceWithStr = cm.getSelection();\n          replaceWithStr = replaceWithStr.replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, replaceWith);\n          replaceWithStr = replaceWithStr.replace(/\\t/g, spaces).replace(/[^\\n]/g, replaceWith).split('\\n');\n          cm.replaceSelections(replaceWithStr);\n        } else {\n          cm.replaceRange(replaceWithStr, curStart, curEnd);\n        }\n\n        if (vim.visualMode) {\n          curStart = cursorIsBefore(selections[0].anchor, selections[0].head) ? selections[0].anchor : selections[0].head;\n          cm.setCursor(curStart);\n          exitVisualMode(cm, false);\n        } else {\n          cm.setCursor(offsetCursor(curEnd, 0, -1));\n        }\n      }\n    },\n    incrementNumberToken: function (cm, actionArgs) {\n      var cur = cm.getCursor();\n      var lineStr = cm.getLine(cur.line);\n      var re = /(-?)(?:(0x)([\\da-f]+)|(0b|0|)(\\d+))/gi;\n      var match;\n      var start;\n      var end;\n      var numberStr;\n\n      while ((match = re.exec(lineStr)) !== null) {\n        start = match.index;\n        end = start + match[0].length;\n        if (cur.ch < end) break;\n      }\n\n      if (!actionArgs.backtrack && end <= cur.ch) return;\n\n      if (match) {\n        var baseStr = match[2] || match[4];\n        var digits = match[3] || match[5];\n        var increment = actionArgs.increase ? 1 : -1;\n        var base = {\n          '0b': 2,\n          '0': 8,\n          '': 10,\n          '0x': 16\n        }[baseStr.toLowerCase()];\n        var number = parseInt(match[1] + digits, base) + increment * actionArgs.repeat;\n        numberStr = number.toString(base);\n        var zeroPadding = baseStr ? new Array(digits.length - numberStr.length + 1 + match[1].length).join('0') : '';\n\n        if (numberStr.charAt(0) === '-') {\n          numberStr = '-' + baseStr + zeroPadding + numberStr.substr(1);\n        } else {\n          numberStr = baseStr + zeroPadding + numberStr;\n        }\n\n        var from = new Pos(cur.line, start);\n        var to = new Pos(cur.line, end);\n        cm.replaceRange(numberStr, from, to);\n      } else {\n        return;\n      }\n\n      cm.setCursor(new Pos(cur.line, start + numberStr.length - 1));\n    },\n    repeatLastEdit: function (cm, actionArgs, vim) {\n      var lastEditInputState = vim.lastEditInputState;\n\n      if (!lastEditInputState) {\n        return;\n      }\n\n      var repeat = actionArgs.repeat;\n\n      if (repeat && actionArgs.repeatIsExplicit) {\n        vim.lastEditInputState.repeatOverride = repeat;\n      } else {\n        repeat = vim.lastEditInputState.repeatOverride || repeat;\n      }\n\n      repeatLastEdit(cm, vim, repeat, false\n      /** repeatForInsert */\n      );\n    },\n    indent: function (cm, actionArgs) {\n      cm.indentLine(cm.getCursor().line, actionArgs.indentRight);\n    },\n    exitInsertMode: exitInsertMode\n  };\n\n  function defineAction(name, fn) {\n    actions[name] = fn;\n  }\n\n  function clipCursorToContent(cm, cur, oldCur) {\n    var vim = cm.state.vim;\n    var includeLineBreak = vim.insertMode || vim.visualMode;\n    var line = Math.min(Math.max(cm.firstLine(), cur.line), cm.lastLine());\n    var text = cm.getLine(line);\n    var maxCh = text.length - 1 + !!includeLineBreak;\n    var ch = Math.min(Math.max(0, cur.ch), maxCh);\n    var charCode = text.charCodeAt(ch);\n\n    if (0xDC00 < charCode && charCode < 0xDFFF) {\n      var direction = 1;\n\n      if (oldCur && oldCur.line == line) {\n        if (oldCur.ch > ch) {\n          direction = -1;\n        }\n      }\n\n      ch += direction;\n      if (ch > maxCh) ch -= 2;\n    }\n\n    return new Pos(line, ch);\n  }\n\n  function copyArgs(args) {\n    var ret = {};\n\n    for (var prop in args) {\n      if (args.hasOwnProperty(prop)) {\n        ret[prop] = args[prop];\n      }\n    }\n\n    return ret;\n  }\n\n  function offsetCursor(cur, offsetLine, offsetCh) {\n    if (typeof offsetLine === 'object') {\n      offsetCh = offsetLine.ch;\n      offsetLine = offsetLine.line;\n    }\n\n    return new Pos(cur.line + offsetLine, cur.ch + offsetCh);\n  }\n\n  function commandMatches(keys, keyMap, context, inputState) {\n    var match,\n        partial = [],\n        full = [];\n\n    for (var i = 0; i < keyMap.length; i++) {\n      var command = keyMap[i];\n\n      if (context == 'insert' && command.context != 'insert' || command.context && command.context != context || inputState.operator && command.type == 'action' || !(match = commandMatch(keys, command.keys))) {\n        continue;\n      }\n\n      if (match == 'partial') {\n        partial.push(command);\n      }\n\n      if (match == 'full') {\n        full.push(command);\n      }\n    }\n\n    return {\n      partial: partial.length && partial,\n      full: full.length && full\n    };\n  }\n\n  function commandMatch(pressed, mapped) {\n    if (mapped.slice(-11) == '<character>') {\n      var prefixLen = mapped.length - 11;\n      var pressedPrefix = pressed.slice(0, prefixLen);\n      var mappedPrefix = mapped.slice(0, prefixLen);\n      return pressedPrefix == mappedPrefix && pressed.length > prefixLen ? 'full' : mappedPrefix.indexOf(pressedPrefix) == 0 ? 'partial' : false;\n    } else {\n      return pressed == mapped ? 'full' : mapped.indexOf(pressed) == 0 ? 'partial' : false;\n    }\n  }\n\n  function lastChar(keys) {\n    var match = /^.*(<[^>]+>)$/.exec(keys);\n    var selectedCharacter = match ? match[1] : keys.slice(-1);\n\n    if (selectedCharacter.length > 1) {\n      switch (selectedCharacter) {\n        case '<CR>':\n          selectedCharacter = '\\n';\n          break;\n\n        case '<Space>':\n          selectedCharacter = ' ';\n          break;\n\n        default:\n          selectedCharacter = '';\n          break;\n      }\n    }\n\n    return selectedCharacter;\n  }\n\n  function repeatFn(cm, fn, repeat) {\n    return function () {\n      for (var i = 0; i < repeat; i++) {\n        fn(cm);\n      }\n    };\n  }\n\n  function copyCursor(cur) {\n    return new Pos(cur.line, cur.ch);\n  }\n\n  function cursorEqual(cur1, cur2) {\n    return cur1.ch == cur2.ch && cur1.line == cur2.line;\n  }\n\n  function cursorIsBefore(cur1, cur2) {\n    if (cur1.line < cur2.line) {\n      return true;\n    }\n\n    if (cur1.line == cur2.line && cur1.ch < cur2.ch) {\n      return true;\n    }\n\n    return false;\n  }\n\n  function cursorMin(cur1, cur2) {\n    if (arguments.length > 2) {\n      cur2 = cursorMin.apply(undefined, Array.prototype.slice.call(arguments, 1));\n    }\n\n    return cursorIsBefore(cur1, cur2) ? cur1 : cur2;\n  }\n\n  function cursorMax(cur1, cur2) {\n    if (arguments.length > 2) {\n      cur2 = cursorMax.apply(undefined, Array.prototype.slice.call(arguments, 1));\n    }\n\n    return cursorIsBefore(cur1, cur2) ? cur2 : cur1;\n  }\n\n  function cursorIsBetween(cur1, cur2, cur3) {\n    var cur1before2 = cursorIsBefore(cur1, cur2);\n    var cur2before3 = cursorIsBefore(cur2, cur3);\n    return cur1before2 && cur2before3;\n  }\n\n  function lineLength(cm, lineNum) {\n    return cm.getLine(lineNum).length;\n  }\n\n  function trim(s) {\n    if (s.trim) {\n      return s.trim();\n    }\n\n    return s.replace(/^\\s+|\\s+$/g, '');\n  }\n\n  function escapeRegex(s) {\n    return s.replace(/([.?*+$\\[\\]\\/\\\\(){}|\\-])/g, '\\\\$1');\n  }\n\n  function extendLineToColumn(cm, lineNum, column) {\n    var endCh = lineLength(cm, lineNum);\n    var spaces = new Array(column - endCh + 1).join(' ');\n    cm.setCursor(new Pos(lineNum, endCh));\n    cm.replaceRange(spaces, cm.getCursor());\n  }\n\n  function selectBlock(cm, selectionEnd) {\n    var selections = [],\n        ranges = cm.listSelections();\n    var head = copyCursor(cm.clipPos(selectionEnd));\n    var isClipped = !cursorEqual(selectionEnd, head);\n    var curHead = cm.getCursor('head');\n    var primIndex = getIndex(ranges, curHead);\n    var wasClipped = cursorEqual(ranges[primIndex].head, ranges[primIndex].anchor);\n    var max = ranges.length - 1;\n    var index = max - primIndex > primIndex ? max : 0;\n    var base = ranges[index].anchor;\n    var firstLine = Math.min(base.line, head.line);\n    var lastLine = Math.max(base.line, head.line);\n    var baseCh = base.ch,\n        headCh = head.ch;\n    var dir = ranges[index].head.ch - baseCh;\n    var newDir = headCh - baseCh;\n\n    if (dir > 0 && newDir <= 0) {\n      baseCh++;\n\n      if (!isClipped) {\n        headCh--;\n      }\n    } else if (dir < 0 && newDir >= 0) {\n      baseCh--;\n\n      if (!wasClipped) {\n        headCh++;\n      }\n    } else if (dir < 0 && newDir == -1) {\n      baseCh--;\n      headCh++;\n    }\n\n    for (var line = firstLine; line <= lastLine; line++) {\n      var range = {\n        anchor: new Pos(line, baseCh),\n        head: new Pos(line, headCh)\n      };\n      selections.push(range);\n    }\n\n    cm.setSelections(selections);\n    selectionEnd.ch = headCh;\n    base.ch = baseCh;\n    return base;\n  }\n\n  function selectForInsert(cm, head, height) {\n    var sel = [];\n\n    for (var i = 0; i < height; i++) {\n      var lineHead = offsetCursor(head, i, 0);\n      sel.push({\n        anchor: lineHead,\n        head: lineHead\n      });\n    }\n\n    cm.setSelections(sel, 0);\n  }\n\n  function getIndex(ranges, cursor, end) {\n    for (var i = 0; i < ranges.length; i++) {\n      var atAnchor = end != 'head' && cursorEqual(ranges[i].anchor, cursor);\n      var atHead = end != 'anchor' && cursorEqual(ranges[i].head, cursor);\n\n      if (atAnchor || atHead) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n\n  function getSelectedAreaRange(cm, vim) {\n    var lastSelection = vim.lastSelection;\n\n    var getCurrentSelectedAreaRange = function () {\n      var selections = cm.listSelections();\n      var start = selections[0];\n      var end = selections[selections.length - 1];\n      var selectionStart = cursorIsBefore(start.anchor, start.head) ? start.anchor : start.head;\n      var selectionEnd = cursorIsBefore(end.anchor, end.head) ? end.head : end.anchor;\n      return [selectionStart, selectionEnd];\n    };\n\n    var getLastSelectedAreaRange = function () {\n      var selectionStart = cm.getCursor();\n      var selectionEnd = cm.getCursor();\n      var block = lastSelection.visualBlock;\n\n      if (block) {\n        var width = block.width;\n        var height = block.height;\n        selectionEnd = new Pos(selectionStart.line + height, selectionStart.ch + width);\n        var selections = [];\n\n        for (var i = selectionStart.line; i < selectionEnd.line; i++) {\n          var anchor = new Pos(i, selectionStart.ch);\n          var head = new Pos(i, selectionEnd.ch);\n          var range = {\n            anchor: anchor,\n            head: head\n          };\n          selections.push(range);\n        }\n\n        cm.setSelections(selections);\n      } else {\n        var start = lastSelection.anchorMark.find();\n        var end = lastSelection.headMark.find();\n        var line = end.line - start.line;\n        var ch = end.ch - start.ch;\n        selectionEnd = {\n          line: selectionEnd.line + line,\n          ch: line ? selectionEnd.ch : ch + selectionEnd.ch\n        };\n\n        if (lastSelection.visualLine) {\n          selectionStart = new Pos(selectionStart.line, 0);\n          selectionEnd = new Pos(selectionEnd.line, lineLength(cm, selectionEnd.line));\n        }\n\n        cm.setSelection(selectionStart, selectionEnd);\n      }\n\n      return [selectionStart, selectionEnd];\n    };\n\n    if (!vim.visualMode) {\n      return getLastSelectedAreaRange();\n    } else {\n      return getCurrentSelectedAreaRange();\n    }\n  }\n\n  function updateLastSelection(cm, vim) {\n    var anchor = vim.sel.anchor;\n    var head = vim.sel.head;\n\n    if (vim.lastPastedText) {\n      head = cm.posFromIndex(cm.indexFromPos(anchor) + vim.lastPastedText.length);\n      vim.lastPastedText = null;\n    }\n\n    vim.lastSelection = {\n      'anchorMark': cm.setBookmark(anchor),\n      'headMark': cm.setBookmark(head),\n      'anchor': copyCursor(anchor),\n      'head': copyCursor(head),\n      'visualMode': vim.visualMode,\n      'visualLine': vim.visualLine,\n      'visualBlock': vim.visualBlock\n    };\n  }\n\n  function expandSelection(cm, start, end) {\n    var sel = cm.state.vim.sel;\n    var head = sel.head;\n    var anchor = sel.anchor;\n    var tmp;\n\n    if (cursorIsBefore(end, start)) {\n      tmp = end;\n      end = start;\n      start = tmp;\n    }\n\n    if (cursorIsBefore(head, anchor)) {\n      head = cursorMin(start, head);\n      anchor = cursorMax(anchor, end);\n    } else {\n      anchor = cursorMin(start, anchor);\n      head = cursorMax(head, end);\n      head = offsetCursor(head, 0, -1);\n\n      if (head.ch == -1 && head.line != cm.firstLine()) {\n        head = new Pos(head.line - 1, lineLength(cm, head.line - 1));\n      }\n    }\n\n    return [anchor, head];\n  }\n\n  function updateCmSelection(cm, sel, mode) {\n    var vim = cm.state.vim;\n    sel = sel || vim.sel;\n    var mode = mode || vim.visualLine ? 'line' : vim.visualBlock ? 'block' : 'char';\n    var cmSel = makeCmSelection(cm, sel, mode);\n    cm.setSelections(cmSel.ranges, cmSel.primary);\n  }\n\n  function makeCmSelection(cm, sel, mode, exclusive) {\n    var head = copyCursor(sel.head);\n    var anchor = copyCursor(sel.anchor);\n\n    if (mode == 'char') {\n      var headOffset = !exclusive && !cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n      var anchorOffset = cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n      head = offsetCursor(sel.head, 0, headOffset);\n      anchor = offsetCursor(sel.anchor, 0, anchorOffset);\n      return {\n        ranges: [{\n          anchor: anchor,\n          head: head\n        }],\n        primary: 0\n      };\n    } else if (mode == 'line') {\n      if (!cursorIsBefore(sel.head, sel.anchor)) {\n        anchor.ch = 0;\n        var lastLine = cm.lastLine();\n\n        if (head.line > lastLine) {\n          head.line = lastLine;\n        }\n\n        head.ch = lineLength(cm, head.line);\n      } else {\n        head.ch = 0;\n        anchor.ch = lineLength(cm, anchor.line);\n      }\n\n      return {\n        ranges: [{\n          anchor: anchor,\n          head: head\n        }],\n        primary: 0\n      };\n    } else if (mode == 'block') {\n      var top = Math.min(anchor.line, head.line),\n          fromCh = anchor.ch,\n          bottom = Math.max(anchor.line, head.line),\n          toCh = head.ch;\n\n      if (fromCh < toCh) {\n        toCh += 1;\n      } else {\n        fromCh += 1;\n      }\n\n      ;\n      var height = bottom - top + 1;\n      var primary = head.line == top ? 0 : height - 1;\n      var ranges = [];\n\n      for (var i = 0; i < height; i++) {\n        ranges.push({\n          anchor: new Pos(top + i, fromCh),\n          head: new Pos(top + i, toCh)\n        });\n      }\n\n      return {\n        ranges: ranges,\n        primary: primary\n      };\n    }\n  }\n\n  function getHead(cm) {\n    var cur = cm.getCursor('head');\n\n    if (cm.getSelection().length == 1) {\n      cur = cursorMin(cur, cm.getCursor('anchor'));\n    }\n\n    return cur;\n  }\n\n  function exitVisualMode(cm, moveHead) {\n    var vim = cm.state.vim;\n\n    if (moveHead !== false) {\n      cm.setCursor(clipCursorToContent(cm, vim.sel.head));\n    }\n\n    updateLastSelection(cm, vim);\n    vim.visualMode = false;\n    vim.visualLine = false;\n    vim.visualBlock = false;\n    if (!vim.insertMode) CodeMirror.signal(cm, \"vim-mode-change\", {\n      mode: \"normal\"\n    });\n  }\n\n  function clipToLine(cm, curStart, curEnd) {\n    var selection = cm.getRange(curStart, curEnd);\n\n    if (/\\n\\s*$/.test(selection)) {\n      var lines = selection.split('\\n');\n      lines.pop();\n      var line;\n\n      for (var line = lines.pop(); lines.length > 0 && line && isWhiteSpaceString(line); line = lines.pop()) {\n        curEnd.line--;\n        curEnd.ch = 0;\n      }\n\n      if (line) {\n        curEnd.line--;\n        curEnd.ch = lineLength(cm, curEnd.line);\n      } else {\n        curEnd.ch = 0;\n      }\n    }\n  }\n\n  function expandSelectionToLine(_cm, curStart, curEnd) {\n    curStart.ch = 0;\n    curEnd.ch = 0;\n    curEnd.line++;\n  }\n\n  function findFirstNonWhiteSpaceCharacter(text) {\n    if (!text) {\n      return 0;\n    }\n\n    var firstNonWS = text.search(/\\S/);\n    return firstNonWS == -1 ? text.length : firstNonWS;\n  }\n\n  function expandWordUnderCursor(cm, inclusive, _forward, bigWord, noSymbol) {\n    var cur = getHead(cm);\n    var line = cm.getLine(cur.line);\n    var idx = cur.ch;\n    var test = noSymbol ? wordCharTest[0] : bigWordCharTest[0];\n\n    while (!test(line.charAt(idx))) {\n      idx++;\n\n      if (idx >= line.length) {\n        return null;\n      }\n    }\n\n    if (bigWord) {\n      test = bigWordCharTest[0];\n    } else {\n      test = wordCharTest[0];\n\n      if (!test(line.charAt(idx))) {\n        test = wordCharTest[1];\n      }\n    }\n\n    var end = idx,\n        start = idx;\n\n    while (test(line.charAt(end)) && end < line.length) {\n      end++;\n    }\n\n    while (test(line.charAt(start)) && start >= 0) {\n      start--;\n    }\n\n    start++;\n\n    if (inclusive) {\n      var wordEnd = end;\n\n      while (/\\s/.test(line.charAt(end)) && end < line.length) {\n        end++;\n      }\n\n      if (wordEnd == end) {\n        var wordStart = start;\n\n        while (/\\s/.test(line.charAt(start - 1)) && start > 0) {\n          start--;\n        }\n\n        if (!start) {\n          start = wordStart;\n        }\n      }\n    }\n\n    return {\n      start: new Pos(cur.line, start),\n      end: new Pos(cur.line, end)\n    };\n  }\n\n  function expandTagUnderCursor(cm, head, inclusive) {\n    var cur = head;\n\n    if (!CodeMirror.findMatchingTag || !CodeMirror.findEnclosingTag) {\n      return {\n        start: cur,\n        end: cur\n      };\n    }\n\n    var tags = CodeMirror.findMatchingTag(cm, head) || CodeMirror.findEnclosingTag(cm, head);\n\n    if (!tags || !tags.open || !tags.close) {\n      return {\n        start: cur,\n        end: cur\n      };\n    }\n\n    if (inclusive) {\n      return {\n        start: tags.open.from,\n        end: tags.close.to\n      };\n    }\n\n    return {\n      start: tags.open.to,\n      end: tags.close.from\n    };\n  }\n\n  function recordJumpPosition(cm, oldCur, newCur) {\n    if (!cursorEqual(oldCur, newCur)) {\n      vimGlobalState.jumpList.add(cm, oldCur, newCur);\n    }\n  }\n\n  function recordLastCharacterSearch(increment, args) {\n    vimGlobalState.lastCharacterSearch.increment = increment;\n    vimGlobalState.lastCharacterSearch.forward = args.forward;\n    vimGlobalState.lastCharacterSearch.selectedCharacter = args.selectedCharacter;\n  }\n\n  var symbolToMode = {\n    '(': 'bracket',\n    ')': 'bracket',\n    '{': 'bracket',\n    '}': 'bracket',\n    '[': 'section',\n    ']': 'section',\n    '*': 'comment',\n    '/': 'comment',\n    'm': 'method',\n    'M': 'method',\n    '#': 'preprocess'\n  };\n  var findSymbolModes = {\n    bracket: {\n      isComplete: function (state) {\n        if (state.nextCh === state.symb) {\n          state.depth++;\n          if (state.depth >= 1) return true;\n        } else if (state.nextCh === state.reverseSymb) {\n          state.depth--;\n        }\n\n        return false;\n      }\n    },\n    section: {\n      init: function (state) {\n        state.curMoveThrough = true;\n        state.symb = (state.forward ? ']' : '[') === state.symb ? '{' : '}';\n      },\n      isComplete: function (state) {\n        return state.index === 0 && state.nextCh === state.symb;\n      }\n    },\n    comment: {\n      isComplete: function (state) {\n        var found = state.lastCh === '*' && state.nextCh === '/';\n        state.lastCh = state.nextCh;\n        return found;\n      }\n    },\n    method: {\n      init: function (state) {\n        state.symb = state.symb === 'm' ? '{' : '}';\n        state.reverseSymb = state.symb === '{' ? '}' : '{';\n      },\n      isComplete: function (state) {\n        if (state.nextCh === state.symb) return true;\n        return false;\n      }\n    },\n    preprocess: {\n      init: function (state) {\n        state.index = 0;\n      },\n      isComplete: function (state) {\n        if (state.nextCh === '#') {\n          var token = state.lineText.match(/^#(\\w+)/)[1];\n\n          if (token === 'endif') {\n            if (state.forward && state.depth === 0) {\n              return true;\n            }\n\n            state.depth++;\n          } else if (token === 'if') {\n            if (!state.forward && state.depth === 0) {\n              return true;\n            }\n\n            state.depth--;\n          }\n\n          if (token === 'else' && state.depth === 0) return true;\n        }\n\n        return false;\n      }\n    }\n  };\n\n  function findSymbol(cm, repeat, forward, symb) {\n    var cur = copyCursor(cm.getCursor());\n    var increment = forward ? 1 : -1;\n    var endLine = forward ? cm.lineCount() : -1;\n    var curCh = cur.ch;\n    var line = cur.line;\n    var lineText = cm.getLine(line);\n    var state = {\n      lineText: lineText,\n      nextCh: lineText.charAt(curCh),\n      lastCh: null,\n      index: curCh,\n      symb: symb,\n      reverseSymb: (forward ? {\n        ')': '(',\n        '}': '{'\n      } : {\n        '(': ')',\n        '{': '}'\n      })[symb],\n      forward: forward,\n      depth: 0,\n      curMoveThrough: false\n    };\n    var mode = symbolToMode[symb];\n    if (!mode) return cur;\n    var init = findSymbolModes[mode].init;\n    var isComplete = findSymbolModes[mode].isComplete;\n\n    if (init) {\n      init(state);\n    }\n\n    while (line !== endLine && repeat) {\n      state.index += increment;\n      state.nextCh = state.lineText.charAt(state.index);\n\n      if (!state.nextCh) {\n        line += increment;\n        state.lineText = cm.getLine(line) || '';\n\n        if (increment > 0) {\n          state.index = 0;\n        } else {\n          var lineLen = state.lineText.length;\n          state.index = lineLen > 0 ? lineLen - 1 : 0;\n        }\n\n        state.nextCh = state.lineText.charAt(state.index);\n      }\n\n      if (isComplete(state)) {\n        cur.line = line;\n        cur.ch = state.index;\n        repeat--;\n      }\n    }\n\n    if (state.nextCh || state.curMoveThrough) {\n      return new Pos(line, state.index);\n    }\n\n    return cur;\n  }\n\n  function findWord(cm, cur, forward, bigWord, emptyLineIsWord) {\n    var lineNum = cur.line;\n    var pos = cur.ch;\n    var line = cm.getLine(lineNum);\n    var dir = forward ? 1 : -1;\n    var charTests = bigWord ? bigWordCharTest : wordCharTest;\n\n    if (emptyLineIsWord && line == '') {\n      lineNum += dir;\n      line = cm.getLine(lineNum);\n\n      if (!isLine(cm, lineNum)) {\n        return null;\n      }\n\n      pos = forward ? 0 : line.length;\n    }\n\n    while (true) {\n      if (emptyLineIsWord && line == '') {\n        return {\n          from: 0,\n          to: 0,\n          line: lineNum\n        };\n      }\n\n      var stop = dir > 0 ? line.length : -1;\n      var wordStart = stop,\n          wordEnd = stop;\n\n      while (pos != stop) {\n        var foundWord = false;\n\n        for (var i = 0; i < charTests.length && !foundWord; ++i) {\n          if (charTests[i](line.charAt(pos))) {\n            wordStart = pos;\n\n            while (pos != stop && charTests[i](line.charAt(pos))) {\n              pos += dir;\n            }\n\n            wordEnd = pos;\n            foundWord = wordStart != wordEnd;\n\n            if (wordStart == cur.ch && lineNum == cur.line && wordEnd == wordStart + dir) {\n              continue;\n            } else {\n              return {\n                from: Math.min(wordStart, wordEnd + 1),\n                to: Math.max(wordStart, wordEnd),\n                line: lineNum\n              };\n            }\n          }\n        }\n\n        if (!foundWord) {\n          pos += dir;\n        }\n      }\n\n      lineNum += dir;\n\n      if (!isLine(cm, lineNum)) {\n        return null;\n      }\n\n      line = cm.getLine(lineNum);\n      pos = dir > 0 ? 0 : line.length;\n    }\n  }\n\n  function moveToWord(cm, cur, repeat, forward, wordEnd, bigWord) {\n    var curStart = copyCursor(cur);\n    var words = [];\n\n    if (forward && !wordEnd || !forward && wordEnd) {\n      repeat++;\n    }\n\n    var emptyLineIsWord = !(forward && wordEnd);\n\n    for (var i = 0; i < repeat; i++) {\n      var word = findWord(cm, cur, forward, bigWord, emptyLineIsWord);\n\n      if (!word) {\n        var eodCh = lineLength(cm, cm.lastLine());\n        words.push(forward ? {\n          line: cm.lastLine(),\n          from: eodCh,\n          to: eodCh\n        } : {\n          line: 0,\n          from: 0,\n          to: 0\n        });\n        break;\n      }\n\n      words.push(word);\n      cur = new Pos(word.line, forward ? word.to - 1 : word.from);\n    }\n\n    var shortCircuit = words.length != repeat;\n    var firstWord = words[0];\n    var lastWord = words.pop();\n\n    if (forward && !wordEnd) {\n      if (!shortCircuit && (firstWord.from != curStart.ch || firstWord.line != curStart.line)) {\n        lastWord = words.pop();\n      }\n\n      return new Pos(lastWord.line, lastWord.from);\n    } else if (forward && wordEnd) {\n      return new Pos(lastWord.line, lastWord.to - 1);\n    } else if (!forward && wordEnd) {\n      if (!shortCircuit && (firstWord.to != curStart.ch || firstWord.line != curStart.line)) {\n        lastWord = words.pop();\n      }\n\n      return new Pos(lastWord.line, lastWord.to);\n    } else {\n      return new Pos(lastWord.line, lastWord.from);\n    }\n  }\n\n  function moveToEol(cm, head, motionArgs, vim, keepHPos) {\n    var cur = head;\n    var retval = new Pos(cur.line + motionArgs.repeat - 1, Infinity);\n    var end = cm.clipPos(retval);\n    end.ch--;\n\n    if (!keepHPos) {\n      vim.lastHPos = Infinity;\n      vim.lastHSPos = cm.charCoords(end, 'div').left;\n    }\n\n    return retval;\n  }\n\n  function moveToCharacter(cm, repeat, forward, character) {\n    var cur = cm.getCursor();\n    var start = cur.ch;\n    var idx;\n\n    for (var i = 0; i < repeat; i++) {\n      var line = cm.getLine(cur.line);\n      idx = charIdxInLine(start, line, character, forward, true);\n\n      if (idx == -1) {\n        return null;\n      }\n\n      start = idx;\n    }\n\n    return new Pos(cm.getCursor().line, idx);\n  }\n\n  function moveToColumn(cm, repeat) {\n    var line = cm.getCursor().line;\n    return clipCursorToContent(cm, new Pos(line, repeat - 1));\n  }\n\n  function updateMark(cm, vim, markName, pos) {\n    if (!inArray(markName, validMarks)) {\n      return;\n    }\n\n    if (vim.marks[markName]) {\n      vim.marks[markName].clear();\n    }\n\n    vim.marks[markName] = cm.setBookmark(pos);\n  }\n\n  function charIdxInLine(start, line, character, forward, includeChar) {\n    var idx;\n\n    if (forward) {\n      idx = line.indexOf(character, start + 1);\n\n      if (idx != -1 && !includeChar) {\n        idx -= 1;\n      }\n    } else {\n      idx = line.lastIndexOf(character, start - 1);\n\n      if (idx != -1 && !includeChar) {\n        idx += 1;\n      }\n    }\n\n    return idx;\n  }\n\n  function findParagraph(cm, head, repeat, dir, inclusive) {\n    var line = head.line;\n    var min = cm.firstLine();\n    var max = cm.lastLine();\n    var start,\n        end,\n        i = line;\n\n    function isEmpty(i) {\n      return !/\\S/.test(cm.getLine(i));\n    } // ace_patch\n\n\n    function isBoundary(i, dir, any) {\n      if (any) {\n        return isEmpty(i) != isEmpty(i + dir);\n      }\n\n      return !isEmpty(i) && isEmpty(i + dir);\n    }\n\n    function skipFold(i) {\n      dir = dir > 0 ? 1 : -1;\n      var foldLine = cm.ace.session.getFoldLine(i);\n\n      if (foldLine) {\n        if (i + dir > foldLine.start.row && i + dir < foldLine.end.row) dir = (dir > 0 ? foldLine.end.row : foldLine.start.row) - i;\n      }\n    }\n\n    if (dir) {\n      while (min <= i && i <= max && repeat > 0) {\n        skipFold(i);\n\n        if (isBoundary(i, dir)) {\n          repeat--;\n        }\n\n        i += dir;\n      }\n\n      return new Pos(i, 0);\n    }\n\n    var vim = cm.state.vim;\n\n    if (vim.visualLine && isBoundary(line, 1, true)) {\n      var anchor = vim.sel.anchor;\n\n      if (isBoundary(anchor.line, -1, true)) {\n        if (!inclusive || anchor.line != line) {\n          line += 1;\n        }\n      }\n    }\n\n    var startState = isEmpty(line);\n\n    for (i = line; i <= max && repeat; i++) {\n      if (isBoundary(i, 1, true)) {\n        if (!inclusive || isEmpty(i) != startState) {\n          repeat--;\n        }\n      }\n    }\n\n    end = new Pos(i, 0);\n\n    if (i > max && !startState) {\n      startState = true;\n    } else {\n      inclusive = false;\n    }\n\n    for (i = line; i > min; i--) {\n      if (!inclusive || isEmpty(i) == startState || i == line) {\n        if (isBoundary(i, -1, true)) {\n          break;\n        }\n      }\n    }\n\n    start = new Pos(i, 0);\n    return {\n      start: start,\n      end: end\n    };\n  }\n\n  function getSentence(cm, cur, repeat, dir, inclusive\n  /*includes whitespace*/\n  ) {\n    function nextChar(curr) {\n      if (curr.pos + curr.dir < 0 || curr.pos + curr.dir >= curr.line.length) {\n        curr.line = null;\n      } else {\n        curr.pos += curr.dir;\n      }\n    }\n\n    function forward(cm, ln, pos, dir) {\n      var line = cm.getLine(ln);\n      var curr = {\n        line: line,\n        ln: ln,\n        pos: pos,\n        dir: dir\n      };\n\n      if (curr.line === \"\") {\n        return {\n          ln: curr.ln,\n          pos: curr.pos\n        };\n      }\n\n      var lastSentencePos = curr.pos;\n      nextChar(curr);\n\n      while (curr.line !== null) {\n        lastSentencePos = curr.pos;\n\n        if (isEndOfSentenceSymbol(curr.line[curr.pos])) {\n          if (!inclusive) {\n            return {\n              ln: curr.ln,\n              pos: curr.pos + 1\n            };\n          } else {\n            nextChar(curr);\n\n            while (curr.line !== null) {\n              if (isWhiteSpaceString(curr.line[curr.pos])) {\n                lastSentencePos = curr.pos;\n                nextChar(curr);\n              } else {\n                break;\n              }\n            }\n\n            return {\n              ln: curr.ln,\n              pos: lastSentencePos + 1\n            };\n          }\n        }\n\n        nextChar(curr);\n      }\n\n      return {\n        ln: curr.ln,\n        pos: lastSentencePos + 1\n      };\n    }\n\n    function reverse(cm, ln, pos, dir) {\n      var line = cm.getLine(ln);\n      var curr = {\n        line: line,\n        ln: ln,\n        pos: pos,\n        dir: dir\n      };\n\n      if (curr.line === \"\") {\n        return {\n          ln: curr.ln,\n          pos: curr.pos\n        };\n      }\n\n      var lastSentencePos = curr.pos;\n      nextChar(curr);\n\n      while (curr.line !== null) {\n        if (!isWhiteSpaceString(curr.line[curr.pos]) && !isEndOfSentenceSymbol(curr.line[curr.pos])) {\n          lastSentencePos = curr.pos;\n        } else if (isEndOfSentenceSymbol(curr.line[curr.pos])) {\n          if (!inclusive) {\n            return {\n              ln: curr.ln,\n              pos: lastSentencePos\n            };\n          } else {\n            if (isWhiteSpaceString(curr.line[curr.pos + 1])) {\n              return {\n                ln: curr.ln,\n                pos: curr.pos + 1\n              };\n            } else {\n              return {\n                ln: curr.ln,\n                pos: lastSentencePos\n              };\n            }\n          }\n        }\n\n        nextChar(curr);\n      }\n\n      curr.line = line;\n\n      if (inclusive && isWhiteSpaceString(curr.line[curr.pos])) {\n        return {\n          ln: curr.ln,\n          pos: curr.pos\n        };\n      } else {\n        return {\n          ln: curr.ln,\n          pos: lastSentencePos\n        };\n      }\n    }\n\n    var curr_index = {\n      ln: cur.line,\n      pos: cur.ch\n    };\n\n    while (repeat > 0) {\n      if (dir < 0) {\n        curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);\n      } else {\n        curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);\n      }\n\n      repeat--;\n    }\n\n    return new Pos(curr_index.ln, curr_index.pos);\n  }\n\n  function findSentence(cm, cur, repeat, dir) {\n    function nextChar(cm, idx) {\n      if (idx.pos + idx.dir < 0 || idx.pos + idx.dir >= idx.line.length) {\n        idx.ln += idx.dir;\n\n        if (!isLine(cm, idx.ln)) {\n          idx.line = null;\n          idx.ln = null;\n          idx.pos = null;\n          return;\n        }\n\n        idx.line = cm.getLine(idx.ln);\n        idx.pos = idx.dir > 0 ? 0 : idx.line.length - 1;\n      } else {\n        idx.pos += idx.dir;\n      }\n    }\n\n    function forward(cm, ln, pos, dir) {\n      var line = cm.getLine(ln);\n      var stop = line === \"\";\n      var curr = {\n        line: line,\n        ln: ln,\n        pos: pos,\n        dir: dir\n      };\n      var last_valid = {\n        ln: curr.ln,\n        pos: curr.pos\n      };\n      var skip_empty_lines = curr.line === \"\";\n      nextChar(cm, curr);\n\n      while (curr.line !== null) {\n        last_valid.ln = curr.ln;\n        last_valid.pos = curr.pos;\n\n        if (curr.line === \"\" && !skip_empty_lines) {\n          return {\n            ln: curr.ln,\n            pos: curr.pos\n          };\n        } else if (stop && curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n          return {\n            ln: curr.ln,\n            pos: curr.pos\n          };\n        } else if (isEndOfSentenceSymbol(curr.line[curr.pos]) && !stop && (curr.pos === curr.line.length - 1 || isWhiteSpaceString(curr.line[curr.pos + 1]))) {\n          stop = true;\n        }\n\n        nextChar(cm, curr);\n      }\n\n      var line = cm.getLine(last_valid.ln);\n      last_valid.pos = 0;\n\n      for (var i = line.length - 1; i >= 0; --i) {\n        if (!isWhiteSpaceString(line[i])) {\n          last_valid.pos = i;\n          break;\n        }\n      }\n\n      return last_valid;\n    }\n\n    function reverse(cm, ln, pos, dir) {\n      var line = cm.getLine(ln);\n      var curr = {\n        line: line,\n        ln: ln,\n        pos: pos,\n        dir: dir\n      };\n      var last_valid = {\n        ln: curr.ln,\n        pos: null\n      };\n      var skip_empty_lines = curr.line === \"\";\n      nextChar(cm, curr);\n\n      while (curr.line !== null) {\n        if (curr.line === \"\" && !skip_empty_lines) {\n          if (last_valid.pos !== null) {\n            return last_valid;\n          } else {\n            return {\n              ln: curr.ln,\n              pos: curr.pos\n            };\n          }\n        } else if (isEndOfSentenceSymbol(curr.line[curr.pos]) && last_valid.pos !== null && !(curr.ln === last_valid.ln && curr.pos + 1 === last_valid.pos)) {\n          return last_valid;\n        } else if (curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n          skip_empty_lines = false;\n          last_valid = {\n            ln: curr.ln,\n            pos: curr.pos\n          };\n        }\n\n        nextChar(cm, curr);\n      }\n\n      var line = cm.getLine(last_valid.ln);\n      last_valid.pos = 0;\n\n      for (var i = 0; i < line.length; ++i) {\n        if (!isWhiteSpaceString(line[i])) {\n          last_valid.pos = i;\n          break;\n        }\n      }\n\n      return last_valid;\n    }\n\n    var curr_index = {\n      ln: cur.line,\n      pos: cur.ch\n    };\n\n    while (repeat > 0) {\n      if (dir < 0) {\n        curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);\n      } else {\n        curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);\n      }\n\n      repeat--;\n    }\n\n    return new Pos(curr_index.ln, curr_index.pos);\n  }\n\n  function selectCompanionObject(cm, head, symb, inclusive) {\n    var cur = head,\n        start,\n        end;\n    var bracketRegexp = {\n      '(': /[()]/,\n      ')': /[()]/,\n      '[': /[[\\]]/,\n      ']': /[[\\]]/,\n      '{': /[{}]/,\n      '}': /[{}]/,\n      '<': /[<>]/,\n      '>': /[<>]/\n    }[symb];\n    var openSym = {\n      '(': '(',\n      ')': '(',\n      '[': '[',\n      ']': '[',\n      '{': '{',\n      '}': '{',\n      '<': '<',\n      '>': '<'\n    }[symb];\n    var curChar = cm.getLine(cur.line).charAt(cur.ch);\n    var offset = curChar === openSym ? 1 : 0;\n    start = cm.scanForBracket(new Pos(cur.line, cur.ch + offset), -1, undefined, {\n      'bracketRegex': bracketRegexp\n    });\n    end = cm.scanForBracket(new Pos(cur.line, cur.ch + offset), 1, undefined, {\n      'bracketRegex': bracketRegexp\n    });\n\n    if (!start || !end) {\n      return {\n        start: cur,\n        end: cur\n      };\n    }\n\n    start = start.pos;\n    end = end.pos;\n\n    if (start.line == end.line && start.ch > end.ch || start.line > end.line) {\n      var tmp = start;\n      start = end;\n      end = tmp;\n    }\n\n    if (inclusive) {\n      end.ch += 1;\n    } else {\n      start.ch += 1;\n    }\n\n    return {\n      start: start,\n      end: end\n    };\n  }\n\n  function findBeginningAndEnd(cm, head, symb, inclusive) {\n    var cur = copyCursor(head);\n    var line = cm.getLine(cur.line);\n    var chars = line.split('');\n    var start, end, i, len;\n    var firstIndex = chars.indexOf(symb);\n\n    if (cur.ch < firstIndex) {\n      cur.ch = firstIndex;\n    } else if (firstIndex < cur.ch && chars[cur.ch] == symb) {\n      end = cur.ch; // assign end to the current cursor\n\n      --cur.ch; // make sure to look backwards\n    }\n\n    if (chars[cur.ch] == symb && !end) {\n      start = cur.ch + 1; // assign start to ahead of the cursor\n    } else {\n      for (i = cur.ch; i > -1 && !start; i--) {\n        if (chars[i] == symb) {\n          start = i + 1;\n        }\n      }\n    }\n\n    if (start && !end) {\n      for (i = start, len = chars.length; i < len && !end; i++) {\n        if (chars[i] == symb) {\n          end = i;\n        }\n      }\n    }\n\n    if (!start || !end) {\n      return {\n        start: cur,\n        end: cur\n      };\n    }\n\n    if (inclusive) {\n      --start;\n      ++end;\n    }\n\n    return {\n      start: new Pos(cur.line, start),\n      end: new Pos(cur.line, end)\n    };\n  }\n\n  defineOption('pcre', true, 'boolean');\n\n  function SearchState() {}\n\n  SearchState.prototype = {\n    getQuery: function () {\n      return vimGlobalState.query;\n    },\n    setQuery: function (query) {\n      vimGlobalState.query = query;\n    },\n    getOverlay: function () {\n      return this.searchOverlay;\n    },\n    setOverlay: function (overlay) {\n      this.searchOverlay = overlay;\n    },\n    isReversed: function () {\n      return vimGlobalState.isReversed;\n    },\n    setReversed: function (reversed) {\n      vimGlobalState.isReversed = reversed;\n    },\n    getScrollbarAnnotate: function () {\n      return this.annotate;\n    },\n    setScrollbarAnnotate: function (annotate) {\n      this.annotate = annotate;\n    }\n  };\n\n  function getSearchState(cm) {\n    var vim = cm.state.vim;\n    return vim.searchState_ || (vim.searchState_ = new SearchState());\n  }\n\n  function splitBySlash(argString) {\n    return splitBySeparator(argString, '/');\n  }\n\n  function findUnescapedSlashes(argString) {\n    return findUnescapedSeparators(argString, '/');\n  }\n\n  function splitBySeparator(argString, separator) {\n    var slashes = findUnescapedSeparators(argString, separator) || [];\n    if (!slashes.length) return [];\n    var tokens = [];\n    if (slashes[0] !== 0) return;\n\n    for (var i = 0; i < slashes.length; i++) {\n      if (typeof slashes[i] == 'number') tokens.push(argString.substring(slashes[i] + 1, slashes[i + 1]));\n    }\n\n    return tokens;\n  }\n\n  function findUnescapedSeparators(str, separator) {\n    if (!separator) separator = '/';\n    var escapeNextChar = false;\n    var slashes = [];\n\n    for (var i = 0; i < str.length; i++) {\n      var c = str.charAt(i);\n\n      if (!escapeNextChar && c == separator) {\n        slashes.push(i);\n      }\n\n      escapeNextChar = !escapeNextChar && c == '\\\\';\n    }\n\n    return slashes;\n  }\n\n  function translateRegex(str) {\n    var specials = '|(){';\n    var unescape = '}';\n    var escapeNextChar = false;\n    var out = [];\n\n    for (var i = -1; i < str.length; i++) {\n      var c = str.charAt(i) || '';\n      var n = str.charAt(i + 1) || '';\n      var specialComesNext = n && specials.indexOf(n) != -1;\n\n      if (escapeNextChar) {\n        if (c !== '\\\\' || !specialComesNext) {\n          out.push(c);\n        }\n\n        escapeNextChar = false;\n      } else {\n        if (c === '\\\\') {\n          escapeNextChar = true;\n\n          if (n && unescape.indexOf(n) != -1) {\n            specialComesNext = true;\n          }\n\n          if (!specialComesNext || n === '\\\\') {\n            out.push(c);\n          }\n        } else {\n          out.push(c);\n\n          if (specialComesNext && n !== '\\\\') {\n            out.push('\\\\');\n          }\n        }\n      }\n    }\n\n    return out.join('');\n  }\n\n  var charUnescapes = {\n    '\\\\n': '\\n',\n    '\\\\r': '\\r',\n    '\\\\t': '\\t'\n  };\n\n  function translateRegexReplace(str) {\n    var escapeNextChar = false;\n    var out = [];\n\n    for (var i = -1; i < str.length; i++) {\n      var c = str.charAt(i) || '';\n      var n = str.charAt(i + 1) || '';\n\n      if (charUnescapes[c + n]) {\n        out.push(charUnescapes[c + n]);\n        i++;\n      } else if (escapeNextChar) {\n        out.push(c);\n        escapeNextChar = false;\n      } else {\n        if (c === '\\\\') {\n          escapeNextChar = true;\n\n          if (isNumber(n) || n === '$') {\n            out.push('$');\n          } else if (n !== '/' && n !== '\\\\') {\n            out.push('\\\\');\n          }\n        } else {\n          if (c === '$') {\n            out.push('$');\n          }\n\n          out.push(c);\n\n          if (n === '/') {\n            out.push('\\\\');\n          }\n        }\n      }\n    }\n\n    return out.join('');\n  }\n\n  var unescapes = {\n    '\\\\/': '/',\n    '\\\\\\\\': '\\\\',\n    '\\\\n': '\\n',\n    '\\\\r': '\\r',\n    '\\\\t': '\\t',\n    '\\\\&': '&'\n  };\n\n  function unescapeRegexReplace(str) {\n    var stream = new CodeMirror.StringStream(str);\n    var output = [];\n\n    while (!stream.eol()) {\n      while (stream.peek() && stream.peek() != '\\\\') {\n        output.push(stream.next());\n      }\n\n      var matched = false;\n\n      for (var matcher in unescapes) {\n        if (stream.match(matcher, true)) {\n          matched = true;\n          output.push(unescapes[matcher]);\n          break;\n        }\n      }\n\n      if (!matched) {\n        output.push(stream.next());\n      }\n    }\n\n    return output.join('');\n  }\n\n  function parseQuery(query, ignoreCase, smartCase) {\n    var lastSearchRegister = vimGlobalState.registerController.getRegister('/');\n    lastSearchRegister.setText(query);\n\n    if (query instanceof RegExp) {\n      return query;\n    }\n\n    var slashes = findUnescapedSlashes(query);\n    var regexPart;\n    var forceIgnoreCase;\n\n    if (!slashes.length) {\n      regexPart = query;\n    } else {\n      regexPart = query.substring(0, slashes[0]);\n      var flagsPart = query.substring(slashes[0]);\n      forceIgnoreCase = flagsPart.indexOf('i') != -1;\n    }\n\n    if (!regexPart) {\n      return null;\n    }\n\n    if (!getOption('pcre')) {\n      regexPart = translateRegex(regexPart);\n    }\n\n    if (smartCase) {\n      ignoreCase = /^[^A-Z]*$/.test(regexPart);\n    }\n\n    var regexp = new RegExp(regexPart, ignoreCase || forceIgnoreCase ? 'im' : 'm');\n    return regexp;\n  }\n\n  function dom(n) {\n    if (typeof n === 'string') n = document.createElement(n);\n\n    for (var a, i = 1; i < arguments.length; i++) {\n      if (!(a = arguments[i])) continue;\n      if (typeof a !== 'object') a = document.createTextNode(a);\n      if (a.nodeType) n.appendChild(a);else for (var key in a) {\n        if (!Object.prototype.hasOwnProperty.call(a, key)) continue;\n        if (key[0] === '$') n.style[key.slice(1)] = a[key];else n.setAttribute(key, a[key]);\n      }\n    }\n\n    return n;\n  }\n\n  function showConfirm(cm, template) {\n    var pre = dom('div', {\n      $color: 'red',\n      $whiteSpace: 'pre',\n      class: 'cm-vim-message'\n    }, template);\n\n    if (cm.openNotification) {\n      cm.openNotification(pre, {\n        bottom: true,\n        duration: 5000\n      });\n    } else {\n      alert(pre.innerText);\n    }\n  }\n\n  function makePrompt(prefix, desc) {\n    return dom(document.createDocumentFragment(), dom('span', {\n      $fontFamily: 'monospace',\n      $whiteSpace: 'pre'\n    }, prefix, dom('input', {\n      type: 'text',\n      autocorrect: 'off',\n      autocapitalize: 'off',\n      spellcheck: 'false'\n    })), desc && dom('span', {\n      $color: '#888'\n    }, desc));\n  }\n\n  function showPrompt(cm, options) {\n    var template = makePrompt(options.prefix, options.desc);\n\n    if (cm.openDialog) {\n      cm.openDialog(template, options.onClose, {\n        onKeyDown: options.onKeyDown,\n        onKeyUp: options.onKeyUp,\n        bottom: true,\n        selectValueOnOpen: false,\n        value: options.value\n      });\n    } else {\n      var shortText = '';\n      if (typeof options.prefix != \"string\" && options.prefix) shortText += options.prefix.textContent;\n      if (options.desc) shortText += \" \" + options.desc;\n      options.onClose(prompt(shortText, ''));\n    }\n  }\n\n  function regexEqual(r1, r2) {\n    if (r1 instanceof RegExp && r2 instanceof RegExp) {\n      var props = ['global', 'multiline', 'ignoreCase', 'source'];\n\n      for (var i = 0; i < props.length; i++) {\n        var prop = props[i];\n\n        if (r1[prop] !== r2[prop]) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  function updateSearchQuery(cm, rawQuery, ignoreCase, smartCase) {\n    if (!rawQuery) {\n      return;\n    }\n\n    var state = getSearchState(cm);\n    var query = parseQuery(rawQuery, !!ignoreCase, !!smartCase);\n\n    if (!query) {\n      return;\n    }\n\n    highlightSearchMatches(cm, query);\n\n    if (regexEqual(query, state.getQuery())) {\n      return query;\n    }\n\n    state.setQuery(query);\n    return query;\n  }\n\n  function searchOverlay(query) {\n    if (query.source.charAt(0) == '^') {\n      var matchSol = true;\n    }\n\n    return {\n      token: function (stream) {\n        if (matchSol && !stream.sol()) {\n          stream.skipToEnd();\n          return;\n        }\n\n        var match = stream.match(query, false);\n\n        if (match) {\n          if (match[0].length == 0) {\n            stream.next();\n            return 'searching';\n          }\n\n          if (!stream.sol()) {\n            stream.backUp(1);\n\n            if (!query.exec(stream.next() + match[0])) {\n              stream.next();\n              return null;\n            }\n          }\n\n          stream.match(query);\n          return 'searching';\n        }\n\n        while (!stream.eol()) {\n          stream.next();\n          if (stream.match(query, false)) break;\n        }\n      },\n      query: query\n    };\n  }\n\n  var highlightTimeout = 0;\n\n  function highlightSearchMatches(cm, query) {\n    clearTimeout(highlightTimeout);\n    highlightTimeout = setTimeout(function () {\n      if (!cm.state.vim) return;\n      var searchState = getSearchState(cm);\n      var overlay = searchState.getOverlay();\n\n      if (!overlay || query != overlay.query) {\n        if (overlay) {\n          cm.removeOverlay(overlay);\n        }\n\n        overlay = searchOverlay(query);\n        cm.addOverlay(overlay);\n\n        if (cm.showMatchesOnScrollbar) {\n          if (searchState.getScrollbarAnnotate()) {\n            searchState.getScrollbarAnnotate().clear();\n          }\n\n          searchState.setScrollbarAnnotate(cm.showMatchesOnScrollbar(query));\n        }\n\n        searchState.setOverlay(overlay);\n      }\n    }, 50);\n  }\n\n  function findNext(cm, prev, query, repeat) {\n    if (repeat === undefined) {\n      repeat = 1;\n    }\n\n    return cm.operation(function () {\n      var pos = cm.getCursor();\n      var cursor = cm.getSearchCursor(query, pos);\n\n      for (var i = 0; i < repeat; i++) {\n        var found = cursor.find(prev);\n\n        if (i == 0 && found && cursorEqual(cursor.from(), pos)) {\n          var lastEndPos = prev ? cursor.from() : cursor.to();\n          found = cursor.find(prev);\n\n          if (found && !found[0] && cursorEqual(cursor.from(), lastEndPos)) {\n            if (cm.getLine(lastEndPos.line).length == lastEndPos.ch) found = cursor.find(prev);\n          }\n        }\n\n        if (!found) {\n          cursor = cm.getSearchCursor(query, prev ? new Pos(cm.lastLine()) : new Pos(cm.firstLine(), 0));\n\n          if (!cursor.find(prev)) {\n            return;\n          }\n        }\n      }\n\n      return cursor.from();\n    });\n  }\n\n  function findNextFromAndToInclusive(cm, prev, query, repeat, vim) {\n    if (repeat === undefined) {\n      repeat = 1;\n    }\n\n    return cm.operation(function () {\n      var pos = cm.getCursor();\n      var cursor = cm.getSearchCursor(query, pos);\n      var found = cursor.find(!prev);\n\n      if (!vim.visualMode && found && cursorEqual(cursor.from(), pos)) {\n        cursor.find(!prev);\n      }\n\n      for (var i = 0; i < repeat; i++) {\n        found = cursor.find(prev);\n\n        if (!found) {\n          cursor = cm.getSearchCursor(query, prev ? new Pos(cm.lastLine()) : new Pos(cm.firstLine(), 0));\n\n          if (!cursor.find(prev)) {\n            return;\n          }\n        }\n      }\n\n      return [cursor.from(), cursor.to()];\n    });\n  }\n\n  function clearSearchHighlight(cm) {\n    var state = getSearchState(cm);\n    cm.removeOverlay(getSearchState(cm).getOverlay());\n    state.setOverlay(null);\n\n    if (state.getScrollbarAnnotate()) {\n      state.getScrollbarAnnotate().clear();\n      state.setScrollbarAnnotate(null);\n    }\n  }\n\n  function isInRange(pos, start, end) {\n    if (typeof pos != 'number') {\n      pos = pos.line;\n    }\n\n    if (start instanceof Array) {\n      return inArray(pos, start);\n    } else {\n      if (typeof end == 'number') {\n        return pos >= start && pos <= end;\n      } else {\n        return pos == start;\n      }\n    }\n  }\n\n  function getUserVisibleLines(cm) {\n    var renderer = cm.ace.renderer;\n    return {\n      top: renderer.getFirstFullyVisibleRow(),\n      bottom: renderer.getLastFullyVisibleRow()\n    };\n  }\n\n  function getMarkPos(cm, vim, markName) {\n    if (markName == '\\'' || markName == '`') {\n      return vimGlobalState.jumpList.find(cm, -1) || new Pos(0, 0);\n    } else if (markName == '.') {\n      return getLastEditPos(cm);\n    }\n\n    var mark = vim.marks[markName];\n    return mark && mark.find();\n  }\n\n  function getLastEditPos(cm) {\n    var undoManager = cm.ace.session.$undoManager;\n    if (undoManager && undoManager.$lastDelta) return toCmPos(undoManager.$lastDelta.end);\n  }\n\n  var ExCommandDispatcher = function () {\n    this.buildCommandMap_();\n  };\n\n  ExCommandDispatcher.prototype = {\n    processCommand: function (cm, input, opt_params) {\n      var that = this;\n      cm.operation(function () {\n        cm.curOp.isVimOp = true;\n\n        that._processCommand(cm, input, opt_params);\n      });\n    },\n    _processCommand: function (cm, input, opt_params) {\n      var vim = cm.state.vim;\n      var commandHistoryRegister = vimGlobalState.registerController.getRegister(':');\n      var previousCommand = commandHistoryRegister.toString();\n\n      if (vim.visualMode) {\n        exitVisualMode(cm);\n      }\n\n      var inputStream = new CodeMirror.StringStream(input);\n      commandHistoryRegister.setText(input);\n      var params = opt_params || {};\n      params.input = input;\n\n      try {\n        this.parseInput_(cm, inputStream, params);\n      } catch (e) {\n        showConfirm(cm, e.toString());\n        throw e;\n      }\n\n      var command;\n      var commandName;\n\n      if (!params.commandName) {\n        if (params.line !== undefined) {\n          commandName = 'move';\n        }\n      } else {\n        command = this.matchCommand_(params.commandName);\n\n        if (command) {\n          commandName = command.name;\n\n          if (command.excludeFromCommandHistory) {\n            commandHistoryRegister.setText(previousCommand);\n          }\n\n          this.parseCommandArgs_(inputStream, params, command);\n\n          if (command.type == 'exToKey') {\n            for (var i = 0; i < command.toKeys.length; i++) {\n              vimApi.handleKey(cm, command.toKeys[i], 'mapping');\n            }\n\n            return;\n          } else if (command.type == 'exToEx') {\n            this.processCommand(cm, command.toInput);\n            return;\n          }\n        }\n      }\n\n      if (!commandName) {\n        showConfirm(cm, 'Not an editor command \":' + input + '\"');\n        return;\n      }\n\n      try {\n        exCommands[commandName](cm, params);\n\n        if ((!command || !command.possiblyAsync) && params.callback) {\n          params.callback();\n        }\n      } catch (e) {\n        showConfirm(cm, e.toString());\n        throw e;\n      }\n    },\n    parseInput_: function (cm, inputStream, result) {\n      inputStream.eatWhile(':');\n\n      if (inputStream.eat('%')) {\n        result.line = cm.firstLine();\n        result.lineEnd = cm.lastLine();\n      } else {\n        result.line = this.parseLineSpec_(cm, inputStream);\n\n        if (result.line !== undefined && inputStream.eat(',')) {\n          result.lineEnd = this.parseLineSpec_(cm, inputStream);\n        }\n      }\n\n      var commandMatch = inputStream.match(/^(\\w+|!!|@@|[!#&*<=>@~])/);\n\n      if (commandMatch) {\n        result.commandName = commandMatch[1];\n      } else {\n        result.commandName = inputStream.match(/.*/)[0];\n      }\n\n      return result;\n    },\n    parseLineSpec_: function (cm, inputStream) {\n      var numberMatch = inputStream.match(/^(\\d+)/);\n\n      if (numberMatch) {\n        return parseInt(numberMatch[1], 10) - 1;\n      }\n\n      switch (inputStream.next()) {\n        case '.':\n          return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n\n        case '$':\n          return this.parseLineSpecOffset_(inputStream, cm.lastLine());\n\n        case '\\'':\n          var markName = inputStream.next();\n          var markPos = getMarkPos(cm, cm.state.vim, markName);\n          if (!markPos) throw new Error('Mark not set');\n          return this.parseLineSpecOffset_(inputStream, markPos.line);\n\n        case '-':\n        case '+':\n          inputStream.backUp(1);\n          return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n\n        default:\n          inputStream.backUp(1);\n          return undefined;\n      }\n    },\n    parseLineSpecOffset_: function (inputStream, line) {\n      var offsetMatch = inputStream.match(/^([+-])?(\\d+)/);\n\n      if (offsetMatch) {\n        var offset = parseInt(offsetMatch[2], 10);\n\n        if (offsetMatch[1] == \"-\") {\n          line -= offset;\n        } else {\n          line += offset;\n        }\n      }\n\n      return line;\n    },\n    parseCommandArgs_: function (inputStream, params, command) {\n      if (inputStream.eol()) {\n        return;\n      }\n\n      params.argString = inputStream.match(/.*/)[0];\n      var delim = command.argDelimiter || /\\s+/;\n      var args = trim(params.argString).split(delim);\n\n      if (args.length && args[0]) {\n        params.args = args;\n      }\n    },\n    matchCommand_: function (commandName) {\n      for (var i = commandName.length; i > 0; i--) {\n        var prefix = commandName.substring(0, i);\n\n        if (this.commandMap_[prefix]) {\n          var command = this.commandMap_[prefix];\n\n          if (command.name.indexOf(commandName) === 0) {\n            return command;\n          }\n        }\n      }\n\n      return null;\n    },\n    buildCommandMap_: function () {\n      this.commandMap_ = {};\n\n      for (var i = 0; i < defaultExCommandMap.length; i++) {\n        var command = defaultExCommandMap[i];\n        var key = command.shortName || command.name;\n        this.commandMap_[key] = command;\n      }\n    },\n    map: function (lhs, rhs, ctx) {\n      if (lhs != ':' && lhs.charAt(0) == ':') {\n        if (ctx) {\n          throw Error('Mode not supported for ex mappings');\n        }\n\n        var commandName = lhs.substring(1);\n\n        if (rhs != ':' && rhs.charAt(0) == ':') {\n          this.commandMap_[commandName] = {\n            name: commandName,\n            type: 'exToEx',\n            toInput: rhs.substring(1),\n            user: true\n          };\n        } else {\n          this.commandMap_[commandName] = {\n            name: commandName,\n            type: 'exToKey',\n            toKeys: rhs,\n            user: true\n          };\n        }\n      } else {\n        if (rhs != ':' && rhs.charAt(0) == ':') {\n          var mapping = {\n            keys: lhs,\n            type: 'keyToEx',\n            exArgs: {\n              input: rhs.substring(1)\n            }\n          };\n\n          if (ctx) {\n            mapping.context = ctx;\n          }\n\n          defaultKeymap.unshift(mapping);\n        } else {\n          var mapping = {\n            keys: lhs,\n            type: 'keyToKey',\n            toKeys: rhs\n          };\n\n          if (ctx) {\n            mapping.context = ctx;\n          }\n\n          defaultKeymap.unshift(mapping);\n        }\n      }\n    },\n    unmap: function (lhs, ctx) {\n      if (lhs != ':' && lhs.charAt(0) == ':') {\n        if (ctx) {\n          throw Error('Mode not supported for ex mappings');\n        }\n\n        var commandName = lhs.substring(1);\n\n        if (this.commandMap_[commandName] && this.commandMap_[commandName].user) {\n          delete this.commandMap_[commandName];\n          return true;\n        }\n      } else {\n        var keys = lhs;\n\n        for (var i = 0; i < defaultKeymap.length; i++) {\n          if (keys == defaultKeymap[i].keys && defaultKeymap[i].context === ctx) {\n            defaultKeymap.splice(i, 1);\n            return true;\n          }\n        }\n      }\n    }\n  };\n  var exCommands = {\n    colorscheme: function (cm, params) {\n      if (!params.args || params.args.length < 1) {\n        showConfirm(cm, cm.getOption('theme'));\n        return;\n      }\n\n      cm.setOption('theme', params.args[0]);\n    },\n    map: function (cm, params, ctx) {\n      var mapArgs = params.args;\n\n      if (!mapArgs || mapArgs.length < 2) {\n        if (cm) {\n          showConfirm(cm, 'Invalid mapping: ' + params.input);\n        }\n\n        return;\n      }\n\n      exCommandDispatcher.map(mapArgs[0], mapArgs[1], ctx);\n    },\n    imap: function (cm, params) {\n      this.map(cm, params, 'insert');\n    },\n    nmap: function (cm, params) {\n      this.map(cm, params, 'normal');\n    },\n    vmap: function (cm, params) {\n      this.map(cm, params, 'visual');\n    },\n    unmap: function (cm, params, ctx) {\n      var mapArgs = params.args;\n\n      if (!mapArgs || mapArgs.length < 1 || !exCommandDispatcher.unmap(mapArgs[0], ctx)) {\n        if (cm) {\n          showConfirm(cm, 'No such mapping: ' + params.input);\n        }\n      }\n    },\n    move: function (cm, params) {\n      commandDispatcher.processCommand(cm, cm.state.vim, {\n        type: 'motion',\n        motion: 'moveToLineOrEdgeOfDocument',\n        motionArgs: {\n          forward: false,\n          explicitRepeat: true,\n          linewise: true\n        },\n        repeatOverride: params.line + 1\n      });\n    },\n    set: function (cm, params) {\n      var setArgs = params.args;\n      var setCfg = params.setCfg || {};\n\n      if (!setArgs || setArgs.length < 1) {\n        if (cm) {\n          showConfirm(cm, 'Invalid mapping: ' + params.input);\n        }\n\n        return;\n      }\n\n      var expr = setArgs[0].split('=');\n      var optionName = expr[0];\n      var value = expr[1];\n      var forceGet = false;\n\n      if (optionName.charAt(optionName.length - 1) == '?') {\n        if (value) {\n          throw Error('Trailing characters: ' + params.argString);\n        }\n\n        optionName = optionName.substring(0, optionName.length - 1);\n        forceGet = true;\n      }\n\n      if (value === undefined && optionName.substring(0, 2) == 'no') {\n        optionName = optionName.substring(2);\n        value = false;\n      }\n\n      var optionIsBoolean = options[optionName] && options[optionName].type == 'boolean';\n\n      if (optionIsBoolean && value == undefined) {\n        value = true;\n      }\n\n      if (!optionIsBoolean && value === undefined || forceGet) {\n        var oldValue = getOption(optionName, cm, setCfg);\n\n        if (oldValue instanceof Error) {\n          showConfirm(cm, oldValue.message);\n        } else if (oldValue === true || oldValue === false) {\n          showConfirm(cm, ' ' + (oldValue ? '' : 'no') + optionName);\n        } else {\n          showConfirm(cm, '  ' + optionName + '=' + oldValue);\n        }\n      } else {\n        var setOptionReturn = setOption(optionName, value, cm, setCfg);\n\n        if (setOptionReturn instanceof Error) {\n          showConfirm(cm, setOptionReturn.message);\n        }\n      }\n    },\n    setlocal: function (cm, params) {\n      params.setCfg = {\n        scope: 'local'\n      };\n      this.set(cm, params);\n    },\n    setglobal: function (cm, params) {\n      params.setCfg = {\n        scope: 'global'\n      };\n      this.set(cm, params);\n    },\n    registers: function (cm, params) {\n      var regArgs = params.args;\n      var registers = vimGlobalState.registerController.registers;\n      var regInfo = '----------Registers----------\\n\\n';\n\n      if (!regArgs) {\n        for (var registerName in registers) {\n          var text = registers[registerName].toString();\n\n          if (text.length) {\n            regInfo += '\"' + registerName + '    ' + text + '\\n';\n          }\n        }\n      } else {\n        var registerName;\n        regArgs = regArgs.join('');\n\n        for (var i = 0; i < regArgs.length; i++) {\n          registerName = regArgs.charAt(i);\n\n          if (!vimGlobalState.registerController.isValidRegister(registerName)) {\n            continue;\n          }\n\n          var register = registers[registerName] || new Register();\n          regInfo += '\"' + registerName + '    ' + register.toString() + '\\n';\n        }\n      }\n\n      showConfirm(cm, regInfo);\n    },\n    sort: function (cm, params) {\n      var reverse, ignoreCase, unique, number, pattern;\n\n      function parseArgs() {\n        if (params.argString) {\n          var args = new CodeMirror.StringStream(params.argString);\n\n          if (args.eat('!')) {\n            reverse = true;\n          }\n\n          if (args.eol()) {\n            return;\n          }\n\n          if (!args.eatSpace()) {\n            return 'Invalid arguments';\n          }\n\n          var opts = args.match(/([dinuox]+)?\\s*(\\/.+\\/)?\\s*/);\n\n          if (!opts && !args.eol()) {\n            return 'Invalid arguments';\n          }\n\n          if (opts[1]) {\n            ignoreCase = opts[1].indexOf('i') != -1;\n            unique = opts[1].indexOf('u') != -1;\n            var decimal = opts[1].indexOf('d') != -1 || opts[1].indexOf('n') != -1 && 1;\n            var hex = opts[1].indexOf('x') != -1 && 1;\n            var octal = opts[1].indexOf('o') != -1 && 1;\n\n            if (decimal + hex + octal > 1) {\n              return 'Invalid arguments';\n            }\n\n            number = decimal && 'decimal' || hex && 'hex' || octal && 'octal';\n          }\n\n          if (opts[2]) {\n            pattern = new RegExp(opts[2].substr(1, opts[2].length - 2), ignoreCase ? 'i' : '');\n          }\n        }\n      }\n\n      var err = parseArgs();\n\n      if (err) {\n        showConfirm(cm, err + ': ' + params.argString);\n        return;\n      }\n\n      var lineStart = params.line || cm.firstLine();\n      var lineEnd = params.lineEnd || params.line || cm.lastLine();\n\n      if (lineStart == lineEnd) {\n        return;\n      }\n\n      var curStart = new Pos(lineStart, 0);\n      var curEnd = new Pos(lineEnd, lineLength(cm, lineEnd));\n      var text = cm.getRange(curStart, curEnd).split('\\n');\n      var numberRegex = pattern ? pattern : number == 'decimal' ? /(-?)([\\d]+)/ : number == 'hex' ? /(-?)(?:0x)?([0-9a-f]+)/i : number == 'octal' ? /([0-7]+)/ : null;\n      var radix = number == 'decimal' ? 10 : number == 'hex' ? 16 : number == 'octal' ? 8 : null;\n      var numPart = [],\n          textPart = [];\n\n      if (number || pattern) {\n        for (var i = 0; i < text.length; i++) {\n          var matchPart = pattern ? text[i].match(pattern) : null;\n\n          if (matchPart && matchPart[0] != '') {\n            numPart.push(matchPart);\n          } else if (!pattern && numberRegex.exec(text[i])) {\n            numPart.push(text[i]);\n          } else {\n            textPart.push(text[i]);\n          }\n        }\n      } else {\n        textPart = text;\n      }\n\n      function compareFn(a, b) {\n        if (reverse) {\n          var tmp;\n          tmp = a;\n          a = b;\n          b = tmp;\n        }\n\n        if (ignoreCase) {\n          a = a.toLowerCase();\n          b = b.toLowerCase();\n        }\n\n        var anum = number && numberRegex.exec(a);\n        var bnum = number && numberRegex.exec(b);\n\n        if (!anum) {\n          return a < b ? -1 : 1;\n        }\n\n        anum = parseInt((anum[1] + anum[2]).toLowerCase(), radix);\n        bnum = parseInt((bnum[1] + bnum[2]).toLowerCase(), radix);\n        return anum - bnum;\n      }\n\n      function comparePatternFn(a, b) {\n        if (reverse) {\n          var tmp;\n          tmp = a;\n          a = b;\n          b = tmp;\n        }\n\n        if (ignoreCase) {\n          a[0] = a[0].toLowerCase();\n          b[0] = b[0].toLowerCase();\n        }\n\n        return a[0] < b[0] ? -1 : 1;\n      }\n\n      numPart.sort(pattern ? comparePatternFn : compareFn);\n\n      if (pattern) {\n        for (var i = 0; i < numPart.length; i++) {\n          numPart[i] = numPart[i].input;\n        }\n      } else if (!number) {\n        textPart.sort(compareFn);\n      }\n\n      text = !reverse ? textPart.concat(numPart) : numPart.concat(textPart);\n\n      if (unique) {\n        // Remove duplicate lines\n        var textOld = text;\n        var lastLine;\n        text = [];\n\n        for (var i = 0; i < textOld.length; i++) {\n          if (textOld[i] != lastLine) {\n            text.push(textOld[i]);\n          }\n\n          lastLine = textOld[i];\n        }\n      }\n\n      cm.replaceRange(text.join('\\n'), curStart, curEnd);\n    },\n    vglobal: function (cm, params) {\n      this.global(cm, params);\n    },\n    global: function (cm, params) {\n      var argString = params.argString;\n\n      if (!argString) {\n        showConfirm(cm, 'Regular Expression missing from global');\n        return;\n      }\n\n      var inverted = params.commandName[0] === 'v';\n      var lineStart = params.line !== undefined ? params.line : cm.firstLine();\n      var lineEnd = params.lineEnd || params.line || cm.lastLine();\n      var tokens = splitBySlash(argString);\n      var regexPart = argString,\n          cmd;\n\n      if (tokens.length) {\n        regexPart = tokens[0];\n        cmd = tokens.slice(1, tokens.length).join('/');\n      }\n\n      if (regexPart) {\n        try {\n          updateSearchQuery(cm, regexPart, true\n          /** ignoreCase */\n          , true\n          /** smartCase */\n          );\n        } catch (e) {\n          showConfirm(cm, 'Invalid regex: ' + regexPart);\n          return;\n        }\n      }\n\n      var query = getSearchState(cm).getQuery();\n      var matchedLines = [];\n\n      for (var i = lineStart; i <= lineEnd; i++) {\n        var line = cm.getLineHandle(i);\n        var matched = query.test(line.text);\n\n        if (matched !== inverted) {\n          matchedLines.push(cmd ? line : line.text);\n        }\n      }\n\n      if (!cmd) {\n        showConfirm(cm, matchedLines.join('\\n'));\n        return;\n      }\n\n      var index = 0;\n\n      var nextCommand = function () {\n        if (index < matchedLines.length) {\n          var line = matchedLines[index++];\n          var lineNum = cm.getLineNumber(line);\n\n          if (lineNum == null) {\n            nextCommand();\n            return;\n          }\n\n          var command = lineNum + 1 + cmd;\n          exCommandDispatcher.processCommand(cm, command, {\n            callback: nextCommand\n          });\n        }\n      };\n\n      nextCommand();\n    },\n    substitute: function (cm, params) {\n      if (!cm.getSearchCursor) {\n        throw new Error('Search feature not available. Requires searchcursor.js or ' + 'any other getSearchCursor implementation.');\n      }\n\n      var argString = params.argString;\n      var tokens = argString ? splitBySeparator(argString, argString[0]) : [];\n      var regexPart,\n          replacePart = '',\n          trailing,\n          flagsPart,\n          count;\n      var confirm = false; // Whether to confirm each replace.\n\n      var global = false; // True to replace all instances on a line, false to replace only 1.\n\n      if (tokens.length) {\n        regexPart = tokens[0];\n\n        if (getOption('pcre') && regexPart !== '') {\n          regexPart = new RegExp(regexPart).source; //normalize not escaped characters\n        }\n\n        replacePart = tokens[1];\n\n        if (replacePart !== undefined) {\n          if (getOption('pcre')) {\n            replacePart = unescapeRegexReplace(replacePart.replace(/([^\\\\])&/g, \"$1$$&\"));\n          } else {\n            replacePart = translateRegexReplace(replacePart);\n          }\n\n          vimGlobalState.lastSubstituteReplacePart = replacePart;\n        }\n\n        trailing = tokens[2] ? tokens[2].split(' ') : [];\n      } else {\n        if (argString && argString.length) {\n          showConfirm(cm, 'Substitutions should be of the form ' + ':s/pattern/replace/');\n          return;\n        }\n      }\n\n      if (trailing) {\n        flagsPart = trailing[0];\n        count = parseInt(trailing[1]);\n\n        if (flagsPart) {\n          if (flagsPart.indexOf('c') != -1) {\n            confirm = true;\n          }\n\n          if (flagsPart.indexOf('g') != -1) {\n            global = true;\n          }\n\n          if (getOption('pcre')) {\n            regexPart = regexPart + '/' + flagsPart;\n          } else {\n            regexPart = regexPart.replace(/\\//g, \"\\\\/\") + '/' + flagsPart;\n          }\n        }\n      }\n\n      if (regexPart) {\n        try {\n          updateSearchQuery(cm, regexPart, true\n          /** ignoreCase */\n          , true\n          /** smartCase */\n          );\n        } catch (e) {\n          showConfirm(cm, 'Invalid regex: ' + regexPart);\n          return;\n        }\n      }\n\n      replacePart = replacePart || vimGlobalState.lastSubstituteReplacePart;\n\n      if (replacePart === undefined) {\n        showConfirm(cm, 'No previous substitute regular expression');\n        return;\n      }\n\n      var state = getSearchState(cm);\n      var query = state.getQuery();\n      var lineStart = params.line !== undefined ? params.line : cm.getCursor().line;\n      var lineEnd = params.lineEnd || lineStart;\n\n      if (lineStart == cm.firstLine() && lineEnd == cm.lastLine()) {\n        lineEnd = Infinity;\n      }\n\n      if (count) {\n        lineStart = lineEnd;\n        lineEnd = lineStart + count - 1;\n      }\n\n      var startPos = clipCursorToContent(cm, new Pos(lineStart, 0));\n      var cursor = cm.getSearchCursor(query, startPos);\n      doReplace(cm, confirm, global, lineStart, lineEnd, cursor, query, replacePart, params.callback);\n    },\n    redo: CodeMirror.commands.redo,\n    undo: CodeMirror.commands.undo,\n    write: function (cm) {\n      if (CodeMirror.commands.save) {\n        CodeMirror.commands.save(cm);\n      } else if (cm.save) {\n        cm.save();\n      }\n    },\n    nohlsearch: function (cm) {\n      clearSearchHighlight(cm);\n    },\n    yank: function (cm) {\n      var cur = copyCursor(cm.getCursor());\n      var line = cur.line;\n      var lineText = cm.getLine(line);\n      vimGlobalState.registerController.pushText('0', 'yank', lineText, true, true);\n    },\n    delmarks: function (cm, params) {\n      if (!params.argString || !trim(params.argString)) {\n        showConfirm(cm, 'Argument required');\n        return;\n      }\n\n      var state = cm.state.vim;\n      var stream = new CodeMirror.StringStream(trim(params.argString));\n\n      while (!stream.eol()) {\n        stream.eatSpace();\n        var count = stream.pos;\n\n        if (!stream.match(/[a-zA-Z]/, false)) {\n          showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n          return;\n        }\n\n        var sym = stream.next();\n\n        if (stream.match('-', true)) {\n          if (!stream.match(/[a-zA-Z]/, false)) {\n            showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n            return;\n          }\n\n          var startMark = sym;\n          var finishMark = stream.next();\n\n          if (isLowerCase(startMark) && isLowerCase(finishMark) || isUpperCase(startMark) && isUpperCase(finishMark)) {\n            var start = startMark.charCodeAt(0);\n            var finish = finishMark.charCodeAt(0);\n\n            if (start >= finish) {\n              showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n              return;\n            }\n\n            for (var j = 0; j <= finish - start; j++) {\n              var mark = String.fromCharCode(start + j);\n              delete state.marks[mark];\n            }\n          } else {\n            showConfirm(cm, 'Invalid argument: ' + startMark + '-');\n            return;\n          }\n        } else {\n          delete state.marks[sym];\n        }\n      }\n    }\n  };\n  var exCommandDispatcher = new ExCommandDispatcher();\n\n  function doReplace(cm, confirm, global, lineStart, lineEnd, searchCursor, query, replaceWith, callback) {\n    cm.state.vim.exMode = true;\n    var done = false;\n    var lastPos, modifiedLineNumber, joined;\n\n    function replaceAll() {\n      cm.operation(function () {\n        while (!done) {\n          replace();\n          next();\n        }\n\n        stop();\n      });\n    }\n\n    function replace() {\n      var text = cm.getRange(searchCursor.from(), searchCursor.to());\n      var newText = text.replace(query, replaceWith);\n      var unmodifiedLineNumber = searchCursor.to().line;\n      searchCursor.replace(newText);\n      modifiedLineNumber = searchCursor.to().line;\n      lineEnd += modifiedLineNumber - unmodifiedLineNumber;\n      joined = modifiedLineNumber < unmodifiedLineNumber;\n    }\n\n    function findNextValidMatch() {\n      var lastMatchTo = lastPos && copyCursor(searchCursor.to());\n      var match = searchCursor.findNext();\n\n      if (match && !match[0] && lastMatchTo && cursorEqual(searchCursor.from(), lastMatchTo)) {\n        match = searchCursor.findNext();\n      }\n\n      return match;\n    }\n\n    function next() {\n      while (findNextValidMatch() && isInRange(searchCursor.from(), lineStart, lineEnd)) {\n        if (!global && searchCursor.from().line == modifiedLineNumber && !joined) {\n          continue;\n        }\n\n        cm.scrollIntoView(searchCursor.from(), 30);\n        cm.setSelection(searchCursor.from(), searchCursor.to());\n        lastPos = searchCursor.from();\n        done = false;\n        return;\n      }\n\n      done = true;\n    }\n\n    function stop(close) {\n      if (close) {\n        close();\n      }\n\n      cm.focus();\n\n      if (lastPos) {\n        cm.setCursor(lastPos);\n        var vim = cm.state.vim;\n        vim.exMode = false;\n        vim.lastHPos = vim.lastHSPos = lastPos.ch;\n      }\n\n      if (callback) {\n        callback();\n      }\n    }\n\n    function onPromptKeyDown(e, _value, close) {\n      CodeMirror.e_stop(e);\n      var keyName = CodeMirror.keyName(e);\n\n      switch (keyName) {\n        case 'Y':\n          replace();\n          next();\n          break;\n\n        case 'N':\n          next();\n          break;\n\n        case 'A':\n          var savedCallback = callback;\n          callback = undefined;\n          cm.operation(replaceAll);\n          callback = savedCallback;\n          break;\n\n        case 'L':\n          replace();\n\n        case 'Q':\n        case 'Esc':\n        case 'Ctrl-C':\n        case 'Ctrl-[':\n          stop(close);\n          break;\n      }\n\n      if (done) {\n        stop(close);\n      }\n\n      return true;\n    }\n\n    next();\n\n    if (done) {\n      showConfirm(cm, 'No matches for ' + query.source);\n      return;\n    }\n\n    if (!confirm) {\n      replaceAll();\n\n      if (callback) {\n        callback();\n      }\n\n      return;\n    }\n\n    showPrompt(cm, {\n      prefix: dom('span', 'replace with ', dom('strong', replaceWith), ' (y/n/a/q/l)'),\n      onKeyDown: onPromptKeyDown\n    });\n  }\n\n  CodeMirror.keyMap.vim = {\n    attach: attachVimMap,\n    detach: detachVimMap,\n    call: cmKey\n  };\n\n  function exitInsertMode(cm) {\n    var vim = cm.state.vim;\n    var macroModeState = vimGlobalState.macroModeState;\n    var insertModeChangeRegister = vimGlobalState.registerController.getRegister('.');\n    var isPlaying = macroModeState.isPlaying;\n    var lastChange = macroModeState.lastInsertModeChanges;\n\n    if (!isPlaying) {\n      cm.off('change', onChange);\n      CodeMirror.off(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n    }\n\n    if (!isPlaying && vim.insertModeRepeat > 1) {\n      repeatLastEdit(cm, vim, vim.insertModeRepeat - 1, true\n      /** repeatForInsert */\n      );\n      vim.lastEditInputState.repeatOverride = vim.insertModeRepeat;\n    }\n\n    delete vim.insertModeRepeat;\n    vim.insertMode = false;\n    cm.setCursor(cm.getCursor().line, cm.getCursor().ch - 1);\n    cm.setOption('keyMap', 'vim');\n    cm.setOption('disableInput', true);\n    cm.toggleOverwrite(false); // exit replace mode if we were in it.\n\n    insertModeChangeRegister.setText(lastChange.changes.join(''));\n    CodeMirror.signal(cm, \"vim-mode-change\", {\n      mode: \"normal\"\n    });\n\n    if (macroModeState.isRecording) {\n      logInsertModeChange(macroModeState);\n    }\n  }\n\n  function _mapCommand(command) {\n    defaultKeymap.unshift(command);\n  }\n\n  function mapCommand(keys, type, name, args, extra) {\n    var command = {\n      keys: keys,\n      type: type\n    };\n    command[type] = name;\n    command[type + \"Args\"] = args;\n\n    for (var key in extra) command[key] = extra[key];\n\n    _mapCommand(command);\n  }\n\n  defineOption('insertModeEscKeysTimeout', 200, 'number');\n  CodeMirror.keyMap['vim-insert'] = {\n    fallthrough: ['default'],\n    attach: attachVimMap,\n    detach: detachVimMap,\n    call: cmKey\n  };\n  CodeMirror.keyMap['vim-replace'] = {\n    'Backspace': 'goCharLeft',\n    fallthrough: ['vim-insert'],\n    attach: attachVimMap,\n    detach: detachVimMap,\n    call: cmKey\n  };\n\n  function executeMacroRegister(cm, vim, macroModeState, registerName) {\n    var register = vimGlobalState.registerController.getRegister(registerName);\n\n    if (registerName == ':') {\n      if (register.keyBuffer[0]) {\n        exCommandDispatcher.processCommand(cm, register.keyBuffer[0]);\n      }\n\n      macroModeState.isPlaying = false;\n      return;\n    }\n\n    var keyBuffer = register.keyBuffer;\n    var imc = 0;\n    macroModeState.isPlaying = true;\n    macroModeState.replaySearchQueries = register.searchQueries.slice(0);\n\n    for (var i = 0; i < keyBuffer.length; i++) {\n      var text = keyBuffer[i];\n      var match, key;\n\n      while (text) {\n        match = /<\\w+-.+?>|<\\w+>|./.exec(text);\n        key = match[0];\n        text = text.substring(match.index + key.length);\n        vimApi.handleKey(cm, key, 'macro');\n\n        if (vim.insertMode) {\n          var changes = register.insertModeChanges[imc++].changes;\n          vimGlobalState.macroModeState.lastInsertModeChanges.changes = changes;\n          repeatInsertModeChanges(cm, changes, 1);\n          exitInsertMode(cm);\n        }\n      }\n    }\n\n    macroModeState.isPlaying = false;\n  }\n\n  function logKey(macroModeState, key) {\n    if (macroModeState.isPlaying) {\n      return;\n    }\n\n    var registerName = macroModeState.latestRegister;\n    var register = vimGlobalState.registerController.getRegister(registerName);\n\n    if (register) {\n      register.pushText(key);\n    }\n  }\n\n  function logInsertModeChange(macroModeState) {\n    if (macroModeState.isPlaying) {\n      return;\n    }\n\n    var registerName = macroModeState.latestRegister;\n    var register = vimGlobalState.registerController.getRegister(registerName);\n\n    if (register && register.pushInsertModeChanges) {\n      register.pushInsertModeChanges(macroModeState.lastInsertModeChanges);\n    }\n  }\n\n  function logSearchQuery(macroModeState, query) {\n    if (macroModeState.isPlaying) {\n      return;\n    }\n\n    var registerName = macroModeState.latestRegister;\n    var register = vimGlobalState.registerController.getRegister(registerName);\n\n    if (register && register.pushSearchQuery) {\n      register.pushSearchQuery(query);\n    }\n  }\n\n  function onChange(cm, changeObj) {\n    var macroModeState = vimGlobalState.macroModeState;\n    var lastChange = macroModeState.lastInsertModeChanges;\n\n    if (!macroModeState.isPlaying) {\n      while (changeObj) {\n        lastChange.expectCursorActivityForChange = true;\n\n        if (lastChange.ignoreCount > 1) {\n          lastChange.ignoreCount--;\n        } else if (changeObj.origin == '+input' || changeObj.origin == 'paste' || changeObj.origin === undefined\n        /* only in testing */\n        ) {\n          var selectionCount = cm.listSelections().length;\n          if (selectionCount > 1) lastChange.ignoreCount = selectionCount;\n          var text = changeObj.text.join('\\n');\n\n          if (lastChange.maybeReset) {\n            lastChange.changes = [];\n            lastChange.maybeReset = false;\n          }\n\n          if (text) {\n            if (cm.state.overwrite && !/\\n/.test(text)) {\n              lastChange.changes.push([text]);\n            } else {\n              lastChange.changes.push(text);\n            }\n          }\n        }\n\n        changeObj = changeObj.next;\n      }\n    }\n  }\n\n  function onCursorActivity(cm) {\n    var vim = cm.state.vim;\n\n    if (vim.insertMode) {\n      var macroModeState = vimGlobalState.macroModeState;\n\n      if (macroModeState.isPlaying) {\n        return;\n      }\n\n      var lastChange = macroModeState.lastInsertModeChanges;\n\n      if (lastChange.expectCursorActivityForChange) {\n        lastChange.expectCursorActivityForChange = false;\n      } else {\n        lastChange.maybeReset = true;\n      }\n    } else if (!cm.curOp.isVimOp) {\n      handleExternalSelection(cm, vim);\n    }\n  }\n\n  function handleExternalSelection(cm, vim, keepHPos) {\n    var anchor = cm.getCursor('anchor');\n    var head = cm.getCursor('head');\n\n    if (vim.visualMode && !cm.somethingSelected()) {\n      exitVisualMode(cm, false);\n    } else if (!vim.visualMode && !vim.insertMode && cm.somethingSelected()) {\n      vim.visualMode = true;\n      vim.visualLine = false;\n      CodeMirror.signal(cm, \"vim-mode-change\", {\n        mode: \"visual\"\n      });\n    }\n\n    if (vim.visualMode) {\n      var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\n      var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\n      head = offsetCursor(head, 0, headOffset);\n      anchor = offsetCursor(anchor, 0, anchorOffset);\n      vim.sel = {\n        anchor: anchor,\n        head: head\n      };\n      updateMark(cm, vim, '<', cursorMin(head, anchor));\n      updateMark(cm, vim, '>', cursorMax(head, anchor));\n    } else if (!vim.insertMode && !keepHPos) {\n      vim.lastHPos = cm.getCursor().ch;\n    }\n  }\n\n  function InsertModeKey(keyName) {\n    this.keyName = keyName;\n  }\n\n  function onKeyEventTargetKeyDown(e) {\n    var macroModeState = vimGlobalState.macroModeState;\n    var lastChange = macroModeState.lastInsertModeChanges;\n    var keyName = CodeMirror.keyName(e);\n\n    if (!keyName) {\n      return;\n    }\n\n    function onKeyFound() {\n      if (lastChange.maybeReset) {\n        lastChange.changes = [];\n        lastChange.maybeReset = false;\n      }\n\n      lastChange.changes.push(new InsertModeKey(keyName));\n      return true;\n    }\n\n    if (keyName.indexOf('Delete') != -1 || keyName.indexOf('Backspace') != -1) {\n      CodeMirror.lookupKey(keyName, 'vim-insert', onKeyFound);\n    }\n  }\n\n  function repeatLastEdit(cm, vim, repeat, repeatForInsert) {\n    var macroModeState = vimGlobalState.macroModeState;\n    macroModeState.isPlaying = true;\n    var isAction = !!vim.lastEditActionCommand;\n    var cachedInputState = vim.inputState;\n\n    function repeatCommand() {\n      if (isAction) {\n        commandDispatcher.processAction(cm, vim, vim.lastEditActionCommand);\n      } else {\n        commandDispatcher.evalInput(cm, vim);\n      }\n    }\n\n    function repeatInsert(repeat) {\n      if (macroModeState.lastInsertModeChanges.changes.length > 0) {\n        repeat = !vim.lastEditActionCommand ? 1 : repeat;\n        var changeObject = macroModeState.lastInsertModeChanges;\n        repeatInsertModeChanges(cm, changeObject.changes, repeat);\n      }\n    }\n\n    vim.inputState = vim.lastEditInputState;\n\n    if (isAction && vim.lastEditActionCommand.interlaceInsertRepeat) {\n      for (var i = 0; i < repeat; i++) {\n        repeatCommand();\n        repeatInsert(1);\n      }\n    } else {\n      if (!repeatForInsert) {\n        repeatCommand();\n      }\n\n      repeatInsert(repeat);\n    }\n\n    vim.inputState = cachedInputState;\n\n    if (vim.insertMode && !repeatForInsert) {\n      exitInsertMode(cm);\n    }\n\n    macroModeState.isPlaying = false;\n  }\n\n  function repeatInsertModeChanges(cm, changes, repeat) {\n    function keyHandler(binding) {\n      if (typeof binding == 'string') {\n        CodeMirror.commands[binding](cm);\n      } else {\n        binding(cm);\n      }\n\n      return true;\n    }\n\n    var head = cm.getCursor('head');\n    var visualBlock = vimGlobalState.macroModeState.lastInsertModeChanges.visualBlock;\n\n    if (visualBlock) {\n      selectForInsert(cm, head, visualBlock + 1);\n      repeat = cm.listSelections().length;\n      cm.setCursor(head);\n    }\n\n    for (var i = 0; i < repeat; i++) {\n      if (visualBlock) {\n        cm.setCursor(offsetCursor(head, i, 0));\n      }\n\n      for (var j = 0; j < changes.length; j++) {\n        var change = changes[j];\n\n        if (change instanceof InsertModeKey) {\n          CodeMirror.lookupKey(change.keyName, 'vim-insert', keyHandler);\n        } else if (typeof change == \"string\") {\n          cm.replaceSelection(change);\n        } else {\n          var start = cm.getCursor();\n          var end = offsetCursor(start, 0, change[0].length);\n          cm.replaceRange(change[0], start, end);\n          cm.setCursor(end);\n        }\n      }\n    }\n\n    if (visualBlock) {\n      cm.setCursor(offsetCursor(head, 0, 1));\n    }\n  }\n\n  resetVimGlobalState();\n  CodeMirror.Vim = vimApi;\n  var specialKey = {\n    'return': 'CR',\n    backspace: 'BS',\n    'delete': 'Del',\n    esc: 'Esc',\n    left: 'Left',\n    right: 'Right',\n    up: 'Up',\n    down: 'Down',\n    space: 'Space',\n    insert: 'Ins',\n    home: 'Home',\n    end: 'End',\n    pageup: 'PageUp',\n    pagedown: 'PageDown',\n    enter: 'CR'\n  };\n\n  function lookupKey(hashId, key, e) {\n    if (key.length > 1 && key[0] == \"n\") {\n      key = key.replace(\"numpad\", \"\");\n    }\n\n    key = specialKey[key] || key;\n    var name = '';\n\n    if (e.ctrlKey) {\n      name += 'C-';\n    }\n\n    if (e.altKey) {\n      name += 'A-';\n    }\n\n    if ((name || key.length > 1) && e.shiftKey) {\n      name += 'S-';\n    }\n\n    name += key;\n\n    if (name.length > 1) {\n      name = '<' + name + '>';\n    }\n\n    return name;\n  }\n\n  var handleKey = vimApi.handleKey.bind(vimApi);\n\n  vimApi.handleKey = function (cm, key, origin) {\n    return cm.operation(function () {\n      return handleKey(cm, key, origin);\n    }, true);\n  };\n\n  function cloneVimState(state) {\n    var n = new state.constructor();\n    Object.keys(state).forEach(function (key) {\n      var o = state[key];\n      if (Array.isArray(o)) o = o.slice();else if (o && typeof o == \"object\" && o.constructor != Object) o = cloneVimState(o);\n      n[key] = o;\n    });\n\n    if (state.sel) {\n      n.sel = {\n        head: state.sel.head && copyCursor(state.sel.head),\n        anchor: state.sel.anchor && copyCursor(state.sel.anchor)\n      };\n    }\n\n    return n;\n  }\n\n  function multiSelectHandleKey(cm, key, origin) {\n    var isHandled = false;\n    var vim = vimApi.maybeInitVimState_(cm);\n    var visualBlock = vim.visualBlock || vim.wasInVisualBlock;\n    var wasMultiselect = cm.ace.inMultiSelectMode;\n\n    if (vim.wasInVisualBlock && !wasMultiselect) {\n      vim.wasInVisualBlock = false;\n    } else if (wasMultiselect && vim.visualBlock) {\n      vim.wasInVisualBlock = true;\n    }\n\n    if (key == '<Esc>' && !vim.insertMode && !vim.visualMode && wasMultiselect) {\n      cm.ace.exitMultiSelectMode();\n    } else if (visualBlock || !wasMultiselect || cm.ace.inVirtualSelectionMode) {\n      isHandled = vimApi.handleKey(cm, key, origin);\n    } else {\n      var old = cloneVimState(vim);\n      cm.operation(function () {\n        cm.ace.forEachSelection(function () {\n          var sel = cm.ace.selection;\n          cm.state.vim.lastHPos = sel.$desiredColumn == null ? sel.lead.column : sel.$desiredColumn;\n          var head = cm.getCursor(\"head\");\n          var anchor = cm.getCursor(\"anchor\");\n          var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\n          var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\n          head = offsetCursor(head, 0, headOffset);\n          anchor = offsetCursor(anchor, 0, anchorOffset);\n          cm.state.vim.sel.head = head;\n          cm.state.vim.sel.anchor = anchor;\n          isHandled = handleKey(cm, key, origin);\n          sel.$desiredColumn = cm.state.vim.lastHPos == -1 ? null : cm.state.vim.lastHPos;\n\n          if (cm.virtualSelectionMode()) {\n            cm.state.vim = cloneVimState(old);\n          }\n        });\n        if (cm.curOp.cursorActivity && !isHandled) cm.curOp.cursorActivity = false;\n      }, true);\n    }\n\n    if (isHandled && !vim.visualMode && !vim.insert && vim.visualMode != cm.somethingSelected()) {\n      handleExternalSelection(cm, vim, true);\n    }\n\n    return isHandled;\n  }\n\n  exports.CodeMirror = CodeMirror;\n  var getVim = vimApi.maybeInitVimState_;\n  exports.handler = {\n    $id: \"ace/keyboard/vim\",\n    drawCursor: function (element, pixelPos, config, sel, session) {\n      var vim = this.state.vim || {};\n      var w = config.characterWidth;\n      var h = config.lineHeight;\n      var top = pixelPos.top;\n      var left = pixelPos.left;\n\n      if (!vim.insertMode) {\n        var isbackwards = !sel.cursor ? session.selection.isBackwards() || session.selection.isEmpty() : Range.comparePoints(sel.cursor, sel.start) <= 0;\n        if (!isbackwards && left > w) left -= w;\n      }\n\n      if (!vim.insertMode && vim.status) {\n        h = h / 2;\n        top += h;\n      }\n\n      domLib.translate(element, left, top);\n      domLib.setStyle(element.style, \"width\", w + \"px\");\n      domLib.setStyle(element.style, \"height\", h + \"px\");\n    },\n    $getDirectionForHighlight: function (editor) {\n      var cm = editor.state.cm;\n      var vim = getVim(cm);\n\n      if (!vim.insertMode) {\n        return editor.session.selection.isBackwards() || editor.session.selection.isEmpty();\n      }\n    },\n    handleKeyboard: function (data, hashId, key, keyCode, e) {\n      var editor = data.editor;\n      var cm = editor.state.cm;\n      var vim = getVim(cm);\n      if (keyCode == -1) return;\n\n      if (!vim.insertMode) {\n        if (hashId == -1) {\n          if (key.charCodeAt(0) > 0xFF) {\n            if (data.inputKey) {\n              key = data.inputKey;\n              if (key && data.inputHash == 4) key = key.toUpperCase();\n            }\n          }\n\n          data.inputChar = key;\n        } else if (hashId == 4 || hashId == 0) {\n          if (data.inputKey == key && data.inputHash == hashId && data.inputChar) {\n            key = data.inputChar;\n            hashId = -1;\n          } else {\n            data.inputChar = null;\n            data.inputKey = key;\n            data.inputHash = hashId;\n          }\n        } else {\n          data.inputChar = data.inputKey = null;\n        }\n      }\n\n      if (cm.state.overwrite && vim.insertMode && key == \"backspace\" && hashId == 0) {\n        return {\n          command: \"gotoleft\"\n        };\n      }\n\n      if (key == \"c\" && hashId == 1) {\n        // key == \"ctrl-c\"\n        if (!useragent.isMac && editor.getCopyText()) {\n          editor.once(\"copy\", function () {\n            if (vim.insertMode) editor.selection.clearSelection();else cm.operation(function () {\n              exitVisualMode(cm);\n            });\n          });\n          return {\n            command: \"null\",\n            passEvent: true\n          };\n        }\n      }\n\n      if (key == \"esc\" && !vim.insertMode && !vim.visualMode && !cm.ace.inMultiSelectMode) {\n        var searchState = getSearchState(cm);\n        var overlay = searchState.getOverlay();\n        if (overlay) cm.removeOverlay(overlay);\n      }\n\n      if (hashId == -1 || hashId & 1 || hashId === 0 && key.length > 1) {\n        var insertMode = vim.insertMode;\n        var name = lookupKey(hashId, key, e || {});\n        if (vim.status == null) vim.status = \"\";\n        var isHandled = multiSelectHandleKey(cm, name, 'user');\n        vim = getVim(cm); // may be changed by multiSelectHandleKey\n\n        if (isHandled && vim.status != null) vim.status += name;else if (vim.status == null) vim.status = \"\";\n\n        cm._signal(\"changeStatus\");\n\n        if (!isHandled && (hashId != -1 || insertMode)) return;\n        return {\n          command: \"null\",\n          passEvent: !isHandled\n        };\n      }\n    },\n    attach: function (editor) {\n      if (!editor.state) editor.state = {};\n      var cm = new CodeMirror(editor);\n      editor.state.cm = cm;\n      editor.$vimModeHandler = this;\n      CodeMirror.keyMap.vim.attach(cm);\n      getVim(cm).status = null;\n      cm.on('vim-command-done', function () {\n        if (cm.virtualSelectionMode()) return;\n        getVim(cm).status = null;\n\n        cm.ace._signal(\"changeStatus\");\n\n        cm.ace.session.markUndoGroup();\n      });\n      cm.on(\"changeStatus\", function () {\n        cm.ace.renderer.updateCursor();\n\n        cm.ace._signal(\"changeStatus\");\n      });\n      cm.on(\"vim-mode-change\", function () {\n        if (cm.virtualSelectionMode()) return;\n        updateInputMode();\n\n        cm._signal(\"changeStatus\");\n      });\n\n      function updateInputMode() {\n        var isIntsert = getVim(cm).insertMode;\n        cm.ace.renderer.setStyle(\"normal-mode\", !isIntsert);\n        editor.textInput.setCommandMode(!isIntsert);\n        editor.renderer.$keepTextAreaAtCursor = isIntsert;\n        editor.renderer.$blockCursor = !isIntsert;\n      }\n\n      updateInputMode();\n      editor.renderer.$cursorLayer.drawCursor = this.drawCursor.bind(cm);\n    },\n    detach: function (editor) {\n      var cm = editor.state.cm;\n      CodeMirror.keyMap.vim.detach(cm);\n      cm.destroy();\n      editor.state.cm = null;\n      editor.$vimModeHandler = null;\n      editor.renderer.$cursorLayer.drawCursor = null;\n      editor.renderer.setStyle(\"normal-mode\", false);\n      editor.textInput.setCommandMode(false);\n      editor.renderer.$keepTextAreaAtCursor = true;\n    },\n    getStatusText: function (editor) {\n      var cm = editor.state.cm;\n      var vim = getVim(cm);\n      if (vim.insertMode) return \"INSERT\";\n      var status = \"\";\n\n      if (vim.visualMode) {\n        status += \"VISUAL\";\n        if (vim.visualLine) status += \" LINE\";\n        if (vim.visualBlock) status += \" BLOCK\";\n      }\n\n      if (vim.status) status += (status ? \" \" : \"\") + vim.status;\n      return status;\n    }\n  };\n  vimApi.defineOption({\n    name: \"wrap\",\n    set: function (value, cm) {\n      if (cm) {\n        cm.ace.setOption(\"wrap\", value);\n      }\n    },\n    type: \"boolean\"\n  }, false);\n  vimApi.defineEx('write', 'w', function () {\n    console.log(':write is not implemented');\n  });\n  defaultKeymap.push({\n    keys: 'zc',\n    type: 'action',\n    action: 'fold',\n    actionArgs: {\n      open: false\n    }\n  }, {\n    keys: 'zC',\n    type: 'action',\n    action: 'fold',\n    actionArgs: {\n      open: false,\n      all: true\n    }\n  }, {\n    keys: 'zo',\n    type: 'action',\n    action: 'fold',\n    actionArgs: {\n      open: true\n    }\n  }, {\n    keys: 'zO',\n    type: 'action',\n    action: 'fold',\n    actionArgs: {\n      open: true,\n      all: true\n    }\n  }, {\n    keys: 'za',\n    type: 'action',\n    action: 'fold',\n    actionArgs: {\n      toggle: true\n    }\n  }, {\n    keys: 'zA',\n    type: 'action',\n    action: 'fold',\n    actionArgs: {\n      toggle: true,\n      all: true\n    }\n  }, {\n    keys: 'zf',\n    type: 'action',\n    action: 'fold',\n    actionArgs: {\n      open: true,\n      all: true\n    }\n  }, {\n    keys: 'zd',\n    type: 'action',\n    action: 'fold',\n    actionArgs: {\n      open: true,\n      all: true\n    }\n  }, {\n    keys: '<C-A-k>',\n    type: 'action',\n    action: 'aceCommand',\n    actionArgs: {\n      name: \"addCursorAbove\"\n    }\n  }, {\n    keys: '<C-A-j>',\n    type: 'action',\n    action: 'aceCommand',\n    actionArgs: {\n      name: \"addCursorBelow\"\n    }\n  }, {\n    keys: '<C-A-S-k>',\n    type: 'action',\n    action: 'aceCommand',\n    actionArgs: {\n      name: \"addCursorAboveSkipCurrent\"\n    }\n  }, {\n    keys: '<C-A-S-j>',\n    type: 'action',\n    action: 'aceCommand',\n    actionArgs: {\n      name: \"addCursorBelowSkipCurrent\"\n    }\n  }, {\n    keys: '<C-A-h>',\n    type: 'action',\n    action: 'aceCommand',\n    actionArgs: {\n      name: \"selectMoreBefore\"\n    }\n  }, {\n    keys: '<C-A-l>',\n    type: 'action',\n    action: 'aceCommand',\n    actionArgs: {\n      name: \"selectMoreAfter\"\n    }\n  }, {\n    keys: '<C-A-S-h>',\n    type: 'action',\n    action: 'aceCommand',\n    actionArgs: {\n      name: \"selectNextBefore\"\n    }\n  }, {\n    keys: '<C-A-S-l>',\n    type: 'action',\n    action: 'aceCommand',\n    actionArgs: {\n      name: \"selectNextAfter\"\n    }\n  });\n  defaultKeymap.push({\n    keys: 'gq',\n    type: 'operator',\n    operator: 'hardWrap'\n  });\n  vimApi.defineOperator(\"hardWrap\", function (cm, operatorArgs, ranges, oldAnchor, newHead) {\n    var anchor = ranges[0].anchor.line;\n    var head = ranges[0].head.line;\n    if (operatorArgs.linewise) head--;\n    hardWrap(cm.ace, {\n      startRow: anchor,\n      endRow: head\n    });\n    return Pos(head, 0);\n  });\n  defineOption('textwidth', undefined, 'number', ['tw'], function (width, cm) {\n    if (cm === undefined) {\n      return;\n    }\n\n    if (width === undefined) {\n      var value = cm.ace.getOption('printMarginColumn');\n      return value;\n    } else {\n      var column = Math.round(width);\n\n      if (column > 1) {\n        cm.ace.setOption('printMarginColumn', column);\n      }\n    }\n  });\n\n  actions.aceCommand = function (cm, actionArgs, vim) {\n    cm.vimCmd = actionArgs;\n    if (cm.ace.inVirtualSelectionMode) cm.ace.on(\"beforeEndOperation\", delayedExecAceCommand);else delayedExecAceCommand(null, cm.ace);\n  };\n\n  function delayedExecAceCommand(op, ace) {\n    ace.off(\"beforeEndOperation\", delayedExecAceCommand);\n    var cmd = ace.state.cm.vimCmd;\n\n    if (cmd) {\n      ace.execCommand(cmd.exec ? cmd : cmd.name, cmd.args);\n    }\n\n    ace.curOp = ace.prevOp;\n  }\n\n  actions.fold = function (cm, actionArgs, vim) {\n    cm.ace.execCommand(['toggleFoldWidget', 'toggleFoldWidget', 'foldOther', 'unfoldall'][(actionArgs.all ? 2 : 0) + (actionArgs.open ? 1 : 0)]);\n  };\n\n  exports.handler.defaultKeymap = defaultKeymap;\n  exports.handler.actions = actions;\n  exports.Vim = vimApi;\n});\n\n(function () {\n  ace.require([\"ace/keyboard/vim\"], function (m) {\n    if (typeof module == \"object\" && typeof exports == \"object\" && module) {\n      module.exports = m;\n    }\n  });\n})();","map":{"version":3,"names":["ace","define","require","exports","module","Range","hardWrap","editor","options","max","column","getOption","allowMerge","row","Math","min","startRow","endRow","session","line","getLine","length","space","findSpace","indentation","exec","replace","start","end","test","nextLine","trimmedLine","trimmedNextLine","mergedLine","replaceRange","remove","before","slice","after","spaceAfter","spaceBefore","index","wrapAfterInput","e","command","name","args","cursor","selection","renderer","$printMarginColumn","lastDelta","$undoManager","$lastDelta","markUndoGroup","Editor","defineOptions","prototype","set","val","commands","on","off","value","log","d","format","p","ch","anchor","head","Array","isArray","map","x","JSON","stringify","i","arguments","f","console","EventEmitter","domLib","oop","KEYS","event","Search","useragent","SearchHighlight","multiSelectCommands","TextModeTokenRe","Mode","tokenRe","CodeMirror","state","marks","$uid","onChange","bind","onSelectionChange","onBeforeEndOperation","Pos","defineOption","setter","redo","cm","undo","newlineAndIndent","insert","goLineLeft","moveCursorLineStart","goLineRight","moveCursorLineEnd","keyMap","addClass","rmClass","e_stop","e_preventDefault","stopEvent","keyName","key","keyCode","toUpperCase","getModifierString","m","cmd","commandKeyBinding","toLowerCase","execCommand","lookupKey","handle","found","fallthrough","result","findMatchingTag","findEnclosingTag","signal","o","_signal","addListener","removeListener","isWordChar","lastIndex","implement","destroy","removeOverlay","virtualSelectionMode","inVirtualSelectionMode","delta","change","text","action","lines","curOp","changeHandlers","_eventRegistry","lastChange","next","$updateMarkers","cursorActivityHandlers","cursorActivity","inMultiSelectMode","keyBinding","removeKeyboardHandler","keyboardHandler","operation","fn","force","prevOp","startOperation","scrollIntoView","dialog","vimDialogScroll","endOperation","op","eventName","handlers","listeners","firstLine","lastLine","getLength","lineCount","setCursor","shouldScroll","exitMultiSelectMode","unfold","moveTo","scrollCursorIntoView","getCursor","sel","pos","isEmpty","lead","getRange","toCmPos","listSelections","ranges","multiSelect","rangeList","r","clipPos","setSelections","primIndex","toAcePos","comparePoints","fromPoints","fromOrientedRange","reverse","push","splice","toSingleRange","clone","range","$clipRangeToDocument","addRange","setSelection","a","h","selectTo","origin","somethingSelected","$clipPositionToDocument","foldCode","$toggleFoldWidget","markText","clear","find","isInsert","rowShift","colShift","point","cmp","bias","cmp2","Marker","id","setBookmark","bm","insertLeft","$insertRight","moveH","increment","unit","clearSelection","moveCursorBy","findPosV","amount","goalColumn","config","layerConfig","floor","height","lineHeight","screenPos","documentToScreenPosition","getScreenLength","screenToDocumentPosition","charCoords","mode","sc","left","top","lh","cw","characterWidth","bottom","coordsChar","col","getSearchCursor","query","caseFold","caseSensitive","isRegexp","RegExp","global","ignoreCase","source","search","undefined","Number","MAX_VALUE","acePos","last","findNext","findPrevious","back","setOptions","needle","wrap","backwards","regExp","from","to","doc","scrollTo","y","maxHeight","$size","scrollerHeight","$scrollPastEnd","setScrollTop","setScrollLeft","width","scrollInfo","margin","viewMargin","s","getTextRange","replaceSelection","replaceSelections","getSelection","getSelectedText","getSelections","getInputField","textInput","getElement","getWrapperElement","container","optMap","indentWithTabs","indentUnit","tabSize","firstLineNumber","readOnly","setOption","$keyMap","aceOpt","toggleOverwrite","overwrite","setOverwrite","addOverlay","$searchHighlight","highlight","marker","addDynamicMarker","updateOnChange","removeMarker","cache","re","setRegexp","updateBackMarkers","getScrollInfo","scrollLeft","scrollTop","clientHeight","clientWidth","getValue","setValue","v","getTokenTypeAt","token","getTokenAt","type","findMatchingBracket","getMatchingTags","open","openTag","close","closeTag","indentLine","method","indentRows","outdentRows","indexFromPos","positionToIndex","posFromIndex","indexToPosition","focus","blur","defaultTextHeight","scanForBracket","dir","_","bracketRegex","$findClosingBracket","$findOpeningBracket","refresh","resize","getMode","hasOwnProperty","getLineNumber","getLineHandle","call","cmPos","StringStream","string","lastColumnPos","lastColumnValue","lineStart","eol","sol","peek","charAt","eat","match","ok","eatWhile","eatSpace","skipToEnd","skipTo","indexOf","backUp","n","pattern","consume","caseInsensitive","cased","str","substr","current","hideFirstChars","inner","defineExtension","importCssString","dialogDiv","template","appendChild","document","createElement","className","innerHTML","closeNotification","newVal","currentNotificationClose","callback","closed","me","inp","activeElement","onClose","vim","status","$loop","schedule","CHANGE_CURSOR","getElementsByTagName","button","selectValueOnOpen","select","onInput","onKeyUp","onKeyDown","closeOnEnter","closeOnBlur","doneTimer","duration","clearTimeout","setTimeout","transformCursor","insertMode","visualBlock","empty","updateSelectionForSurrogateCharacters","curStart","curEnd","charCode","charCodeAt","defaultKeymap","keys","toKeys","context","motion","motionArgs","linewise","toJumplist","forward","wordEnd","bigWord","inclusive","explicitRepeat","toFirstChar","repeatOffset","isEdit","actionArgs","matchIndent","sameLine","operator","operatorArgs","indentRight","toLower","operatorMotionArgs","visualLine","shouldMoveCursor","insertAt","interlaceInsertRepeat","blockwise","keepSpaces","fullLine","exitVisualBlock","position","increase","backtrack","textObjectInner","searchArgs","querySrc","wholeWordOnly","defaultKeymapLength","defaultExCommandMap","shortName","possiblyAsync","excludeFromCommandHistory","enterVimMode","onCursorActivity","maybeInitVimState","getOnPasteFn","leaveVimMode","highlightTimeout","detachVimMap","$customCursor","attach","attachVimMap","prev","selectionChanged","Init","cmKey","vimKey","cmKeyToVimKey","vimApi","findKey","modifiers","Shift","Ctrl","Alt","Cmd","Mod","CapsLock","specialKeys","Enter","Backspace","Delete","Insert","pieces","split","lastPiece","hasCharacter","piece","isUpperCase","join","onPasteFn","offsetCursor","actions","enterInsertMode","numberRegex","wordCharTest","bigWordCharTest","makeKeyRange","size","String","fromCharCode","upperCaseAlphabet","lowerCaseAlphabet","numbers","validMarks","concat","validRegisters","upperCaseChars","isLine","isLowerCase","k","isMatchableSymbol","isNumber","isWhiteSpaceString","isEndOfSentenceSymbol","inArray","arr","defaultValue","aliases","Error","cfg","option","scope","local","createCircularJumpList","pointer","tail","buffer","add","oldCur","newCur","curMark","useNextSlot","trashMark","markPos","cursorEqual","move","offset","mark","inc","oldPointer","cachedCursor","createInsertModeChanges","c","changes","expectCursorActivityForChange","MacroModeState","latestRegister","isPlaying","isRecording","replaySearchQueries","onRecordingDone","lastInsertModeChanges","exitMacroRecordMode","macroModeState","vimGlobalState","enterMacroRecordMode","registerName","register","registerController","getRegister","openDialog","dom","class","inputState","InputState","lastEditInputState","lastEditActionCommand","lastHPos","lastHSPos","lastMotion","insertModeRepeat","visualMode","lastSelection","lastPastedText","resetVimGlobalState","searchQuery","searchIsReversed","lastSubstituteReplacePart","jumpList","lastCharacterSearch","selectedCharacter","RegisterController","searchHistoryController","HistoryController","exCommandHistoryController","optionName","lastInsertModeKeyTimer","buildKeyMap","getRegisterController","resetVimGlobalState_","getVimGlobalState_","maybeInitVimState_","suppressErrorLogging","InsertModeKey","lhs","rhs","ctx","exCommandDispatcher","unmap","noremap","toCtxArray","ctxsToMap","actualLength","origLength","mapping","newMapping","_mapCommand","mappedCtxs","filter","el","mapclear","userKeymap","contexts","j","defineEx","prefix","func","exCommands","commandMap_","handleKey","multiSelectHandleKey","handleMacroRecording","clearInputState","logKey","handleEsc","exitVisualMode","exitInsertMode","doKeyToKey","substring","handleKeyInsertMode","keyBuffer","keysAreChars","commandDispatcher","matchCommand","thisMatch","window","selections","here","pop","handleKeyNonInsertMode","keysMatcher","mainKey","operatorShortcut","pushRepeatDigit","isVimOp","processCommand","handleEx","input","defineMotion","defineAction","defineOperator","mapCommand","defineRegister","prefixRepeat","motionRepeat","getRepeat","repeat","parseInt","reason","Register","insertModeChanges","searchQueries","setText","pushText","pushInsertModeChanges","pushSearchQuery","toString","registers","unnamedRegister","isValidRegister","shiftNumericRegisters_","append","navigator","clipboard","readText","writeText","historyBuffer","iterator","initialPrefix","nextMatch","up","element","pushInput","reset","matches","commandMatches","full","partial","bestMatch","character","lastChar","repeatOverride","processMotion","processOperator","processOperatorMotion","processAction","processSearch","processEx","copyArgs","evalInput","updateCmSelection","repeatIsExplicit","recordLastEdit","getSearchState","setReversed","promptPrefix","originalQuery","getQuery","originalScrollPos","handleQuery","smartCase","updateSearchQuery","showConfirm","onPromptClose","logSearchQuery","onPromptKeyUp","target","selectionEnd","selectionStart","parsedQuery","clearSearchHighlight","onPromptKeyDown","shift","showPrompt","desc","word","expandWordUnderCursor","isKeyword","escapeRegex","exArgs","origHead","copyCursor","clipCursorToContent","origAnchor","oldHead","oldAnchor","newHead","newAnchor","noRepeat","motionResult","motions","recordJumpPosition","Infinity","updateMark","cursorIsBefore","lastSel","lineOffset","abs","chOffset","cmSel","cursorMin","cursorMax","newPositions","makeCmSelection","lineLength","tmp","expandSelectionToLine","clipToLine","exclusive","primary","operatorMoveTo","operators","actionCommand","moveToTopLine","_head","getUserVisibleLines","findFirstNonWhiteSpaceCharacter","moveToMiddleLine","moveToBottomLine","expandToLine","_cm","cur","isReversed","highlightSearchMatches","findAndSelectNextInclusive","prevInputState","findNextFromAndToInclusive","subMode","goToMark","getMarkPos","moveToOtherHighlightedEnd","jumpToMark","best","isWrongDirection","equal","between","cursorIsBetween","moveByCharacters","moveByLines","endCh","moveByDisplayLines","moveByScroll","moveToColumn","moveToEol","first","moveToStartOfLine","fold","getFoldLine","res","hitSide","lastCharCoords","goalCoords","resCoords","moveByPage","moveByParagraph","findParagraph","moveBySentence","findSentence","scrollbox","orig","dest","moveByWords","moveToWord","moveTillCharacter","moveToCharacter","recordLastCharacterSearch","moveToSymbol","findSymbol","moveToFirstNonWhiteSpaceCharacter","moveToMatchedSymbol","lineText","symbol","style","matched","moveToLineOrEdgeOfDocument","lineNum","moveToStartOfDisplayLine","moveToEndOfDisplayLine","sticky","textObjectManipulation","mirroredPairs","selfPaired","selectCompanionObject","findBeginningAndEnd","expandTagUnderCursor","content","getSentence","expandSelection","repeatLastCharacterSearch","lastSearch","fillArray","times","finalHead","lastState","prevLineEnd","wasLastLine","replacement","indent","indentMore","indentLess","startLine","endLine","indentAuto","_args","changeCase","swapped","toSwap","yank","endPos","jumpListWalk","scroll","newPos","cursorCoords","ceil","newBottom","scrollToCursor","lineLastCharPos","lineLastCharCoords","replayMacro","executeMacroRegister","newPosition","getLastEditPos","onKeyEventTargetKeyDown","selectForInsert","toggleVisualMode","reselectLastSelection","_actionArgs","updateLastSelection","anchorMark","headMark","joinLines","finalCh","nextStartCh","curFinalPos","newLineAndEnterInsertMode","newlineFn","newlineAndIndentContinueComment","paste","_this","fallback","continuePaste","then","whitespaceLength","tabs","spaces","currentLine","chompedText","wasChomped","firstIndent","wspace","newIndent","quotient","curPosFinal","idx","lastSelectionCurEnd","selectedArea","getSelectedAreaRange","selectedText","emptyStrings","selectBlock","lastCh","extendLineToColumn","repeatFn","setRegister","setMark","markName","replaceWith","replaceTo","replaceWithStr","incrementNumberToken","lineStr","numberStr","baseStr","digits","base","number","zeroPadding","repeatLastEdit","includeLineBreak","maxCh","direction","ret","prop","offsetLine","offsetCh","commandMatch","pressed","mapped","prefixLen","pressedPrefix","mappedPrefix","cur1","cur2","apply","cur3","cur1before2","cur2before3","trim","isClipped","curHead","getIndex","wasClipped","baseCh","headCh","newDir","lineHead","atAnchor","atHead","getCurrentSelectedAreaRange","getLastSelectedAreaRange","block","headOffset","anchorOffset","fromCh","toCh","getHead","moveHead","firstNonWS","_forward","noSymbol","wordStart","tags","symbolToMode","findSymbolModes","bracket","isComplete","nextCh","symb","depth","reverseSymb","section","init","curMoveThrough","comment","preprocess","curCh","lineLen","findWord","emptyLineIsWord","charTests","stop","foundWord","words","eodCh","shortCircuit","firstWord","lastWord","keepHPos","retval","charIdxInLine","includeChar","lastIndexOf","isBoundary","any","skipFold","foldLine","startState","nextChar","curr","ln","lastSentencePos","curr_index","last_valid","skip_empty_lines","bracketRegexp","openSym","curChar","chars","len","firstIndex","SearchState","setQuery","getOverlay","searchOverlay","setOverlay","overlay","reversed","getScrollbarAnnotate","annotate","setScrollbarAnnotate","searchState_","splitBySlash","argString","splitBySeparator","findUnescapedSlashes","findUnescapedSeparators","separator","slashes","tokens","escapeNextChar","translateRegex","specials","unescape","out","specialComesNext","charUnescapes","translateRegexReplace","unescapes","unescapeRegexReplace","stream","output","matcher","parseQuery","lastSearchRegister","regexPart","forceIgnoreCase","flagsPart","regexp","createTextNode","nodeType","Object","setAttribute","pre","$color","$whiteSpace","openNotification","alert","innerText","makePrompt","createDocumentFragment","$fontFamily","autocorrect","autocapitalize","spellcheck","shortText","textContent","prompt","regexEqual","r1","r2","props","rawQuery","matchSol","searchState","showMatchesOnScrollbar","lastEndPos","isInRange","getFirstFullyVisibleRow","getLastFullyVisibleRow","undoManager","ExCommandDispatcher","buildCommandMap_","opt_params","that","_processCommand","commandHistoryRegister","previousCommand","inputStream","params","parseInput_","commandName","matchCommand_","parseCommandArgs_","toInput","lineEnd","parseLineSpec_","numberMatch","parseLineSpecOffset_","offsetMatch","delim","argDelimiter","user","unshift","colorscheme","mapArgs","imap","nmap","vmap","setArgs","setCfg","expr","forceGet","optionIsBoolean","oldValue","message","setOptionReturn","setlocal","setglobal","regArgs","regInfo","sort","unique","parseArgs","opts","decimal","hex","octal","err","radix","numPart","textPart","matchPart","compareFn","b","anum","bnum","comparePatternFn","textOld","vglobal","inverted","matchedLines","nextCommand","substitute","replacePart","trailing","count","confirm","startPos","doReplace","write","save","nohlsearch","delmarks","sym","startMark","finishMark","finish","searchCursor","exMode","done","lastPos","modifiedLineNumber","joined","replaceAll","newText","unmodifiedLineNumber","findNextValidMatch","lastMatchTo","_value","savedCallback","detach","insertModeChangeRegister","logInsertModeChange","extra","imc","repeatInsertModeChanges","changeObj","ignoreCount","selectionCount","maybeReset","handleExternalSelection","onKeyFound","repeatForInsert","isAction","cachedInputState","repeatCommand","repeatInsert","changeObject","keyHandler","binding","Vim","specialKey","backspace","esc","right","down","home","pageup","pagedown","enter","hashId","ctrlKey","altKey","shiftKey","cloneVimState","constructor","forEach","isHandled","wasInVisualBlock","wasMultiselect","old","forEachSelection","$desiredColumn","getVim","handler","$id","drawCursor","pixelPos","w","isbackwards","isBackwards","translate","setStyle","$getDirectionForHighlight","handleKeyboard","data","inputKey","inputHash","inputChar","isMac","getCopyText","once","passEvent","$vimModeHandler","updateCursor","updateInputMode","isIntsert","setCommandMode","$keepTextAreaAtCursor","$blockCursor","$cursorLayer","getStatusText","all","toggle","round","aceCommand","vimCmd","delayedExecAceCommand"],"sources":["C:/Users/Mukul Pandey/Downloads/Collab-code-editor-main/Collab-code-editor/client/node_modules/ace-builds/src-noconflict/keybinding-vim.js"],"sourcesContent":["ace.define(\"ace/ext/hardwrap\",[\"require\",\"exports\",\"module\",\"ace/range\",\"ace/editor\",\"ace/config\"], function(require, exports, module){\"use strict\";\nvar Range = require(\"../range\").Range;\nfunction hardWrap(editor, options) {\n    var max = options.column || editor.getOption(\"printMarginColumn\");\n    var allowMerge = options.allowMerge != false;\n    var row = Math.min(options.startRow, options.endRow);\n    var endRow = Math.max(options.startRow, options.endRow);\n    var session = editor.session;\n    while (row <= endRow) {\n        var line = session.getLine(row);\n        if (line.length > max) {\n            var space = findSpace(line, max, 5);\n            if (space) {\n                var indentation = /^\\s*/.exec(line)[0];\n                session.replace(new Range(row, space.start, row, space.end), \"\\n\" + indentation);\n            }\n            endRow++;\n        }\n        else if (allowMerge && /\\S/.test(line) && row != endRow) {\n            var nextLine = session.getLine(row + 1);\n            if (nextLine && /\\S/.test(nextLine)) {\n                var trimmedLine = line.replace(/\\s+$/, \"\");\n                var trimmedNextLine = nextLine.replace(/^\\s+/, \"\");\n                var mergedLine = trimmedLine + \" \" + trimmedNextLine;\n                var space = findSpace(mergedLine, max, 5);\n                if (space && space.start > trimmedLine.length || mergedLine.length < max) {\n                    var replaceRange = new Range(row, trimmedLine.length, row + 1, nextLine.length - trimmedNextLine.length);\n                    session.replace(replaceRange, \" \");\n                    row--;\n                    endRow--;\n                }\n                else if (trimmedLine.length < line.length) {\n                    session.remove(new Range(row, trimmedLine.length, row, line.length));\n                }\n            }\n        }\n        row++;\n    }\n    function findSpace(line, max, min) {\n        if (line.length < max)\n            return;\n        var before = line.slice(0, max);\n        var after = line.slice(max);\n        var spaceAfter = /^(?:(\\s+)|(\\S+)(\\s+))/.exec(after);\n        var spaceBefore = /(?:(\\s+)|(\\s+)(\\S+))$/.exec(before);\n        var start = 0;\n        var end = 0;\n        if (spaceBefore && !spaceBefore[2]) {\n            start = max - spaceBefore[1].length;\n            end = max;\n        }\n        if (spaceAfter && !spaceAfter[2]) {\n            if (!start)\n                start = max;\n            end = max + spaceAfter[1].length;\n        }\n        if (start) {\n            return {\n                start: start,\n                end: end\n            };\n        }\n        if (spaceBefore && spaceBefore[2] && spaceBefore.index > min) {\n            return {\n                start: spaceBefore.index,\n                end: spaceBefore.index + spaceBefore[2].length\n            };\n        }\n        if (spaceAfter && spaceAfter[2]) {\n            start = max + spaceAfter[2].length;\n            return {\n                start: start,\n                end: start + spaceAfter[3].length\n            };\n        }\n    }\n}\nfunction wrapAfterInput(e) {\n    if (e.command.name == \"insertstring\" && /\\S/.test(e.args)) {\n        var editor = e.editor;\n        var cursor = editor.selection.cursor;\n        if (cursor.column <= editor.renderer.$printMarginColumn)\n            return;\n        var lastDelta = editor.session.$undoManager.$lastDelta;\n        hardWrap(editor, {\n            startRow: cursor.row, endRow: cursor.row,\n            allowMerge: false\n        });\n        if (lastDelta != editor.session.$undoManager.$lastDelta)\n            editor.session.markUndoGroup();\n    }\n}\nvar Editor = require(\"../editor\").Editor;\nrequire(\"../config\").defineOptions(Editor.prototype, \"editor\", {\n    hardWrap: {\n        set: function (val) {\n            if (val) {\n                this.commands.on(\"afterExec\", wrapAfterInput);\n            }\n            else {\n                this.commands.off(\"afterExec\", wrapAfterInput);\n            }\n        },\n        value: false\n    }\n});\nexports.hardWrap = hardWrap;\n\n});\n\nace.define(\"ace/keyboard/vim\",[\"require\",\"exports\",\"module\",\"ace/range\",\"ace/lib/event_emitter\",\"ace/lib/dom\",\"ace/lib/oop\",\"ace/lib/keys\",\"ace/lib/event\",\"ace/search\",\"ace/lib/useragent\",\"ace/search_highlight\",\"ace/commands/multi_select_commands\",\"ace/mode/text\",\"ace/ext/hardwrap\",\"ace/multi_select\"], function(require, exports, module){// CodeMirror, copyright (c) by Marijn Haverbeke and others\n'use strict';\nfunction log() {\n    var d = \"\";\n    function format(p) {\n        if (typeof p != \"object\")\n            return p + \"\";\n        if (\"line\" in p) {\n            return p.line + \":\" + p.ch;\n        }\n        if (\"anchor\" in p) {\n            return format(p.anchor) + \"->\" + format(p.head);\n        }\n        if (Array.isArray(p))\n            return \"[\" + p.map(function (x) {\n                return format(x);\n            }) + \"]\";\n        return JSON.stringify(p);\n    }\n    for (var i = 0; i < arguments.length; i++) {\n        var p = arguments[i];\n        var f = format(p);\n        d += f + \"  \";\n    }\n    console.log(d);\n}\nvar Range = require(\"../range\").Range;\nvar EventEmitter = require(\"../lib/event_emitter\").EventEmitter;\nvar domLib = require(\"../lib/dom\");\nvar oop = require(\"../lib/oop\");\nvar KEYS = require(\"../lib/keys\");\nvar event = require(\"../lib/event\");\nvar Search = require(\"../search\").Search;\nvar useragent = require(\"../lib/useragent\");\nvar SearchHighlight = require(\"../search_highlight\").SearchHighlight;\nvar multiSelectCommands = require(\"../commands/multi_select_commands\");\nvar TextModeTokenRe = require(\"../mode/text\").Mode.prototype.tokenRe;\nvar hardWrap = require(\"../ext/hardwrap\").hardWrap;\nrequire(\"../multi_select\");\nvar CodeMirror = function (ace) {\n    this.ace = ace;\n    this.state = {};\n    this.marks = {};\n    this.options = {};\n    this.$uid = 0;\n    this.onChange = this.onChange.bind(this);\n    this.onSelectionChange = this.onSelectionChange.bind(this);\n    this.onBeforeEndOperation = this.onBeforeEndOperation.bind(this);\n    this.ace.on('change', this.onChange);\n    this.ace.on('changeSelection', this.onSelectionChange);\n    this.ace.on('beforeEndOperation', this.onBeforeEndOperation);\n};\nCodeMirror.Pos = function (line, ch) {\n    if (!(this instanceof Pos))\n        return new Pos(line, ch);\n    this.line = line;\n    this.ch = ch;\n};\nCodeMirror.defineOption = function (name, val, setter) { };\nCodeMirror.commands = {\n    redo: function (cm) { cm.ace.redo(); },\n    undo: function (cm) { cm.ace.undo(); },\n    newlineAndIndent: function (cm) { cm.ace.insert(\"\\n\"); },\n    goLineLeft: function (cm) { cm.ace.selection.moveCursorLineStart(); },\n    goLineRight: function (cm) { cm.ace.selection.moveCursorLineEnd(); }\n};\nCodeMirror.keyMap = {};\nCodeMirror.addClass = CodeMirror.rmClass = function () { };\nCodeMirror.e_stop = CodeMirror.e_preventDefault = event.stopEvent;\nCodeMirror.keyName = function (e) {\n    var key = (KEYS[e.keyCode] || e.key || \"\");\n    if (key.length == 1)\n        key = key.toUpperCase();\n    key = event.getModifierString(e).replace(/(^|-)\\w/g, function (m) {\n        return m.toUpperCase();\n    }) + key;\n    return key;\n};\nCodeMirror.keyMap['default'] = function (key) {\n    return function (cm) {\n        var cmd = cm.ace.commands.commandKeyBinding[key.toLowerCase()];\n        return cmd && cm.ace.execCommand(cmd) !== false;\n    };\n};\nCodeMirror.lookupKey = function lookupKey(key, map, handle) {\n    if (!map)\n        map = \"default\";\n    if (typeof map == \"string\")\n        map = CodeMirror.keyMap[map];\n    var found = typeof map == \"function\" ? map(key) : map[key];\n    if (found === false)\n        return \"nothing\";\n    if (found === \"...\")\n        return \"multi\";\n    if (found != null && handle(found))\n        return \"handled\";\n    if (map.fallthrough) {\n        if (!Array.isArray(map.fallthrough))\n            return lookupKey(key, map.fallthrough, handle);\n        for (var i = 0; i < map.fallthrough.length; i++) {\n            var result = lookupKey(key, map.fallthrough[i], handle);\n            if (result)\n                return result;\n        }\n    }\n};\nCodeMirror.findMatchingTag = function (cm, head) {\n    return cm.findMatchingTag(head);\n};\nCodeMirror.findEnclosingTag = function (cm, head) {\n};\nCodeMirror.signal = function (o, name, e) { return o._signal(name, e); };\nCodeMirror.on = event.addListener;\nCodeMirror.off = event.removeListener;\nCodeMirror.isWordChar = function (ch) {\n    if (ch < \"\\x7f\")\n        return /^\\w$/.test(ch);\n    TextModeTokenRe.lastIndex = 0;\n    return TextModeTokenRe.test(ch);\n};\n(function () {\n    oop.implement(CodeMirror.prototype, EventEmitter);\n    this.destroy = function () {\n        this.ace.off('change', this.onChange);\n        this.ace.off('changeSelection', this.onSelectionChange);\n        this.ace.off('beforeEndOperation', this.onBeforeEndOperation);\n        this.removeOverlay();\n    };\n    this.virtualSelectionMode = function () {\n        return this.ace.inVirtualSelectionMode && this.ace.selection.index;\n    };\n    this.onChange = function (delta) {\n        var change = { text: delta.action[0] == 'i' ? delta.lines : [] };\n        var curOp = this.curOp = this.curOp || {};\n        if (!curOp.changeHandlers)\n            curOp.changeHandlers = this._eventRegistry[\"change\"] && this._eventRegistry[\"change\"].slice();\n        if (!curOp.lastChange) {\n            curOp.lastChange = curOp.change = change;\n        }\n        else {\n            curOp.lastChange.next = curOp.lastChange = change;\n        }\n        this.$updateMarkers(delta);\n    };\n    this.onSelectionChange = function () {\n        var curOp = this.curOp = this.curOp || {};\n        if (!curOp.cursorActivityHandlers)\n            curOp.cursorActivityHandlers = this._eventRegistry[\"cursorActivity\"] && this._eventRegistry[\"cursorActivity\"].slice();\n        this.curOp.cursorActivity = true;\n        if (this.ace.inMultiSelectMode) {\n            this.ace.keyBinding.removeKeyboardHandler(multiSelectCommands.keyboardHandler);\n        }\n    };\n    this.operation = function (fn, force) {\n        if (!force && this.curOp || force && this.curOp && this.curOp.force) {\n            return fn();\n        }\n        if (force || !this.ace.curOp) {\n            if (this.curOp)\n                this.onBeforeEndOperation();\n        }\n        if (!this.ace.curOp) {\n            var prevOp = this.ace.prevOp;\n            this.ace.startOperation({\n                command: { name: \"vim\", scrollIntoView: \"cursor\" }\n            });\n        }\n        var curOp = this.curOp = this.curOp || {};\n        this.curOp.force = force;\n        var result = fn();\n        if (this.ace.curOp && this.ace.curOp.command.name == \"vim\") {\n            if (this.state.dialog)\n                this.ace.curOp.command.scrollIntoView = this.ace.curOp.vimDialogScroll;\n            this.ace.endOperation();\n            if (!curOp.cursorActivity && !curOp.lastChange && prevOp)\n                this.ace.prevOp = prevOp;\n        }\n        if (force || !this.ace.curOp) {\n            if (this.curOp)\n                this.onBeforeEndOperation();\n        }\n        return result;\n    };\n    this.onBeforeEndOperation = function () {\n        var op = this.curOp;\n        if (op) {\n            if (op.change) {\n                this.signal(\"change\", op.change, op);\n            }\n            if (op && op.cursorActivity) {\n                this.signal(\"cursorActivity\", null, op);\n            }\n            this.curOp = null;\n        }\n    };\n    this.signal = function (eventName, e, handlers) {\n        var listeners = handlers ? handlers[eventName + \"Handlers\"]\n            : (this._eventRegistry || {})[eventName];\n        if (!listeners)\n            return;\n        listeners = listeners.slice();\n        for (var i = 0; i < listeners.length; i++)\n            listeners[i](this, e);\n    };\n    this.firstLine = function () { return 0; };\n    this.lastLine = function () { return this.ace.session.getLength() - 1; };\n    this.lineCount = function () { return this.ace.session.getLength(); };\n    this.setCursor = function (line, ch) {\n        if (typeof line === 'object') {\n            ch = line.ch;\n            line = line.line;\n        }\n        var shouldScroll = !this.curOp && !this.ace.inVirtualSelectionMode;\n        if (!this.ace.inVirtualSelectionMode)\n            this.ace.exitMultiSelectMode();\n        this.ace.session.unfold({ row: line, column: ch });\n        this.ace.selection.moveTo(line, ch);\n        if (shouldScroll) {\n            this.ace.renderer.scrollCursorIntoView();\n            this.ace.endOperation();\n        }\n    };\n    this.getCursor = function (p) {\n        var sel = this.ace.selection;\n        var pos = p == 'anchor' ? (sel.isEmpty() ? sel.lead : sel.anchor) :\n            p == 'head' || !p ? sel.lead : sel.getRange()[p];\n        return toCmPos(pos);\n    };\n    this.listSelections = function (p) {\n        var ranges = this.ace.multiSelect.rangeList.ranges;\n        if (!ranges.length || this.ace.inVirtualSelectionMode)\n            return [{ anchor: this.getCursor('anchor'), head: this.getCursor('head') }];\n        return ranges.map(function (r) {\n            return {\n                anchor: this.clipPos(toCmPos(r.cursor == r.end ? r.start : r.end)),\n                head: this.clipPos(toCmPos(r.cursor))\n            };\n        }, this);\n    };\n    this.setSelections = function (p, primIndex) {\n        var sel = this.ace.multiSelect;\n        var ranges = p.map(function (x) {\n            var anchor = toAcePos(x.anchor);\n            var head = toAcePos(x.head);\n            var r = Range.comparePoints(anchor, head) < 0\n                ? new Range.fromPoints(anchor, head)\n                : new Range.fromPoints(head, anchor);\n            r.cursor = Range.comparePoints(r.start, head) ? r.end : r.start;\n            return r;\n        });\n        if (this.ace.inVirtualSelectionMode) {\n            this.ace.selection.fromOrientedRange(ranges[0]);\n            return;\n        }\n        if (!primIndex) {\n            ranges = ranges.reverse();\n        }\n        else if (ranges[primIndex]) {\n            ranges.push(ranges.splice(primIndex, 1)[0]);\n        }\n        sel.toSingleRange(ranges[0].clone());\n        var session = this.ace.session;\n        for (var i = 0; i < ranges.length; i++) {\n            var range = session.$clipRangeToDocument(ranges[i]); // todo why ace doesn't do this?\n            sel.addRange(range);\n        }\n    };\n    this.setSelection = function (a, h, options) {\n        var sel = this.ace.selection;\n        sel.moveTo(a.line, a.ch);\n        sel.selectTo(h.line, h.ch);\n        if (options && options.origin == '*mouse') {\n            this.onBeforeEndOperation();\n        }\n    };\n    this.somethingSelected = function (p) {\n        return !this.ace.selection.isEmpty();\n    };\n    this.clipPos = function (p) {\n        var pos = this.ace.session.$clipPositionToDocument(p.line, p.ch);\n        return toCmPos(pos);\n    };\n    this.foldCode = function (pos) {\n        this.ace.session.$toggleFoldWidget(pos.line, {});\n    };\n    this.markText = function (cursor) {\n        return { clear: function () { }, find: function () { } };\n    };\n    this.$updateMarkers = function (delta) {\n        var isInsert = delta.action == \"insert\";\n        var start = delta.start;\n        var end = delta.end;\n        var rowShift = (end.row - start.row) * (isInsert ? 1 : -1);\n        var colShift = (end.column - start.column) * (isInsert ? 1 : -1);\n        if (isInsert)\n            end = start;\n        for (var i in this.marks) {\n            var point = this.marks[i];\n            var cmp = Range.comparePoints(point, start);\n            if (cmp < 0) {\n                continue; // delta starts after the range\n            }\n            if (cmp === 0) {\n                if (isInsert) {\n                    if (point.bias == 1) {\n                        cmp = 1;\n                    }\n                    else {\n                        point.bias = -1;\n                        continue;\n                    }\n                }\n            }\n            var cmp2 = isInsert ? cmp : Range.comparePoints(point, end);\n            if (cmp2 > 0) {\n                point.row += rowShift;\n                point.column += point.row == end.row ? colShift : 0;\n                continue;\n            }\n            if (!isInsert && cmp2 <= 0) {\n                point.row = start.row;\n                point.column = start.column;\n                if (cmp2 === 0)\n                    point.bias = 1;\n            }\n        }\n    };\n    var Marker = function (cm, id, row, column) {\n        this.cm = cm;\n        this.id = id;\n        this.row = row;\n        this.column = column;\n        cm.marks[this.id] = this;\n    };\n    Marker.prototype.clear = function () { delete this.cm.marks[this.id]; };\n    Marker.prototype.find = function () { return toCmPos(this); };\n    this.setBookmark = function (cursor, options) {\n        var bm = new Marker(this, this.$uid++, cursor.line, cursor.ch);\n        if (!options || !options.insertLeft)\n            bm.$insertRight = true;\n        this.marks[bm.id] = bm;\n        return bm;\n    };\n    this.moveH = function (increment, unit) {\n        if (unit == 'char') {\n            var sel = this.ace.selection;\n            sel.clearSelection();\n            sel.moveCursorBy(0, increment);\n        }\n    };\n    this.findPosV = function (start, amount, unit, goalColumn) {\n        if (unit == 'page') {\n            var renderer = this.ace.renderer;\n            var config = renderer.layerConfig;\n            amount = amount * Math.floor(config.height / config.lineHeight);\n            unit = 'line';\n        }\n        if (unit == 'line') {\n            var screenPos = this.ace.session.documentToScreenPosition(start.line, start.ch);\n            if (goalColumn != null)\n                screenPos.column = goalColumn;\n            screenPos.row += amount;\n            screenPos.row = Math.min(Math.max(0, screenPos.row), this.ace.session.getScreenLength() - 1);\n            var pos = this.ace.session.screenToDocumentPosition(screenPos.row, screenPos.column);\n            return toCmPos(pos);\n        }\n        else {\n            debugger;\n        }\n    };\n    this.charCoords = function (pos, mode) {\n        if (mode == 'div' || !mode) {\n            var sc = this.ace.session.documentToScreenPosition(pos.line, pos.ch);\n            return { left: sc.column, top: sc.row };\n        }\n        if (mode == 'local') {\n            var renderer = this.ace.renderer;\n            var sc = this.ace.session.documentToScreenPosition(pos.line, pos.ch);\n            var lh = renderer.layerConfig.lineHeight;\n            var cw = renderer.layerConfig.characterWidth;\n            var top = lh * sc.row;\n            return { left: sc.column * cw, top: top, bottom: top + lh };\n        }\n    };\n    this.coordsChar = function (pos, mode) {\n        var renderer = this.ace.renderer;\n        if (mode == 'local') {\n            var row = Math.max(0, Math.floor(pos.top / renderer.lineHeight));\n            var col = Math.max(0, Math.floor(pos.left / renderer.characterWidth));\n            var ch = renderer.session.screenToDocumentPosition(row, col);\n            return toCmPos(ch);\n        }\n        else if (mode == 'div') {\n            throw \"not implemented\";\n        }\n    };\n    this.getSearchCursor = function (query, pos, caseFold) {\n        var caseSensitive = false;\n        var isRegexp = false;\n        if (query instanceof RegExp && !query.global) {\n            caseSensitive = !query.ignoreCase;\n            query = query.source;\n            isRegexp = true;\n        }\n        if (query == \"\\\\n\") {\n            query = \"\\n\";\n            isRegexp = false;\n        }\n        var search = new Search();\n        if (pos.ch == undefined)\n            pos.ch = Number.MAX_VALUE;\n        var acePos = { row: pos.line, column: pos.ch };\n        var cm = this;\n        var last = null;\n        return {\n            findNext: function () { return this.find(false); },\n            findPrevious: function () { return this.find(true); },\n            find: function (back) {\n                search.setOptions({\n                    needle: query,\n                    caseSensitive: caseSensitive,\n                    wrap: false,\n                    backwards: back,\n                    regExp: isRegexp,\n                    start: last || acePos\n                });\n                var range = search.find(cm.ace.session);\n                last = range;\n                return last && [!last.isEmpty()];\n            },\n            from: function () { return last && toCmPos(last.start); },\n            to: function () { return last && toCmPos(last.end); },\n            replace: function (text) {\n                if (last) {\n                    last.end = cm.ace.session.doc.replace(last, text);\n                }\n            }\n        };\n    };\n    this.scrollTo = function (x, y) {\n        var renderer = this.ace.renderer;\n        var config = renderer.layerConfig;\n        var maxHeight = config.maxHeight;\n        maxHeight -= (renderer.$size.scrollerHeight - renderer.lineHeight) * renderer.$scrollPastEnd;\n        if (y != null)\n            this.ace.session.setScrollTop(Math.max(0, Math.min(y, maxHeight)));\n        if (x != null)\n            this.ace.session.setScrollLeft(Math.max(0, Math.min(x, config.width)));\n    };\n    this.scrollInfo = function () { return 0; };\n    this.scrollIntoView = function (pos, margin) {\n        if (pos) {\n            var renderer = this.ace.renderer;\n            var viewMargin = { \"top\": 0, \"bottom\": margin };\n            renderer.scrollCursorIntoView(toAcePos(pos), (renderer.lineHeight * 2) / renderer.$size.scrollerHeight, viewMargin);\n        }\n    };\n    this.getLine = function (row) { return this.ace.session.getLine(row); };\n    this.getRange = function (s, e) {\n        return this.ace.session.getTextRange(new Range(s.line, s.ch, e.line, e.ch));\n    };\n    this.replaceRange = function (text, s, e) {\n        if (!e)\n            e = s;\n        var range = new Range(s.line, s.ch, e.line, e.ch);\n        this.ace.session.$clipRangeToDocument(range);\n        return this.ace.session.replace(range, text);\n    };\n    this.replaceSelection =\n        this.replaceSelections = function (p) {\n            var sel = this.ace.selection;\n            if (this.ace.inVirtualSelectionMode) {\n                this.ace.session.replace(sel.getRange(), p[0] || \"\");\n                return;\n            }\n            sel.inVirtualSelectionMode = true;\n            var ranges = sel.rangeList.ranges;\n            if (!ranges.length)\n                ranges = [this.ace.multiSelect.getRange()];\n            for (var i = ranges.length; i--;)\n                this.ace.session.replace(ranges[i], p[i] || \"\");\n            sel.inVirtualSelectionMode = false;\n        };\n    this.getSelection = function () {\n        return this.ace.getSelectedText();\n    };\n    this.getSelections = function () {\n        return this.listSelections().map(function (x) {\n            return this.getRange(x.anchor, x.head);\n        }, this);\n    };\n    this.getInputField = function () {\n        return this.ace.textInput.getElement();\n    };\n    this.getWrapperElement = function () {\n        return this.ace.container;\n    };\n    var optMap = {\n        indentWithTabs: \"useSoftTabs\",\n        indentUnit: \"tabSize\",\n        tabSize: \"tabSize\",\n        firstLineNumber: \"firstLineNumber\",\n        readOnly: \"readOnly\"\n    };\n    this.setOption = function (name, val) {\n        this.state[name] = val;\n        switch (name) {\n            case 'indentWithTabs':\n                name = optMap[name];\n                val = !val;\n                break;\n            case 'keyMap':\n                this.state.$keyMap = val;\n                return;\n                break;\n            default:\n                name = optMap[name];\n        }\n        if (name)\n            this.ace.setOption(name, val);\n    };\n    this.getOption = function (name) {\n        var val;\n        var aceOpt = optMap[name];\n        if (aceOpt)\n            val = this.ace.getOption(aceOpt);\n        switch (name) {\n            case 'indentWithTabs':\n                name = optMap[name];\n                return !val;\n            case 'keyMap':\n                return this.state.$keyMap || 'vim';\n        }\n        return aceOpt ? val : this.state[name];\n    };\n    this.toggleOverwrite = function (on) {\n        this.state.overwrite = on;\n        return this.ace.setOverwrite(on);\n    };\n    this.addOverlay = function (o) {\n        if (!this.$searchHighlight || !this.$searchHighlight.session) {\n            var highlight = new SearchHighlight(null, \"ace_highlight-marker\", \"text\");\n            var marker = this.ace.session.addDynamicMarker(highlight);\n            highlight.id = marker.id;\n            highlight.session = this.ace.session;\n            highlight.destroy = function (o) {\n                highlight.session.off(\"change\", highlight.updateOnChange);\n                highlight.session.off(\"changeEditor\", highlight.destroy);\n                highlight.session.removeMarker(highlight.id);\n                highlight.session = null;\n            };\n            highlight.updateOnChange = function (delta) {\n                var row = delta.start.row;\n                if (row == delta.end.row)\n                    highlight.cache[row] = undefined;\n                else\n                    highlight.cache.splice(row, highlight.cache.length);\n            };\n            highlight.session.on(\"changeEditor\", highlight.destroy);\n            highlight.session.on(\"change\", highlight.updateOnChange);\n        }\n        var re = new RegExp(o.query.source, \"gmi\");\n        this.$searchHighlight = o.highlight = highlight;\n        this.$searchHighlight.setRegexp(re);\n        this.ace.renderer.updateBackMarkers();\n    };\n    this.removeOverlay = function (o) {\n        if (this.$searchHighlight && this.$searchHighlight.session) {\n            this.$searchHighlight.destroy();\n        }\n    };\n    this.getScrollInfo = function () {\n        var renderer = this.ace.renderer;\n        var config = renderer.layerConfig;\n        return {\n            left: renderer.scrollLeft,\n            top: renderer.scrollTop,\n            height: config.maxHeight,\n            width: config.width,\n            clientHeight: config.height,\n            clientWidth: config.width\n        };\n    };\n    this.getValue = function () {\n        return this.ace.getValue();\n    };\n    this.setValue = function (v) {\n        return this.ace.setValue(v, -1);\n    };\n    this.getTokenTypeAt = function (pos) {\n        var token = this.ace.session.getTokenAt(pos.line, pos.ch);\n        return token && /comment|string/.test(token.type) ? \"string\" : \"\";\n    };\n    this.findMatchingBracket = function (pos) {\n        var m = this.ace.session.findMatchingBracket(toAcePos(pos));\n        return { to: m && toCmPos(m) };\n    };\n    this.findMatchingTag = function (pos) {\n        var m = this.ace.session.getMatchingTags(toAcePos(pos));\n        if (!m)\n            return;\n        return {\n            open: {\n                from: toCmPos(m.openTag.start),\n                to: toCmPos(m.openTag.end)\n            },\n            close: {\n                from: toCmPos(m.closeTag.start),\n                to: toCmPos(m.closeTag.end)\n            }\n        };\n    };\n    this.indentLine = function (line, method) {\n        if (method === true)\n            this.ace.session.indentRows(line, line, \"\\t\");\n        else if (method === false)\n            this.ace.session.outdentRows(new Range(line, 0, line, 0));\n    };\n    this.indexFromPos = function (pos) {\n        return this.ace.session.doc.positionToIndex(toAcePos(pos));\n    };\n    this.posFromIndex = function (index) {\n        return toCmPos(this.ace.session.doc.indexToPosition(index));\n    };\n    this.focus = function (index) {\n        return this.ace.textInput.focus();\n    };\n    this.blur = function (index) {\n        return this.ace.blur();\n    };\n    this.defaultTextHeight = function (index) {\n        return this.ace.renderer.layerConfig.lineHeight;\n    };\n    this.scanForBracket = function (pos, dir, _, options) {\n        var re = options.bracketRegex.source;\n        var tokenRe = /paren|text|operator|tag/;\n        if (dir == 1) {\n            var m = this.ace.session.$findClosingBracket(re.slice(1, 2), toAcePos(pos), tokenRe);\n        }\n        else {\n            var m = this.ace.session.$findOpeningBracket(re.slice(-2, -1), { row: pos.line, column: pos.ch + 1 }, tokenRe);\n        }\n        return m && { pos: toCmPos(m) };\n    };\n    this.refresh = function () {\n        return this.ace.resize(true);\n    };\n    this.getMode = function () {\n        return { name: this.getOption(\"mode\") };\n    };\n    this.execCommand = function (name) {\n        if (CodeMirror.commands.hasOwnProperty(name))\n            return CodeMirror.commands[name](this);\n        if (name == \"indentAuto\")\n            return this.ace.execCommand(\"autoindent\");\n        console.log(name + \" is not implemented\");\n    };\n    this.getLineNumber = function (handle) {\n        return handle.row;\n    };\n    this.getLineHandle = function (row) {\n        return { text: this.ace.session.getLine(row), row: row };\n    };\n}).call(CodeMirror.prototype);\nfunction toAcePos(cmPos) {\n    return { row: cmPos.line, column: cmPos.ch };\n}\nfunction toCmPos(acePos) {\n    return new Pos(acePos.row, acePos.column);\n}\nvar StringStream = CodeMirror.StringStream = function (string, tabSize) {\n    this.pos = this.start = 0;\n    this.string = string;\n    this.tabSize = tabSize || 8;\n    this.lastColumnPos = this.lastColumnValue = 0;\n    this.lineStart = 0;\n};\nStringStream.prototype = {\n    eol: function () { return this.pos >= this.string.length; },\n    sol: function () { return this.pos == this.lineStart; },\n    peek: function () { return this.string.charAt(this.pos) || undefined; },\n    next: function () {\n        if (this.pos < this.string.length)\n            return this.string.charAt(this.pos++);\n    },\n    eat: function (match) {\n        var ch = this.string.charAt(this.pos);\n        if (typeof match == \"string\")\n            var ok = ch == match;\n        else\n            var ok = ch && (match.test ? match.test(ch) : match(ch));\n        if (ok) {\n            ++this.pos;\n            return ch;\n        }\n    },\n    eatWhile: function (match) {\n        var start = this.pos;\n        while (this.eat(match)) { }\n        return this.pos > start;\n    },\n    eatSpace: function () {\n        var start = this.pos;\n        while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos)))\n            ++this.pos;\n        return this.pos > start;\n    },\n    skipToEnd: function () { this.pos = this.string.length; },\n    skipTo: function (ch) {\n        var found = this.string.indexOf(ch, this.pos);\n        if (found > -1) {\n            this.pos = found;\n            return true;\n        }\n    },\n    backUp: function (n) { this.pos -= n; },\n    column: function () {\n        throw \"not implemented\";\n    },\n    indentation: function () {\n        throw \"not implemented\";\n    },\n    match: function (pattern, consume, caseInsensitive) {\n        if (typeof pattern == \"string\") {\n            var cased = function (str) { return caseInsensitive ? str.toLowerCase() : str; };\n            var substr = this.string.substr(this.pos, pattern.length);\n            if (cased(substr) == cased(pattern)) {\n                if (consume !== false)\n                    this.pos += pattern.length;\n                return true;\n            }\n        }\n        else {\n            var match = this.string.slice(this.pos).match(pattern);\n            if (match && match.index > 0)\n                return null;\n            if (match && consume !== false)\n                this.pos += match[0].length;\n            return match;\n        }\n    },\n    current: function () { return this.string.slice(this.start, this.pos); },\n    hideFirstChars: function (n, inner) {\n        this.lineStart += n;\n        try {\n            return inner();\n        }\n        finally {\n            this.lineStart -= n;\n        }\n    }\n};\nCodeMirror.defineExtension = function (name, fn) {\n    CodeMirror.prototype[name] = fn;\n};\ndomLib.importCssString(\".normal-mode .ace_cursor{\\n    border: none;\\n    background-color: rgba(255,0,0,0.5);\\n}\\n.normal-mode .ace_hidden-cursors .ace_cursor{\\n  background-color: transparent;\\n  border: 1px solid red;\\n  opacity: 0.7\\n}\\n.ace_dialog {\\n  position: absolute;\\n  left: 0; right: 0;\\n  background: inherit;\\n  z-index: 15;\\n  padding: .1em .8em;\\n  overflow: hidden;\\n  color: inherit;\\n}\\n.ace_dialog-top {\\n  border-bottom: 1px solid #444;\\n  top: 0;\\n}\\n.ace_dialog-bottom {\\n  border-top: 1px solid #444;\\n  bottom: 0;\\n}\\n.ace_dialog input {\\n  border: none;\\n  outline: none;\\n  background: transparent;\\n  width: 20em;\\n  color: inherit;\\n  font-family: monospace;\\n}\", \"vimMode\", false);\n(function () {\n    function dialogDiv(cm, template, bottom) {\n        var wrap = cm.ace.container;\n        var dialog;\n        dialog = wrap.appendChild(document.createElement(\"div\"));\n        if (bottom)\n            dialog.className = \"ace_dialog ace_dialog-bottom\";\n        else\n            dialog.className = \"ace_dialog ace_dialog-top\";\n        if (typeof template == \"string\") {\n            dialog.innerHTML = template;\n        }\n        else { // Assuming it's a detached DOM element.\n            dialog.appendChild(template);\n        }\n        return dialog;\n    }\n    function closeNotification(cm, newVal) {\n        if (cm.state.currentNotificationClose)\n            cm.state.currentNotificationClose();\n        cm.state.currentNotificationClose = newVal;\n    }\n    CodeMirror.defineExtension(\"openDialog\", function (template, callback, options) {\n        if (this.virtualSelectionMode())\n            return;\n        if (!options)\n            options = {};\n        closeNotification(this, null);\n        var dialog = dialogDiv(this, template, options.bottom);\n        var closed = false, me = this;\n        this.state.dialog = dialog;\n        function close(newVal) {\n            if (typeof newVal == 'string') {\n                inp.value = newVal;\n            }\n            else {\n                if (closed)\n                    return;\n                if (newVal && newVal.type == \"blur\") {\n                    if (document.activeElement === inp)\n                        return;\n                }\n                if (me.state.dialog == dialog) {\n                    me.state.dialog = null;\n                    me.focus();\n                }\n                closed = true;\n                dialog.remove();\n                if (options.onClose)\n                    options.onClose(dialog);\n                var cm = me;\n                if (cm.state.vim) {\n                    cm.state.vim.status = null;\n                    cm.ace._signal(\"changeStatus\");\n                    cm.ace.renderer.$loop.schedule(cm.ace.renderer.CHANGE_CURSOR);\n                }\n            }\n        }\n        var inp = dialog.getElementsByTagName(\"input\")[0], button;\n        if (inp) {\n            if (options.value) {\n                inp.value = options.value;\n                if (options.selectValueOnOpen !== false)\n                    inp.select();\n            }\n            if (options.onInput)\n                CodeMirror.on(inp, \"input\", function (e) { options.onInput(e, inp.value, close); });\n            if (options.onKeyUp)\n                CodeMirror.on(inp, \"keyup\", function (e) { options.onKeyUp(e, inp.value, close); });\n            CodeMirror.on(inp, \"keydown\", function (e) {\n                if (options && options.onKeyDown && options.onKeyDown(e, inp.value, close)) {\n                    return;\n                }\n                if (e.keyCode == 13)\n                    callback(inp.value);\n                if (e.keyCode == 27 || (options.closeOnEnter !== false && e.keyCode == 13)) {\n                    CodeMirror.e_stop(e);\n                    close();\n                }\n            });\n            if (options.closeOnBlur !== false)\n                CodeMirror.on(inp, \"blur\", close);\n            inp.focus();\n        }\n        else if (button = dialog.getElementsByTagName(\"button\")[0]) {\n            CodeMirror.on(button, \"click\", function () {\n                close();\n                me.focus();\n            });\n            if (options.closeOnBlur !== false)\n                CodeMirror.on(button, \"blur\", close);\n            button.focus();\n        }\n        return close;\n    });\n    CodeMirror.defineExtension(\"openNotification\", function (template, options) {\n        if (this.virtualSelectionMode())\n            return;\n        closeNotification(this, close);\n        var dialog = dialogDiv(this, template, options && options.bottom);\n        var closed = false, doneTimer;\n        var duration = options && typeof options.duration !== \"undefined\" ? options.duration : 5000;\n        function close() {\n            if (closed)\n                return;\n            closed = true;\n            clearTimeout(doneTimer);\n            dialog.remove();\n        }\n        CodeMirror.on(dialog, 'click', function (e) {\n            CodeMirror.e_preventDefault(e);\n            close();\n        });\n        if (duration)\n            doneTimer = setTimeout(close, duration);\n        return close;\n    });\n})();\nvar Pos = CodeMirror.Pos;\nfunction transformCursor(cm, range) {\n    var vim = cm.state.vim;\n    if (!vim || vim.insertMode)\n        return range.head;\n    var head = vim.sel.head;\n    if (!head)\n        return range.head;\n    if (vim.visualBlock) {\n        if (range.head.line != head.line) {\n            return;\n        }\n    }\n    if (range.from() == range.anchor && !range.empty()) {\n        if (range.head.line == head.line && range.head.ch != head.ch)\n            return new Pos(range.head.line, range.head.ch - 1);\n    }\n    return range.head;\n}\nfunction updateSelectionForSurrogateCharacters(cm, curStart, curEnd) {\n    if (curStart.line === curEnd.line && curStart.ch >= curEnd.ch - 1) {\n        var text = cm.getLine(curStart.line);\n        var charCode = text.charCodeAt(curStart.ch);\n        if (0xD800 <= charCode && charCode <= 0xD8FF) {\n            curEnd.ch += 1;\n        }\n    }\n    return { start: curStart, end: curEnd };\n}\nvar defaultKeymap = [\n    { keys: '<Left>', type: 'keyToKey', toKeys: 'h' },\n    { keys: '<Right>', type: 'keyToKey', toKeys: 'l' },\n    { keys: '<Up>', type: 'keyToKey', toKeys: 'k' },\n    { keys: '<Down>', type: 'keyToKey', toKeys: 'j' },\n    { keys: 'g<Up>', type: 'keyToKey', toKeys: 'gk' },\n    { keys: 'g<Down>', type: 'keyToKey', toKeys: 'gj' },\n    { keys: '<Space>', type: 'keyToKey', toKeys: 'l' },\n    { keys: '<BS>', type: 'keyToKey', toKeys: 'h', context: 'normal' },\n    { keys: '<Del>', type: 'keyToKey', toKeys: 'x', context: 'normal' },\n    { keys: '<C-Space>', type: 'keyToKey', toKeys: 'W' },\n    { keys: '<C-BS>', type: 'keyToKey', toKeys: 'B', context: 'normal' },\n    { keys: '<S-Space>', type: 'keyToKey', toKeys: 'w' },\n    { keys: '<S-BS>', type: 'keyToKey', toKeys: 'b', context: 'normal' },\n    { keys: '<C-n>', type: 'keyToKey', toKeys: 'j' },\n    { keys: '<C-p>', type: 'keyToKey', toKeys: 'k' },\n    { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>' },\n    { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>' },\n    { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: '<C-Esc>', type: 'keyToKey', toKeys: '<Esc>' },\n    { keys: '<C-Esc>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: 's', type: 'keyToKey', toKeys: 'cl', context: 'normal' },\n    { keys: 's', type: 'keyToKey', toKeys: 'c', context: 'visual' },\n    { keys: 'S', type: 'keyToKey', toKeys: 'cc', context: 'normal' },\n    { keys: 'S', type: 'keyToKey', toKeys: 'VdO', context: 'visual' },\n    { keys: '<Home>', type: 'keyToKey', toKeys: '0' },\n    { keys: '<End>', type: 'keyToKey', toKeys: '$' },\n    { keys: '<PageUp>', type: 'keyToKey', toKeys: '<C-b>' },\n    { keys: '<PageDown>', type: 'keyToKey', toKeys: '<C-f>' },\n    { keys: '<CR>', type: 'keyToKey', toKeys: 'j^', context: 'normal' },\n    { keys: '<Ins>', type: 'keyToKey', toKeys: 'i', context: 'normal' },\n    { keys: '<Ins>', type: 'action', action: 'toggleOverwrite', context: 'insert' },\n    { keys: 'H', type: 'motion', motion: 'moveToTopLine', motionArgs: { linewise: true, toJumplist: true } },\n    { keys: 'M', type: 'motion', motion: 'moveToMiddleLine', motionArgs: { linewise: true, toJumplist: true } },\n    { keys: 'L', type: 'motion', motion: 'moveToBottomLine', motionArgs: { linewise: true, toJumplist: true } },\n    { keys: 'h', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: false } },\n    { keys: 'l', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: true } },\n    { keys: 'j', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, linewise: true } },\n    { keys: 'k', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, linewise: true } },\n    { keys: 'gj', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: true } },\n    { keys: 'gk', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: false } },\n    { keys: 'w', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false } },\n    { keys: 'W', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false, bigWord: true } },\n    { keys: 'e', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, inclusive: true } },\n    { keys: 'E', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, bigWord: true, inclusive: true } },\n    { keys: 'b', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false } },\n    { keys: 'B', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false, bigWord: true } },\n    { keys: 'ge', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, inclusive: true } },\n    { keys: 'gE', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, bigWord: true, inclusive: true } },\n    { keys: '{', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: false, toJumplist: true } },\n    { keys: '}', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: true, toJumplist: true } },\n    { keys: '(', type: 'motion', motion: 'moveBySentence', motionArgs: { forward: false } },\n    { keys: ')', type: 'motion', motion: 'moveBySentence', motionArgs: { forward: true } },\n    { keys: '<C-f>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: true } },\n    { keys: '<C-b>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: false } },\n    { keys: '<C-d>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: true, explicitRepeat: true } },\n    { keys: '<C-u>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: false, explicitRepeat: true } },\n    { keys: 'gg', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: false, explicitRepeat: true, linewise: true, toJumplist: true } },\n    { keys: 'G', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: true, explicitRepeat: true, linewise: true, toJumplist: true } },\n    { keys: \"g$\", type: \"motion\", motion: \"moveToEndOfDisplayLine\" },\n    { keys: \"g^\", type: \"motion\", motion: \"moveToStartOfDisplayLine\" },\n    { keys: \"g0\", type: \"motion\", motion: \"moveToStartOfDisplayLine\" },\n    { keys: '0', type: 'motion', motion: 'moveToStartOfLine' },\n    { keys: '^', type: 'motion', motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: '+', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar: true } },\n    { keys: '-', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, toFirstChar: true } },\n    { keys: '_', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar: true, repeatOffset: -1 } },\n    { keys: '$', type: 'motion', motion: 'moveToEol', motionArgs: { inclusive: true } },\n    { keys: '%', type: 'motion', motion: 'moveToMatchedSymbol', motionArgs: { inclusive: true, toJumplist: true } },\n    { keys: 'f<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: true, inclusive: true } },\n    { keys: 'F<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: false } },\n    { keys: 't<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: true, inclusive: true } },\n    { keys: 'T<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: false } },\n    { keys: ';', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: true } },\n    { keys: ',', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: false } },\n    { keys: '\\'<character>', type: 'motion', motion: 'goToMark', motionArgs: { toJumplist: true, linewise: true } },\n    { keys: '`<character>', type: 'motion', motion: 'goToMark', motionArgs: { toJumplist: true } },\n    { keys: ']`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true } },\n    { keys: '[`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false } },\n    { keys: ']\\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true, linewise: true } },\n    { keys: '[\\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false, linewise: true } },\n    { keys: ']p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true, matchIndent: true } },\n    { keys: '[p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true, matchIndent: true } },\n    { keys: ']<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: true, toJumplist: true } },\n    { keys: '[<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: false, toJumplist: true } },\n    { keys: '|', type: 'motion', motion: 'moveToColumn' },\n    { keys: 'o', type: 'motion', motion: 'moveToOtherHighlightedEnd', context: 'visual' },\n    { keys: 'O', type: 'motion', motion: 'moveToOtherHighlightedEnd', motionArgs: { sameLine: true }, context: 'visual' },\n    { keys: 'd', type: 'operator', operator: 'delete' },\n    { keys: 'y', type: 'operator', operator: 'yank' },\n    { keys: 'c', type: 'operator', operator: 'change' },\n    { keys: '=', type: 'operator', operator: 'indentAuto' },\n    { keys: '>', type: 'operator', operator: 'indent', operatorArgs: { indentRight: true } },\n    { keys: '<', type: 'operator', operator: 'indent', operatorArgs: { indentRight: false } },\n    { keys: 'g~', type: 'operator', operator: 'changeCase' },\n    { keys: 'gu', type: 'operator', operator: 'changeCase', operatorArgs: { toLower: true }, isEdit: true },\n    { keys: 'gU', type: 'operator', operator: 'changeCase', operatorArgs: { toLower: false }, isEdit: true },\n    { keys: 'n', type: 'motion', motion: 'findNext', motionArgs: { forward: true, toJumplist: true } },\n    { keys: 'N', type: 'motion', motion: 'findNext', motionArgs: { forward: false, toJumplist: true } },\n    { keys: 'gn', type: 'motion', motion: 'findAndSelectNextInclusive', motionArgs: { forward: true } },\n    { keys: 'gN', type: 'motion', motion: 'findAndSelectNextInclusive', motionArgs: { forward: false } },\n    { keys: 'x', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorMotionArgs: { visualLine: false } },\n    { keys: 'X', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: false }, operatorMotionArgs: { visualLine: true } },\n    { keys: 'D', type: 'operatorMotion', operator: 'delete', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal' },\n    { keys: 'D', type: 'operator', operator: 'delete', operatorArgs: { linewise: true }, context: 'visual' },\n    { keys: 'Y', type: 'operatorMotion', operator: 'yank', motion: 'expandToLine', motionArgs: { linewise: true }, context: 'normal' },\n    { keys: 'Y', type: 'operator', operator: 'yank', operatorArgs: { linewise: true }, context: 'visual' },\n    { keys: 'C', type: 'operatorMotion', operator: 'change', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal' },\n    { keys: 'C', type: 'operator', operator: 'change', operatorArgs: { linewise: true }, context: 'visual' },\n    { keys: '~', type: 'operatorMotion', operator: 'changeCase', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorArgs: { shouldMoveCursor: true }, context: 'normal' },\n    { keys: '~', type: 'operator', operator: 'changeCase', context: 'visual' },\n    { keys: '<C-u>', type: 'operatorMotion', operator: 'delete', motion: 'moveToStartOfLine', context: 'insert' },\n    { keys: '<C-w>', type: 'operatorMotion', operator: 'delete', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false }, context: 'insert' },\n    { keys: '<C-w>', type: 'idle', context: 'normal' },\n    { keys: '<C-i>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: true } },\n    { keys: '<C-o>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: false } },\n    { keys: '<C-e>', type: 'action', action: 'scroll', actionArgs: { forward: true, linewise: true } },\n    { keys: '<C-y>', type: 'action', action: 'scroll', actionArgs: { forward: false, linewise: true } },\n    { keys: 'a', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'charAfter' }, context: 'normal' },\n    { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'eol' }, context: 'normal' },\n    { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'endOfSelectedArea' }, context: 'visual' },\n    { keys: 'i', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'inplace' }, context: 'normal' },\n    { keys: 'gi', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'lastEdit' }, context: 'normal' },\n    { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'firstNonBlank' }, context: 'normal' },\n    { keys: 'gI', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'bol' }, context: 'normal' },\n    { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'startOfSelectedArea' }, context: 'visual' },\n    { keys: 'o', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: true }, context: 'normal' },\n    { keys: 'O', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: false }, context: 'normal' },\n    { keys: 'v', type: 'action', action: 'toggleVisualMode' },\n    { keys: 'V', type: 'action', action: 'toggleVisualMode', actionArgs: { linewise: true } },\n    { keys: '<C-v>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true } },\n    { keys: '<C-q>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true } },\n    { keys: 'gv', type: 'action', action: 'reselectLastSelection' },\n    { keys: 'J', type: 'action', action: 'joinLines', isEdit: true },\n    { keys: 'gJ', type: 'action', action: 'joinLines', actionArgs: { keepSpaces: true }, isEdit: true },\n    { keys: 'p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true } },\n    { keys: 'P', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true } },\n    { keys: 'r<character>', type: 'action', action: 'replace', isEdit: true },\n    { keys: '@<character>', type: 'action', action: 'replayMacro' },\n    { keys: 'q<character>', type: 'action', action: 'enterMacroRecordMode' },\n    { keys: 'R', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { replace: true }, context: 'normal' },\n    { keys: 'R', type: 'operator', operator: 'change', operatorArgs: { linewise: true, fullLine: true }, context: 'visual', exitVisualBlock: true },\n    { keys: 'u', type: 'action', action: 'undo', context: 'normal' },\n    { keys: 'u', type: 'operator', operator: 'changeCase', operatorArgs: { toLower: true }, context: 'visual', isEdit: true },\n    { keys: 'U', type: 'operator', operator: 'changeCase', operatorArgs: { toLower: false }, context: 'visual', isEdit: true },\n    { keys: '<C-r>', type: 'action', action: 'redo' },\n    { keys: 'm<character>', type: 'action', action: 'setMark' },\n    { keys: '\"<character>', type: 'action', action: 'setRegister' },\n    { keys: 'zz', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' } },\n    { keys: 'z.', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: 'zt', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' } },\n    { keys: 'z<CR>', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: 'zb', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' } },\n    { keys: 'z-', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: '.', type: 'action', action: 'repeatLastEdit' },\n    { keys: '<C-a>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: { increase: true, backtrack: false } },\n    { keys: '<C-x>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: { increase: false, backtrack: false } },\n    { keys: '<C-t>', type: 'action', action: 'indent', actionArgs: { indentRight: true }, context: 'insert' },\n    { keys: '<C-d>', type: 'action', action: 'indent', actionArgs: { indentRight: false }, context: 'insert' },\n    { keys: 'a<character>', type: 'motion', motion: 'textObjectManipulation' },\n    { keys: 'i<character>', type: 'motion', motion: 'textObjectManipulation', motionArgs: { textObjectInner: true } },\n    { keys: '/', type: 'search', searchArgs: { forward: true, querySrc: 'prompt', toJumplist: true } },\n    { keys: '?', type: 'search', searchArgs: { forward: false, querySrc: 'prompt', toJumplist: true } },\n    { keys: '*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true } },\n    { keys: '#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true } },\n    { keys: 'g*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', toJumplist: true } },\n    { keys: 'g#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', toJumplist: true } },\n    { keys: ':', type: 'ex' }\n];\nvar defaultKeymapLength = defaultKeymap.length;\nvar defaultExCommandMap = [\n    { name: 'colorscheme', shortName: 'colo' },\n    { name: 'map' },\n    { name: 'imap', shortName: 'im' },\n    { name: 'nmap', shortName: 'nm' },\n    { name: 'vmap', shortName: 'vm' },\n    { name: 'unmap' },\n    { name: 'write', shortName: 'w' },\n    { name: 'undo', shortName: 'u' },\n    { name: 'redo', shortName: 'red' },\n    { name: 'set', shortName: 'se' },\n    { name: 'setlocal', shortName: 'setl' },\n    { name: 'setglobal', shortName: 'setg' },\n    { name: 'sort', shortName: 'sor' },\n    { name: 'substitute', shortName: 's', possiblyAsync: true },\n    { name: 'nohlsearch', shortName: 'noh' },\n    { name: 'yank', shortName: 'y' },\n    { name: 'delmarks', shortName: 'delm' },\n    { name: 'registers', shortName: 'reg', excludeFromCommandHistory: true },\n    { name: 'vglobal', shortName: 'v' },\n    { name: 'global', shortName: 'g' }\n];\nfunction enterVimMode(cm) {\n    cm.setOption('disableInput', true);\n    cm.setOption('showCursorWhenSelecting', false);\n    CodeMirror.signal(cm, \"vim-mode-change\", { mode: \"normal\" });\n    cm.on('cursorActivity', onCursorActivity);\n    maybeInitVimState(cm);\n    CodeMirror.on(cm.getInputField(), 'paste', getOnPasteFn(cm));\n}\nfunction leaveVimMode(cm) {\n    cm.setOption('disableInput', false);\n    cm.off('cursorActivity', onCursorActivity);\n    CodeMirror.off(cm.getInputField(), 'paste', getOnPasteFn(cm));\n    cm.state.vim = null;\n    if (highlightTimeout)\n        clearTimeout(highlightTimeout);\n}\nfunction detachVimMap(cm, next) {\n    if (this == CodeMirror.keyMap.vim) {\n        cm.options.$customCursor = null;\n        CodeMirror.rmClass(cm.getWrapperElement(), \"cm-fat-cursor\");\n    }\n    if (!next || next.attach != attachVimMap)\n        leaveVimMode(cm);\n}\nfunction attachVimMap(cm, prev) {\n    if (this == CodeMirror.keyMap.vim) {\n        if (cm.curOp)\n            cm.curOp.selectionChanged = true;\n        cm.options.$customCursor = transformCursor;\n        CodeMirror.addClass(cm.getWrapperElement(), \"cm-fat-cursor\");\n    }\n    if (!prev || prev.attach != attachVimMap)\n        enterVimMode(cm);\n}\nCodeMirror.defineOption('vimMode', false, function (cm, val, prev) {\n    if (val && cm.getOption(\"keyMap\") != \"vim\")\n        cm.setOption(\"keyMap\", \"vim\");\n    else if (!val && prev != CodeMirror.Init && /^vim/.test(cm.getOption(\"keyMap\")))\n        cm.setOption(\"keyMap\", \"default\");\n});\nfunction cmKey(key, cm) {\n    if (!cm) {\n        return undefined;\n    }\n    if (this[key]) {\n        return this[key];\n    }\n    var vimKey = cmKeyToVimKey(key);\n    if (!vimKey) {\n        return false;\n    }\n    var cmd = vimApi.findKey(cm, vimKey);\n    if (typeof cmd == 'function') {\n        CodeMirror.signal(cm, 'vim-keypress', vimKey);\n    }\n    return cmd;\n}\nvar modifiers = { Shift: 'S', Ctrl: 'C', Alt: 'A', Cmd: 'D', Mod: 'A', CapsLock: '' };\nvar specialKeys = { Enter: 'CR', Backspace: 'BS', Delete: 'Del', Insert: 'Ins' };\nfunction cmKeyToVimKey(key) {\n    if (key.charAt(0) == '\\'') {\n        return key.charAt(1);\n    }\n    var pieces = key.split(/-(?!$)/);\n    var lastPiece = pieces[pieces.length - 1];\n    if (pieces.length == 1 && pieces[0].length == 1) {\n        return false;\n    }\n    else if (pieces.length == 2 && pieces[0] == 'Shift' && lastPiece.length == 1) {\n        return false;\n    }\n    var hasCharacter = false;\n    for (var i = 0; i < pieces.length; i++) {\n        var piece = pieces[i];\n        if (piece in modifiers) {\n            pieces[i] = modifiers[piece];\n        }\n        else {\n            hasCharacter = true;\n        }\n        if (piece in specialKeys) {\n            pieces[i] = specialKeys[piece];\n        }\n    }\n    if (!hasCharacter) {\n        return false;\n    }\n    if (isUpperCase(lastPiece)) {\n        pieces[pieces.length - 1] = lastPiece.toLowerCase();\n    }\n    return '<' + pieces.join('-') + '>';\n}\nfunction getOnPasteFn(cm) {\n    var vim = cm.state.vim;\n    if (!vim.onPasteFn) {\n        vim.onPasteFn = function () {\n            if (!vim.insertMode) {\n                cm.setCursor(offsetCursor(cm.getCursor(), 0, 1));\n                actions.enterInsertMode(cm, {}, vim);\n            }\n        };\n    }\n    return vim.onPasteFn;\n}\nvar numberRegex = /[\\d]/;\nvar wordCharTest = [CodeMirror.isWordChar, function (ch) {\n        return ch && !CodeMirror.isWordChar(ch) && !/\\s/.test(ch);\n    }], bigWordCharTest = [function (ch) {\n        return /\\S/.test(ch);\n    }];\nfunction makeKeyRange(start, size) {\n    var keys = [];\n    for (var i = start; i < start + size; i++) {\n        keys.push(String.fromCharCode(i));\n    }\n    return keys;\n}\nvar upperCaseAlphabet = makeKeyRange(65, 26);\nvar lowerCaseAlphabet = makeKeyRange(97, 26);\nvar numbers = makeKeyRange(48, 10);\nvar validMarks = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['<', '>']);\nvar validRegisters = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['-', '\"', '.', ':', '_', '/', '+']);\nvar upperCaseChars;\ntry {\n    upperCaseChars = new RegExp(\"^[\\\\p{Lu}]$\", \"u\");\n}\ncatch (_) {\n    upperCaseChars = /^[A-Z]$/;\n}\nfunction isLine(cm, line) {\n    return line >= cm.firstLine() && line <= cm.lastLine();\n}\nfunction isLowerCase(k) {\n    return (/^[a-z]$/).test(k);\n}\nfunction isMatchableSymbol(k) {\n    return '()[]{}'.indexOf(k) != -1;\n}\nfunction isNumber(k) {\n    return numberRegex.test(k);\n}\nfunction isUpperCase(k) {\n    return upperCaseChars.test(k);\n}\nfunction isWhiteSpaceString(k) {\n    return (/^\\s*$/).test(k);\n}\nfunction isEndOfSentenceSymbol(k) {\n    return '.?!'.indexOf(k) != -1;\n}\nfunction inArray(val, arr) {\n    for (var i = 0; i < arr.length; i++) {\n        if (arr[i] == val) {\n            return true;\n        }\n    }\n    return false;\n}\nvar options = {};\nfunction defineOption(name, defaultValue, type, aliases, callback) {\n    if (defaultValue === undefined && !callback) {\n        throw Error('defaultValue is required unless callback is provided');\n    }\n    if (!type) {\n        type = 'string';\n    }\n    options[name] = {\n        type: type,\n        defaultValue: defaultValue,\n        callback: callback\n    };\n    if (aliases) {\n        for (var i = 0; i < aliases.length; i++) {\n            options[aliases[i]] = options[name];\n        }\n    }\n    if (defaultValue) {\n        setOption(name, defaultValue);\n    }\n}\nfunction setOption(name, value, cm, cfg) {\n    var option = options[name];\n    cfg = cfg || {};\n    var scope = cfg.scope;\n    if (!option) {\n        return new Error('Unknown option: ' + name);\n    }\n    if (option.type == 'boolean') {\n        if (value && value !== true) {\n            return new Error('Invalid argument: ' + name + '=' + value);\n        }\n        else if (value !== false) {\n            value = true;\n        }\n    }\n    if (option.callback) {\n        if (scope !== 'local') {\n            option.callback(value, undefined);\n        }\n        if (scope !== 'global' && cm) {\n            option.callback(value, cm);\n        }\n    }\n    else {\n        if (scope !== 'local') {\n            option.value = option.type == 'boolean' ? !!value : value;\n        }\n        if (scope !== 'global' && cm) {\n            cm.state.vim.options[name] = { value: value };\n        }\n    }\n}\nfunction getOption(name, cm, cfg) {\n    var option = options[name];\n    cfg = cfg || {};\n    var scope = cfg.scope;\n    if (!option) {\n        return new Error('Unknown option: ' + name);\n    }\n    if (option.callback) {\n        var local = cm && option.callback(undefined, cm);\n        if (scope !== 'global' && local !== undefined) {\n            return local;\n        }\n        if (scope !== 'local') {\n            return option.callback();\n        }\n        return;\n    }\n    else {\n        var local = (scope !== 'global') && (cm && cm.state.vim.options[name]);\n        return (local || (scope !== 'local') && option || {}).value;\n    }\n}\ndefineOption('filetype', undefined, 'string', ['ft'], function (name, cm) {\n    if (cm === undefined) {\n        return;\n    }\n    if (name === undefined) {\n        var mode = cm.getOption('mode');\n        return mode == 'null' ? '' : mode;\n    }\n    else {\n        var mode = name == '' ? 'null' : name;\n        cm.setOption('mode', mode);\n    }\n});\nvar createCircularJumpList = function () {\n    var size = 100;\n    var pointer = -1;\n    var head = 0;\n    var tail = 0;\n    var buffer = new Array(size);\n    function add(cm, oldCur, newCur) {\n        var current = pointer % size;\n        var curMark = buffer[current];\n        function useNextSlot(cursor) {\n            var next = ++pointer % size;\n            var trashMark = buffer[next];\n            if (trashMark) {\n                trashMark.clear();\n            }\n            buffer[next] = cm.setBookmark(cursor);\n        }\n        if (curMark) {\n            var markPos = curMark.find();\n            if (markPos && !cursorEqual(markPos, oldCur)) {\n                useNextSlot(oldCur);\n            }\n        }\n        else {\n            useNextSlot(oldCur);\n        }\n        useNextSlot(newCur);\n        head = pointer;\n        tail = pointer - size + 1;\n        if (tail < 0) {\n            tail = 0;\n        }\n    }\n    function move(cm, offset) {\n        pointer += offset;\n        if (pointer > head) {\n            pointer = head;\n        }\n        else if (pointer < tail) {\n            pointer = tail;\n        }\n        var mark = buffer[(size + pointer) % size];\n        if (mark && !mark.find()) {\n            var inc = offset > 0 ? 1 : -1;\n            var newCur;\n            var oldCur = cm.getCursor();\n            do {\n                pointer += inc;\n                mark = buffer[(size + pointer) % size];\n                if (mark &&\n                    (newCur = mark.find()) &&\n                    !cursorEqual(oldCur, newCur)) {\n                    break;\n                }\n            } while (pointer < head && pointer > tail);\n        }\n        return mark;\n    }\n    function find(cm, offset) {\n        var oldPointer = pointer;\n        var mark = move(cm, offset);\n        pointer = oldPointer;\n        return mark && mark.find();\n    }\n    return {\n        cachedCursor: undefined,\n        add: add,\n        find: find,\n        move: move\n    };\n};\nvar createInsertModeChanges = function (c) {\n    if (c) {\n        return {\n            changes: c.changes,\n            expectCursorActivityForChange: c.expectCursorActivityForChange\n        };\n    }\n    return {\n        changes: [],\n        expectCursorActivityForChange: false\n    };\n};\nfunction MacroModeState() {\n    this.latestRegister = undefined;\n    this.isPlaying = false;\n    this.isRecording = false;\n    this.replaySearchQueries = [];\n    this.onRecordingDone = undefined;\n    this.lastInsertModeChanges = createInsertModeChanges();\n}\nMacroModeState.prototype = {\n    exitMacroRecordMode: function () {\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.onRecordingDone) {\n            macroModeState.onRecordingDone(); // close dialog\n        }\n        macroModeState.onRecordingDone = undefined;\n        macroModeState.isRecording = false;\n    },\n    enterMacroRecordMode: function (cm, registerName) {\n        var register = vimGlobalState.registerController.getRegister(registerName);\n        if (register) {\n            register.clear();\n            this.latestRegister = registerName;\n            if (cm.openDialog) {\n                var template = dom('span', { class: 'cm-vim-message' }, 'recording @' + registerName);\n                this.onRecordingDone = cm.openDialog(template, null, { bottom: true });\n            }\n            this.isRecording = true;\n        }\n    }\n};\nfunction maybeInitVimState(cm) {\n    if (!cm.state.vim) {\n        cm.state.vim = {\n            inputState: new InputState(),\n            lastEditInputState: undefined,\n            lastEditActionCommand: undefined,\n            lastHPos: -1,\n            lastHSPos: -1,\n            lastMotion: null,\n            marks: {},\n            insertMode: false,\n            insertModeRepeat: undefined,\n            visualMode: false,\n            visualLine: false,\n            visualBlock: false,\n            lastSelection: null,\n            lastPastedText: null,\n            sel: {},\n            options: {}\n        };\n    }\n    return cm.state.vim;\n}\nvar vimGlobalState;\nfunction resetVimGlobalState() {\n    vimGlobalState = {\n        searchQuery: null,\n        searchIsReversed: false,\n        lastSubstituteReplacePart: undefined,\n        jumpList: createCircularJumpList(),\n        macroModeState: new MacroModeState,\n        lastCharacterSearch: { increment: 0, forward: true, selectedCharacter: '' },\n        registerController: new RegisterController({}),\n        searchHistoryController: new HistoryController(),\n        exCommandHistoryController: new HistoryController()\n    };\n    for (var optionName in options) {\n        var option = options[optionName];\n        option.value = option.defaultValue;\n    }\n}\nvar lastInsertModeKeyTimer;\nvar vimApi = {\n    enterVimMode: enterVimMode,\n    leaveVimMode: leaveVimMode,\n    buildKeyMap: function () {\n    },\n    getRegisterController: function () {\n        return vimGlobalState.registerController;\n    },\n    resetVimGlobalState_: resetVimGlobalState,\n    getVimGlobalState_: function () {\n        return vimGlobalState;\n    },\n    maybeInitVimState_: maybeInitVimState,\n    suppressErrorLogging: false,\n    InsertModeKey: InsertModeKey,\n    map: function (lhs, rhs, ctx) {\n        exCommandDispatcher.map(lhs, rhs, ctx);\n    },\n    unmap: function (lhs, ctx) {\n        return exCommandDispatcher.unmap(lhs, ctx);\n    },\n    noremap: function (lhs, rhs, ctx) {\n        function toCtxArray(ctx) {\n            return ctx ? [ctx] : ['normal', 'insert', 'visual'];\n        }\n        var ctxsToMap = toCtxArray(ctx);\n        var actualLength = defaultKeymap.length, origLength = defaultKeymapLength;\n        for (var i = actualLength - origLength; i < actualLength && ctxsToMap.length; i++) {\n            var mapping = defaultKeymap[i];\n            if (mapping.keys == rhs &&\n                (!ctx || !mapping.context || mapping.context === ctx) &&\n                mapping.type.substr(0, 2) !== 'ex' &&\n                mapping.type.substr(0, 3) !== 'key') {\n                var newMapping = {};\n                for (var key in mapping) {\n                    newMapping[key] = mapping[key];\n                }\n                newMapping.keys = lhs;\n                if (ctx && !newMapping.context) {\n                    newMapping.context = ctx;\n                }\n                this._mapCommand(newMapping);\n                var mappedCtxs = toCtxArray(mapping.context);\n                ctxsToMap = ctxsToMap.filter(function (el) { return mappedCtxs.indexOf(el) === -1; });\n            }\n        }\n    },\n    mapclear: function (ctx) {\n        var actualLength = defaultKeymap.length, origLength = defaultKeymapLength;\n        var userKeymap = defaultKeymap.slice(0, actualLength - origLength);\n        defaultKeymap = defaultKeymap.slice(actualLength - origLength);\n        if (ctx) {\n            for (var i = userKeymap.length - 1; i >= 0; i--) {\n                var mapping = userKeymap[i];\n                if (ctx !== mapping.context) {\n                    if (mapping.context) {\n                        this._mapCommand(mapping);\n                    }\n                    else {\n                        var contexts = ['normal', 'insert', 'visual'];\n                        for (var j in contexts) {\n                            if (contexts[j] !== ctx) {\n                                var newMapping = {};\n                                for (var key in mapping) {\n                                    newMapping[key] = mapping[key];\n                                }\n                                newMapping.context = contexts[j];\n                                this._mapCommand(newMapping);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    },\n    setOption: setOption,\n    getOption: getOption,\n    defineOption: defineOption,\n    defineEx: function (name, prefix, func) {\n        if (!prefix) {\n            prefix = name;\n        }\n        else if (name.indexOf(prefix) !== 0) {\n            throw new Error('(Vim.defineEx) \"' + prefix + '\" is not a prefix of \"' + name + '\", command not registered');\n        }\n        exCommands[name] = func;\n        exCommandDispatcher.commandMap_[prefix] = { name: name, shortName: prefix, type: 'api' };\n    },\n    handleKey: function (cm, key, origin) {\n        var command = this.findKey(cm, key, origin);\n        if (typeof command === 'function') {\n            return command();\n        }\n    },\n    multiSelectHandleKey: multiSelectHandleKey,\n    findKey: function (cm, key, origin) {\n        var vim = maybeInitVimState(cm);\n        function handleMacroRecording() {\n            var macroModeState = vimGlobalState.macroModeState;\n            if (macroModeState.isRecording) {\n                if (key == 'q') {\n                    macroModeState.exitMacroRecordMode();\n                    clearInputState(cm);\n                    return true;\n                }\n                if (origin != 'mapping') {\n                    logKey(macroModeState, key);\n                }\n            }\n        }\n        function handleEsc() {\n            if (key == '<Esc>') {\n                if (vim.visualMode) {\n                    exitVisualMode(cm);\n                }\n                else if (vim.insertMode) {\n                    exitInsertMode(cm);\n                }\n                else {\n                    return;\n                }\n                clearInputState(cm);\n                return true;\n            }\n        }\n        function doKeyToKey(keys) {\n            var match;\n            while (keys) {\n                match = (/<\\w+-.+?>|<\\w+>|./).exec(keys);\n                key = match[0];\n                keys = keys.substring(match.index + key.length);\n                vimApi.handleKey(cm, key, 'mapping');\n            }\n        }\n        function handleKeyInsertMode() {\n            if (handleEsc()) {\n                return true;\n            }\n            var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;\n            var keysAreChars = key.length == 1;\n            var match = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\n            while (keys.length > 1 && match.type != 'full') {\n                var keys = vim.inputState.keyBuffer = keys.slice(1);\n                var thisMatch = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\n                if (thisMatch.type != 'none') {\n                    match = thisMatch;\n                }\n            }\n            if (match.type == 'none') {\n                clearInputState(cm);\n                return false;\n            }\n            else if (match.type == 'partial') {\n                if (lastInsertModeKeyTimer) {\n                    window.clearTimeout(lastInsertModeKeyTimer);\n                }\n                lastInsertModeKeyTimer = window.setTimeout(function () { if (vim.insertMode && vim.inputState.keyBuffer) {\n                    clearInputState(cm);\n                } }, getOption('insertModeEscKeysTimeout'));\n                return !keysAreChars;\n            }\n            if (lastInsertModeKeyTimer) {\n                window.clearTimeout(lastInsertModeKeyTimer);\n            }\n            if (keysAreChars) {\n                var selections = cm.listSelections();\n                for (var i = 0; i < selections.length; i++) {\n                    var here = selections[i].head;\n                    cm.replaceRange('', offsetCursor(here, 0, -(keys.length - 1)), here, '+input');\n                }\n                vimGlobalState.macroModeState.lastInsertModeChanges.changes.pop();\n            }\n            clearInputState(cm);\n            return match.command;\n        }\n        function handleKeyNonInsertMode() {\n            if (handleMacroRecording() || handleEsc()) {\n                return true;\n            }\n            var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;\n            if (/^[1-9]\\d*$/.test(keys)) {\n                return true;\n            }\n            var keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n            if (!keysMatcher) {\n                clearInputState(cm);\n                return false;\n            }\n            var context = vim.visualMode ? 'visual' :\n                'normal';\n            var mainKey = keysMatcher[2] || keysMatcher[1];\n            if (vim.inputState.operatorShortcut && vim.inputState.operatorShortcut.slice(-1) == mainKey) {\n                mainKey = vim.inputState.operatorShortcut;\n            }\n            var match = commandDispatcher.matchCommand(mainKey, defaultKeymap, vim.inputState, context);\n            if (match.type == 'none') {\n                clearInputState(cm);\n                return false;\n            }\n            else if (match.type == 'partial') {\n                return true;\n            }\n            else if (match.type == 'clear') {\n                clearInputState(cm);\n                return true;\n            }\n            vim.inputState.keyBuffer = '';\n            keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n            if (keysMatcher[1] && keysMatcher[1] != '0') {\n                vim.inputState.pushRepeatDigit(keysMatcher[1]);\n            }\n            return match.command;\n        }\n        var command;\n        if (vim.insertMode) {\n            command = handleKeyInsertMode();\n        }\n        else {\n            command = handleKeyNonInsertMode();\n        }\n        if (command === false) {\n            return undefined; //ace_patch\n        }\n        else if (command === true) {\n            return function () { return true; };\n        }\n        else {\n            return function () {\n                if ((command.operator || command.isEdit) && cm.getOption('readOnly'))\n                    return; // ace_patch\n                return cm.operation(function () {\n                    cm.curOp.isVimOp = true;\n                    try {\n                        if (command.type == 'keyToKey') {\n                            doKeyToKey(command.toKeys);\n                        }\n                        else {\n                            commandDispatcher.processCommand(cm, vim, command);\n                        }\n                    }\n                    catch (e) {\n                        cm.state.vim = undefined;\n                        maybeInitVimState(cm);\n                        if (!vimApi.suppressErrorLogging) {\n                            console['log'](e);\n                        }\n                        throw e;\n                    }\n                    return true;\n                });\n            };\n        }\n    },\n    handleEx: function (cm, input) {\n        exCommandDispatcher.processCommand(cm, input);\n    },\n    defineMotion: defineMotion,\n    defineAction: defineAction,\n    defineOperator: defineOperator,\n    mapCommand: mapCommand,\n    _mapCommand: _mapCommand,\n    defineRegister: defineRegister,\n    exitVisualMode: exitVisualMode,\n    exitInsertMode: exitInsertMode\n};\nfunction InputState() {\n    this.prefixRepeat = [];\n    this.motionRepeat = [];\n    this.operator = null;\n    this.operatorArgs = null;\n    this.motion = null;\n    this.motionArgs = null;\n    this.keyBuffer = []; // For matching multi-key commands.\n    this.registerName = null; // Defaults to the unnamed register.\n}\nInputState.prototype.pushRepeatDigit = function (n) {\n    if (!this.operator) {\n        this.prefixRepeat = this.prefixRepeat.concat(n);\n    }\n    else {\n        this.motionRepeat = this.motionRepeat.concat(n);\n    }\n};\nInputState.prototype.getRepeat = function () {\n    var repeat = 0;\n    if (this.prefixRepeat.length > 0 || this.motionRepeat.length > 0) {\n        repeat = 1;\n        if (this.prefixRepeat.length > 0) {\n            repeat *= parseInt(this.prefixRepeat.join(''), 10);\n        }\n        if (this.motionRepeat.length > 0) {\n            repeat *= parseInt(this.motionRepeat.join(''), 10);\n        }\n    }\n    return repeat;\n};\nfunction clearInputState(cm, reason) {\n    cm.state.vim.inputState = new InputState();\n    CodeMirror.signal(cm, 'vim-command-done', reason);\n}\nfunction Register(text, linewise, blockwise) {\n    this.clear();\n    this.keyBuffer = [text || ''];\n    this.insertModeChanges = [];\n    this.searchQueries = [];\n    this.linewise = !!linewise;\n    this.blockwise = !!blockwise;\n}\nRegister.prototype = {\n    setText: function (text, linewise, blockwise) {\n        this.keyBuffer = [text || ''];\n        this.linewise = !!linewise;\n        this.blockwise = !!blockwise;\n    },\n    pushText: function (text, linewise) {\n        if (linewise) {\n            if (!this.linewise) {\n                this.keyBuffer.push('\\n');\n            }\n            this.linewise = true;\n        }\n        this.keyBuffer.push(text);\n    },\n    pushInsertModeChanges: function (changes) {\n        this.insertModeChanges.push(createInsertModeChanges(changes));\n    },\n    pushSearchQuery: function (query) {\n        this.searchQueries.push(query);\n    },\n    clear: function () {\n        this.keyBuffer = [];\n        this.insertModeChanges = [];\n        this.searchQueries = [];\n        this.linewise = false;\n    },\n    toString: function () {\n        return this.keyBuffer.join('');\n    }\n};\nfunction defineRegister(name, register) {\n    var registers = vimGlobalState.registerController.registers;\n    if (!name || name.length != 1) {\n        throw Error('Register name must be 1 character');\n    }\n    registers[name] = register;\n    validRegisters.push(name);\n}\nfunction RegisterController(registers) {\n    this.registers = registers;\n    this.unnamedRegister = registers['\"'] = new Register();\n    registers['.'] = new Register();\n    registers[':'] = new Register();\n    registers['/'] = new Register();\n    registers['+'] = new Register();\n}\nRegisterController.prototype = {\n    pushText: function (registerName, operator, text, linewise, blockwise) {\n        if (registerName === '_')\n            return;\n        if (linewise && text.charAt(text.length - 1) !== '\\n') {\n            text += '\\n';\n        }\n        var register = this.isValidRegister(registerName) ?\n            this.getRegister(registerName) : null;\n        if (!register) {\n            switch (operator) {\n                case 'yank':\n                    this.registers['0'] = new Register(text, linewise, blockwise);\n                    break;\n                case 'delete':\n                case 'change':\n                    if (text.indexOf('\\n') == -1) {\n                        this.registers['-'] = new Register(text, linewise);\n                    }\n                    else {\n                        this.shiftNumericRegisters_();\n                        this.registers['1'] = new Register(text, linewise);\n                    }\n                    break;\n            }\n            this.unnamedRegister.setText(text, linewise, blockwise);\n            return;\n        }\n        var append = isUpperCase(registerName);\n        if (append) {\n            register.pushText(text, linewise);\n        }\n        else {\n            register.setText(text, linewise, blockwise);\n        }\n        if (registerName === '+' && typeof navigator !== 'undefined' &&\n            typeof navigator.clipboard !== 'undefined' &&\n            typeof navigator.clipboard.readText === 'function') {\n            navigator.clipboard.writeText(text);\n        }\n        this.unnamedRegister.setText(register.toString(), linewise);\n    },\n    getRegister: function (name) {\n        if (!this.isValidRegister(name)) {\n            return this.unnamedRegister;\n        }\n        name = name.toLowerCase();\n        if (!this.registers[name]) {\n            this.registers[name] = new Register();\n        }\n        return this.registers[name];\n    },\n    isValidRegister: function (name) {\n        return name && inArray(name, validRegisters);\n    },\n    shiftNumericRegisters_: function () {\n        for (var i = 9; i >= 2; i--) {\n            this.registers[i] = this.getRegister('' + (i - 1));\n        }\n    }\n};\nfunction HistoryController() {\n    this.historyBuffer = [];\n    this.iterator = 0;\n    this.initialPrefix = null;\n}\nHistoryController.prototype = {\n    nextMatch: function (input, up) {\n        var historyBuffer = this.historyBuffer;\n        var dir = up ? -1 : 1;\n        if (this.initialPrefix === null)\n            this.initialPrefix = input;\n        for (var i = this.iterator + dir; up ? i >= 0 : i < historyBuffer.length; i += dir) {\n            var element = historyBuffer[i];\n            for (var j = 0; j <= element.length; j++) {\n                if (this.initialPrefix == element.substring(0, j)) {\n                    this.iterator = i;\n                    return element;\n                }\n            }\n        }\n        if (i >= historyBuffer.length) {\n            this.iterator = historyBuffer.length;\n            return this.initialPrefix;\n        }\n        if (i < 0)\n            return input;\n    },\n    pushInput: function (input) {\n        var index = this.historyBuffer.indexOf(input);\n        if (index > -1)\n            this.historyBuffer.splice(index, 1);\n        if (input.length)\n            this.historyBuffer.push(input);\n    },\n    reset: function () {\n        this.initialPrefix = null;\n        this.iterator = this.historyBuffer.length;\n    }\n};\nvar commandDispatcher = {\n    matchCommand: function (keys, keyMap, inputState, context) {\n        var matches = commandMatches(keys, keyMap, context, inputState);\n        if (!matches.full && !matches.partial) {\n            return { type: 'none' };\n        }\n        else if (!matches.full && matches.partial) {\n            return { type: 'partial' };\n        }\n        var bestMatch;\n        for (var i = 0; i < matches.full.length; i++) {\n            var match = matches.full[i];\n            if (!bestMatch) {\n                bestMatch = match;\n            }\n        }\n        if (bestMatch.keys.slice(-11) == '<character>') {\n            var character = lastChar(keys);\n            if (!character || character.length > 1)\n                return { type: 'clear' };\n            inputState.selectedCharacter = character;\n        }\n        return { type: 'full', command: bestMatch };\n    },\n    processCommand: function (cm, vim, command) {\n        vim.inputState.repeatOverride = command.repeatOverride;\n        switch (command.type) {\n            case 'motion':\n                this.processMotion(cm, vim, command);\n                break;\n            case 'operator':\n                this.processOperator(cm, vim, command);\n                break;\n            case 'operatorMotion':\n                this.processOperatorMotion(cm, vim, command);\n                break;\n            case 'action':\n                this.processAction(cm, vim, command);\n                break;\n            case 'search':\n                this.processSearch(cm, vim, command);\n                break;\n            case 'ex':\n            case 'keyToEx':\n                this.processEx(cm, vim, command);\n                break;\n            default:\n                break;\n        }\n    },\n    processMotion: function (cm, vim, command) {\n        vim.inputState.motion = command.motion;\n        vim.inputState.motionArgs = copyArgs(command.motionArgs);\n        this.evalInput(cm, vim);\n    },\n    processOperator: function (cm, vim, command) {\n        var inputState = vim.inputState;\n        if (inputState.operator) {\n            if (inputState.operator == command.operator) {\n                inputState.motion = 'expandToLine';\n                inputState.motionArgs = { linewise: true };\n                this.evalInput(cm, vim);\n                return;\n            }\n            else {\n                clearInputState(cm);\n            }\n        }\n        inputState.operator = command.operator;\n        inputState.operatorArgs = copyArgs(command.operatorArgs);\n        if (command.keys.length > 1) {\n            inputState.operatorShortcut = command.keys;\n        }\n        if (command.exitVisualBlock) {\n            vim.visualBlock = false;\n            updateCmSelection(cm);\n        }\n        if (vim.visualMode) {\n            this.evalInput(cm, vim);\n        }\n    },\n    processOperatorMotion: function (cm, vim, command) {\n        var visualMode = vim.visualMode;\n        var operatorMotionArgs = copyArgs(command.operatorMotionArgs);\n        if (operatorMotionArgs) {\n            if (visualMode && operatorMotionArgs.visualLine) {\n                vim.visualLine = true;\n            }\n        }\n        this.processOperator(cm, vim, command);\n        if (!visualMode) {\n            this.processMotion(cm, vim, command);\n        }\n    },\n    processAction: function (cm, vim, command) {\n        var inputState = vim.inputState;\n        var repeat = inputState.getRepeat();\n        var repeatIsExplicit = !!repeat;\n        var actionArgs = copyArgs(command.actionArgs) || {};\n        if (inputState.selectedCharacter) {\n            actionArgs.selectedCharacter = inputState.selectedCharacter;\n        }\n        if (command.operator) {\n            this.processOperator(cm, vim, command);\n        }\n        if (command.motion) {\n            this.processMotion(cm, vim, command);\n        }\n        if (command.motion || command.operator) {\n            this.evalInput(cm, vim);\n        }\n        actionArgs.repeat = repeat || 1;\n        actionArgs.repeatIsExplicit = repeatIsExplicit;\n        actionArgs.registerName = inputState.registerName;\n        clearInputState(cm);\n        vim.lastMotion = null;\n        if (command.isEdit) {\n            this.recordLastEdit(vim, inputState, command);\n        }\n        actions[command.action](cm, actionArgs, vim);\n    },\n    processSearch: function (cm, vim, command) {\n        if (!cm.getSearchCursor) {\n            return;\n        }\n        var forward = command.searchArgs.forward;\n        var wholeWordOnly = command.searchArgs.wholeWordOnly;\n        getSearchState(cm).setReversed(!forward);\n        var promptPrefix = (forward) ? '/' : '?';\n        var originalQuery = getSearchState(cm).getQuery();\n        var originalScrollPos = cm.getScrollInfo();\n        function handleQuery(query, ignoreCase, smartCase) {\n            vimGlobalState.searchHistoryController.pushInput(query);\n            vimGlobalState.searchHistoryController.reset();\n            try {\n                updateSearchQuery(cm, query, ignoreCase, smartCase);\n            }\n            catch (e) {\n                showConfirm(cm, 'Invalid regex: ' + query);\n                clearInputState(cm);\n                return;\n            }\n            commandDispatcher.processMotion(cm, vim, {\n                type: 'motion',\n                motion: 'findNext',\n                motionArgs: { forward: true, toJumplist: command.searchArgs.toJumplist }\n            });\n        }\n        function onPromptClose(query) {\n            handleQuery(query, true /** ignoreCase */, true /** smartCase */);\n            var macroModeState = vimGlobalState.macroModeState;\n            if (macroModeState.isRecording) {\n                logSearchQuery(macroModeState, query);\n            }\n        }\n        function onPromptKeyUp(e, query, close) {\n            var keyName = CodeMirror.keyName(e), up, offset;\n            if (keyName == 'Up' || keyName == 'Down') {\n                up = keyName == 'Up' ? true : false;\n                offset = e.target ? e.target.selectionEnd : 0;\n                query = vimGlobalState.searchHistoryController.nextMatch(query, up) || '';\n                close(query);\n                if (offset && e.target)\n                    e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n            }\n            else {\n                if (keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift')\n                    vimGlobalState.searchHistoryController.reset();\n            }\n            var parsedQuery;\n            try {\n                parsedQuery = updateSearchQuery(cm, query, true /** ignoreCase */, true /** smartCase */);\n            }\n            catch (e) {\n            }\n            if (parsedQuery) {\n                cm.scrollIntoView(findNext(cm, !forward, parsedQuery), 30);\n            }\n            else {\n                clearSearchHighlight(cm);\n                cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n            }\n        }\n        function onPromptKeyDown(e, query, close) {\n            var keyName = CodeMirror.keyName(e);\n            if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' ||\n                (keyName == 'Backspace' && query == '')) {\n                vimGlobalState.searchHistoryController.pushInput(query);\n                vimGlobalState.searchHistoryController.reset();\n                updateSearchQuery(cm, originalQuery);\n                clearSearchHighlight(cm);\n                cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n                CodeMirror.e_stop(e);\n                clearInputState(cm);\n                close();\n                cm.focus();\n            }\n            else if (keyName == 'Up' || keyName == 'Down') {\n                CodeMirror.e_stop(e);\n            }\n            else if (keyName == 'Ctrl-U') {\n                CodeMirror.e_stop(e);\n                close('');\n            }\n        }\n        switch (command.searchArgs.querySrc) {\n            case 'prompt':\n                var macroModeState = vimGlobalState.macroModeState;\n                if (macroModeState.isPlaying) {\n                    var query = macroModeState.replaySearchQueries.shift();\n                    handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n                }\n                else {\n                    showPrompt(cm, {\n                        onClose: onPromptClose,\n                        prefix: promptPrefix,\n                        desc: '(JavaScript regexp)',\n                        onKeyUp: onPromptKeyUp,\n                        onKeyDown: onPromptKeyDown\n                    });\n                }\n                break;\n            case 'wordUnderCursor':\n                var word = expandWordUnderCursor(cm, false /** inclusive */, true /** forward */, false /** bigWord */, true /** noSymbol */);\n                var isKeyword = true;\n                if (!word) {\n                    word = expandWordUnderCursor(cm, false /** inclusive */, true /** forward */, false /** bigWord */, false /** noSymbol */);\n                    isKeyword = false;\n                }\n                if (!word) {\n                    return;\n                }\n                var query = cm.getLine(word.start.line).substring(word.start.ch, word.end.ch);\n                if (isKeyword && wholeWordOnly) {\n                    query = '\\\\b' + query + '\\\\b';\n                }\n                else {\n                    query = escapeRegex(query);\n                }\n                vimGlobalState.jumpList.cachedCursor = cm.getCursor();\n                cm.setCursor(word.start);\n                handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n                break;\n        }\n    },\n    processEx: function (cm, vim, command) {\n        function onPromptClose(input) {\n            vimGlobalState.exCommandHistoryController.pushInput(input);\n            vimGlobalState.exCommandHistoryController.reset();\n            exCommandDispatcher.processCommand(cm, input);\n            if (cm.state.vim)\n                clearInputState(cm);\n        }\n        function onPromptKeyDown(e, input, close) {\n            var keyName = CodeMirror.keyName(e), up, offset;\n            if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' ||\n                (keyName == 'Backspace' && input == '')) {\n                vimGlobalState.exCommandHistoryController.pushInput(input);\n                vimGlobalState.exCommandHistoryController.reset();\n                CodeMirror.e_stop(e);\n                clearInputState(cm);\n                close();\n                cm.focus();\n            }\n            if (keyName == 'Up' || keyName == 'Down') {\n                CodeMirror.e_stop(e);\n                up = keyName == 'Up' ? true : false;\n                offset = e.target ? e.target.selectionEnd : 0;\n                input = vimGlobalState.exCommandHistoryController.nextMatch(input, up) || '';\n                close(input);\n                if (offset && e.target)\n                    e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n            }\n            else if (keyName == 'Ctrl-U') {\n                CodeMirror.e_stop(e);\n                close('');\n            }\n            else {\n                if (keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift')\n                    vimGlobalState.exCommandHistoryController.reset();\n            }\n        }\n        if (command.type == 'keyToEx') {\n            exCommandDispatcher.processCommand(cm, command.exArgs.input);\n        }\n        else {\n            if (vim.visualMode) {\n                showPrompt(cm, { onClose: onPromptClose, prefix: ':', value: '\\'<,\\'>',\n                    onKeyDown: onPromptKeyDown, selectValueOnOpen: false });\n            }\n            else {\n                showPrompt(cm, { onClose: onPromptClose, prefix: ':',\n                    onKeyDown: onPromptKeyDown });\n            }\n        }\n    },\n    evalInput: function (cm, vim) {\n        var inputState = vim.inputState;\n        var motion = inputState.motion;\n        var motionArgs = inputState.motionArgs || {};\n        var operator = inputState.operator;\n        var operatorArgs = inputState.operatorArgs || {};\n        var registerName = inputState.registerName;\n        var sel = vim.sel;\n        var origHead = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.head) : cm.getCursor('head'));\n        var origAnchor = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.anchor) : cm.getCursor('anchor'));\n        var oldHead = copyCursor(origHead);\n        var oldAnchor = copyCursor(origAnchor);\n        var newHead, newAnchor;\n        var repeat;\n        if (operator) {\n            this.recordLastEdit(vim, inputState);\n        }\n        if (inputState.repeatOverride !== undefined) {\n            repeat = inputState.repeatOverride;\n        }\n        else {\n            repeat = inputState.getRepeat();\n        }\n        if (repeat > 0 && motionArgs.explicitRepeat) {\n            motionArgs.repeatIsExplicit = true;\n        }\n        else if (motionArgs.noRepeat ||\n            (!motionArgs.explicitRepeat && repeat === 0)) {\n            repeat = 1;\n            motionArgs.repeatIsExplicit = false;\n        }\n        if (inputState.selectedCharacter) {\n            motionArgs.selectedCharacter = operatorArgs.selectedCharacter =\n                inputState.selectedCharacter;\n        }\n        motionArgs.repeat = repeat;\n        clearInputState(cm);\n        if (motion) {\n            var motionResult = motions[motion](cm, origHead, motionArgs, vim, inputState);\n            vim.lastMotion = motions[motion];\n            if (!motionResult) {\n                return;\n            }\n            if (motionArgs.toJumplist) {\n                if (!operator && cm.ace.curOp != null)\n                    cm.ace.curOp.command.scrollIntoView = \"center-animate\"; // ace_patch\n                var jumpList = vimGlobalState.jumpList;\n                var cachedCursor = jumpList.cachedCursor;\n                if (cachedCursor) {\n                    recordJumpPosition(cm, cachedCursor, motionResult);\n                    delete jumpList.cachedCursor;\n                }\n                else {\n                    recordJumpPosition(cm, origHead, motionResult);\n                }\n            }\n            if (motionResult instanceof Array) {\n                newAnchor = motionResult[0];\n                newHead = motionResult[1];\n            }\n            else {\n                newHead = motionResult;\n            }\n            if (!newHead) {\n                newHead = copyCursor(origHead);\n            }\n            if (vim.visualMode) {\n                if (!(vim.visualBlock && newHead.ch === Infinity)) {\n                    newHead = clipCursorToContent(cm, newHead, oldHead);\n                }\n                if (newAnchor) {\n                    newAnchor = clipCursorToContent(cm, newAnchor);\n                }\n                newAnchor = newAnchor || oldAnchor;\n                sel.anchor = newAnchor;\n                sel.head = newHead;\n                updateCmSelection(cm);\n                updateMark(cm, vim, '<', cursorIsBefore(newAnchor, newHead) ? newAnchor\n                    : newHead);\n                updateMark(cm, vim, '>', cursorIsBefore(newAnchor, newHead) ? newHead\n                    : newAnchor);\n            }\n            else if (!operator) {\n                if (cm.ace.curOp)\n                    cm.ace.curOp.vimDialogScroll = \"center-animate\"; // ace_patch\n                newHead = clipCursorToContent(cm, newHead, oldHead);\n                cm.setCursor(newHead.line, newHead.ch);\n            }\n        }\n        if (operator) {\n            if (operatorArgs.lastSel) {\n                newAnchor = oldAnchor;\n                var lastSel = operatorArgs.lastSel;\n                var lineOffset = Math.abs(lastSel.head.line - lastSel.anchor.line);\n                var chOffset = Math.abs(lastSel.head.ch - lastSel.anchor.ch);\n                if (lastSel.visualLine) {\n                    newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n                }\n                else if (lastSel.visualBlock) {\n                    newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch + chOffset);\n                }\n                else if (lastSel.head.line == lastSel.anchor.line) {\n                    newHead = new Pos(oldAnchor.line, oldAnchor.ch + chOffset);\n                }\n                else {\n                    newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n                }\n                vim.visualMode = true;\n                vim.visualLine = lastSel.visualLine;\n                vim.visualBlock = lastSel.visualBlock;\n                sel = vim.sel = {\n                    anchor: newAnchor,\n                    head: newHead\n                };\n                updateCmSelection(cm);\n            }\n            else if (vim.visualMode) {\n                operatorArgs.lastSel = {\n                    anchor: copyCursor(sel.anchor),\n                    head: copyCursor(sel.head),\n                    visualBlock: vim.visualBlock,\n                    visualLine: vim.visualLine\n                };\n            }\n            var curStart, curEnd, linewise, mode;\n            var cmSel;\n            if (vim.visualMode) {\n                curStart = cursorMin(sel.head, sel.anchor);\n                curEnd = cursorMax(sel.head, sel.anchor);\n                linewise = vim.visualLine || operatorArgs.linewise;\n                mode = vim.visualBlock ? 'block' :\n                    linewise ? 'line' :\n                        'char';\n                var newPositions = updateSelectionForSurrogateCharacters(cm, curStart, curEnd);\n                cmSel = makeCmSelection(cm, {\n                    anchor: newPositions.start,\n                    head: newPositions.end\n                }, mode);\n                if (linewise) {\n                    var ranges = cmSel.ranges;\n                    if (mode == 'block') {\n                        for (var i = 0; i < ranges.length; i++) {\n                            ranges[i].head.ch = lineLength(cm, ranges[i].head.line);\n                        }\n                    }\n                    else if (mode == 'line') {\n                        ranges[0].head = new Pos(ranges[0].head.line + 1, 0);\n                    }\n                }\n            }\n            else {\n                curStart = copyCursor(newAnchor || oldAnchor);\n                curEnd = copyCursor(newHead || oldHead);\n                if (cursorIsBefore(curEnd, curStart)) {\n                    var tmp = curStart;\n                    curStart = curEnd;\n                    curEnd = tmp;\n                }\n                linewise = motionArgs.linewise || operatorArgs.linewise;\n                if (linewise) {\n                    expandSelectionToLine(cm, curStart, curEnd);\n                }\n                else if (motionArgs.forward) {\n                    clipToLine(cm, curStart, curEnd);\n                }\n                mode = 'char';\n                var exclusive = !motionArgs.inclusive || linewise;\n                var newPositions = updateSelectionForSurrogateCharacters(cm, curStart, curEnd);\n                cmSel = makeCmSelection(cm, {\n                    anchor: newPositions.start,\n                    head: newPositions.end\n                }, mode, exclusive);\n            }\n            cm.setSelections(cmSel.ranges, cmSel.primary);\n            vim.lastMotion = null;\n            operatorArgs.repeat = repeat; // For indent in visual mode.\n            operatorArgs.registerName = registerName;\n            operatorArgs.linewise = linewise;\n            var operatorMoveTo = operators[operator](cm, operatorArgs, cmSel.ranges, oldAnchor, newHead);\n            if (vim.visualMode) {\n                exitVisualMode(cm, operatorMoveTo != null);\n            }\n            if (operatorMoveTo) {\n                cm.setCursor(operatorMoveTo);\n            }\n        }\n    },\n    recordLastEdit: function (vim, inputState, actionCommand) {\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isPlaying) {\n            return;\n        }\n        vim.lastEditInputState = inputState;\n        vim.lastEditActionCommand = actionCommand;\n        macroModeState.lastInsertModeChanges.changes = [];\n        macroModeState.lastInsertModeChanges.expectCursorActivityForChange = false;\n        macroModeState.lastInsertModeChanges.visualBlock = vim.visualBlock ? vim.sel.head.line - vim.sel.anchor.line : 0;\n    }\n};\nvar motions = {\n    moveToTopLine: function (cm, _head, motionArgs) {\n        var line = getUserVisibleLines(cm).top + motionArgs.repeat - 1;\n        return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n    },\n    moveToMiddleLine: function (cm) {\n        var range = getUserVisibleLines(cm);\n        var line = Math.floor((range.top + range.bottom) * 0.5);\n        return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n    },\n    moveToBottomLine: function (cm, _head, motionArgs) {\n        var line = getUserVisibleLines(cm).bottom - motionArgs.repeat + 1;\n        return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n    },\n    expandToLine: function (_cm, head, motionArgs) {\n        var cur = head;\n        return new Pos(cur.line + motionArgs.repeat - 1, Infinity);\n    },\n    findNext: function (cm, _head, motionArgs) {\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n        if (!query) {\n            return;\n        }\n        var prev = !motionArgs.forward;\n        prev = (state.isReversed()) ? !prev : prev;\n        highlightSearchMatches(cm, query);\n        return findNext(cm, prev /** prev */, query, motionArgs.repeat);\n    },\n    findAndSelectNextInclusive: function (cm, _head, motionArgs, vim, prevInputState) {\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n        if (!query) {\n            return;\n        }\n        var prev = !motionArgs.forward;\n        prev = (state.isReversed()) ? !prev : prev;\n        var next = findNextFromAndToInclusive(cm, prev, query, motionArgs.repeat, vim);\n        if (!next) {\n            return;\n        }\n        if (prevInputState.operator) {\n            return next;\n        }\n        var from = next[0];\n        var to = new Pos(next[1].line, next[1].ch - 1);\n        if (vim.visualMode) {\n            if (vim.visualLine || vim.visualBlock) {\n                vim.visualLine = false;\n                vim.visualBlock = false;\n                CodeMirror.signal(cm, \"vim-mode-change\", { mode: \"visual\", subMode: \"\" });\n            }\n            var anchor = vim.sel.anchor;\n            if (anchor) {\n                if (state.isReversed()) {\n                    if (motionArgs.forward) {\n                        return [anchor, from];\n                    }\n                    return [anchor, to];\n                }\n                else {\n                    if (motionArgs.forward) {\n                        return [anchor, to];\n                    }\n                    return [anchor, from];\n                }\n            }\n        }\n        else {\n            vim.visualMode = true;\n            vim.visualLine = false;\n            vim.visualBlock = false;\n            CodeMirror.signal(cm, \"vim-mode-change\", { mode: \"visual\", subMode: \"\" });\n        }\n        return prev ? [to, from] : [from, to];\n    },\n    goToMark: function (cm, _head, motionArgs, vim) {\n        var pos = getMarkPos(cm, vim, motionArgs.selectedCharacter);\n        if (pos) {\n            return motionArgs.linewise ? { line: pos.line, ch: findFirstNonWhiteSpaceCharacter(cm.getLine(pos.line)) } : pos;\n        }\n        return null;\n    },\n    moveToOtherHighlightedEnd: function (cm, _head, motionArgs, vim) {\n        if (vim.visualBlock && motionArgs.sameLine) {\n            var sel = vim.sel;\n            return [\n                clipCursorToContent(cm, new Pos(sel.anchor.line, sel.head.ch)),\n                clipCursorToContent(cm, new Pos(sel.head.line, sel.anchor.ch))\n            ];\n        }\n        else {\n            return ([vim.sel.head, vim.sel.anchor]);\n        }\n    },\n    jumpToMark: function (cm, head, motionArgs, vim) {\n        var best = head;\n        for (var i = 0; i < motionArgs.repeat; i++) {\n            var cursor = best;\n            for (var key in vim.marks) {\n                if (!isLowerCase(key)) {\n                    continue;\n                }\n                var mark = vim.marks[key].find();\n                var isWrongDirection = (motionArgs.forward) ?\n                    cursorIsBefore(mark, cursor) : cursorIsBefore(cursor, mark);\n                if (isWrongDirection) {\n                    continue;\n                }\n                if (motionArgs.linewise && (mark.line == cursor.line)) {\n                    continue;\n                }\n                var equal = cursorEqual(cursor, best);\n                var between = (motionArgs.forward) ?\n                    cursorIsBetween(cursor, mark, best) :\n                    cursorIsBetween(best, mark, cursor);\n                if (equal || between) {\n                    best = mark;\n                }\n            }\n        }\n        if (motionArgs.linewise) {\n            best = new Pos(best.line, findFirstNonWhiteSpaceCharacter(cm.getLine(best.line)));\n        }\n        return best;\n    },\n    moveByCharacters: function (_cm, head, motionArgs) {\n        var cur = head;\n        var repeat = motionArgs.repeat;\n        var ch = motionArgs.forward ? cur.ch + repeat : cur.ch - repeat;\n        return new Pos(cur.line, ch);\n    },\n    moveByLines: function (cm, head, motionArgs, vim) {\n        var cur = head;\n        var endCh = cur.ch;\n        switch (vim.lastMotion) {\n            case this.moveByLines:\n            case this.moveByDisplayLines:\n            case this.moveByScroll:\n            case this.moveToColumn:\n            case this.moveToEol:\n                endCh = vim.lastHPos;\n                break;\n            default:\n                vim.lastHPos = endCh;\n        }\n        var repeat = motionArgs.repeat + (motionArgs.repeatOffset || 0);\n        var line = motionArgs.forward ? cur.line + repeat : cur.line - repeat;\n        var first = cm.firstLine();\n        var last = cm.lastLine();\n        if (line < first && cur.line == first) {\n            return this.moveToStartOfLine(cm, head, motionArgs, vim);\n        }\n        else if (line > last && cur.line == last) {\n            return moveToEol(cm, head, motionArgs, vim, true);\n        }\n        var fold = cm.ace.session.getFoldLine(line);\n        if (fold) {\n            if (motionArgs.forward) {\n                if (line > fold.start.row)\n                    line = fold.end.row + 1;\n            }\n            else {\n                line = fold.start.row;\n            }\n        }\n        if (motionArgs.toFirstChar) {\n            endCh = findFirstNonWhiteSpaceCharacter(cm.getLine(line));\n            vim.lastHPos = endCh;\n        }\n        vim.lastHSPos = cm.charCoords(new Pos(line, endCh), 'div').left;\n        return new Pos(line, endCh);\n    },\n    moveByDisplayLines: function (cm, head, motionArgs, vim) {\n        var cur = head;\n        switch (vim.lastMotion) {\n            case this.moveByDisplayLines:\n            case this.moveByScroll:\n            case this.moveByLines:\n            case this.moveToColumn:\n            case this.moveToEol:\n                break;\n            default:\n                vim.lastHSPos = cm.charCoords(cur, 'div').left;\n        }\n        var repeat = motionArgs.repeat;\n        var res = cm.findPosV(cur, (motionArgs.forward ? repeat : -repeat), 'line', vim.lastHSPos);\n        if (res.hitSide) {\n            if (motionArgs.forward) {\n                var lastCharCoords = cm.charCoords(res, 'div');\n                var goalCoords = { top: lastCharCoords.top + 8, left: vim.lastHSPos };\n                var res = cm.coordsChar(goalCoords, 'div');\n            }\n            else {\n                var resCoords = cm.charCoords(new Pos(cm.firstLine(), 0), 'div');\n                resCoords.left = vim.lastHSPos;\n                res = cm.coordsChar(resCoords, 'div');\n            }\n        }\n        vim.lastHPos = res.ch;\n        return res;\n    },\n    moveByPage: function (cm, head, motionArgs) {\n        var curStart = head;\n        var repeat = motionArgs.repeat;\n        return cm.findPosV(curStart, (motionArgs.forward ? repeat : -repeat), 'page');\n    },\n    moveByParagraph: function (cm, head, motionArgs) {\n        var dir = motionArgs.forward ? 1 : -1;\n        return findParagraph(cm, head, motionArgs.repeat, dir);\n    },\n    moveBySentence: function (cm, head, motionArgs) {\n        var dir = motionArgs.forward ? 1 : -1;\n        return findSentence(cm, head, motionArgs.repeat, dir);\n    },\n    moveByScroll: function (cm, head, motionArgs, vim) {\n        var scrollbox = cm.getScrollInfo();\n        var curEnd = null;\n        var repeat = motionArgs.repeat;\n        if (!repeat) {\n            repeat = scrollbox.clientHeight / (2 * cm.defaultTextHeight());\n        }\n        var orig = cm.charCoords(head, 'local');\n        motionArgs.repeat = repeat;\n        curEnd = motions.moveByDisplayLines(cm, head, motionArgs, vim);\n        if (!curEnd) {\n            return null;\n        }\n        var dest = cm.charCoords(curEnd, 'local');\n        cm.scrollTo(null, scrollbox.top + dest.top - orig.top);\n        return curEnd;\n    },\n    moveByWords: function (cm, head, motionArgs) {\n        return moveToWord(cm, head, motionArgs.repeat, !!motionArgs.forward, !!motionArgs.wordEnd, !!motionArgs.bigWord);\n    },\n    moveTillCharacter: function (cm, _head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        var curEnd = moveToCharacter(cm, repeat, motionArgs.forward, motionArgs.selectedCharacter);\n        var increment = motionArgs.forward ? -1 : 1;\n        recordLastCharacterSearch(increment, motionArgs);\n        if (!curEnd)\n            return null;\n        curEnd.ch += increment;\n        return curEnd;\n    },\n    moveToCharacter: function (cm, head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        recordLastCharacterSearch(0, motionArgs);\n        return moveToCharacter(cm, repeat, motionArgs.forward, motionArgs.selectedCharacter) || head;\n    },\n    moveToSymbol: function (cm, head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        return findSymbol(cm, repeat, motionArgs.forward, motionArgs.selectedCharacter) || head;\n    },\n    moveToColumn: function (cm, head, motionArgs, vim) {\n        var repeat = motionArgs.repeat;\n        vim.lastHPos = repeat - 1;\n        vim.lastHSPos = cm.charCoords(head, 'div').left;\n        return moveToColumn(cm, repeat);\n    },\n    moveToEol: function (cm, head, motionArgs, vim) {\n        return moveToEol(cm, head, motionArgs, vim, false);\n    },\n    moveToFirstNonWhiteSpaceCharacter: function (cm, head) {\n        var cursor = head;\n        return new Pos(cursor.line, findFirstNonWhiteSpaceCharacter(cm.getLine(cursor.line)));\n    },\n    moveToMatchedSymbol: function (cm, head) {\n        var cursor = head;\n        var line = cursor.line;\n        var ch = cursor.ch;\n        var lineText = cm.getLine(line);\n        var symbol;\n        for (; ch < lineText.length; ch++) {\n            symbol = lineText.charAt(ch);\n            if (symbol && isMatchableSymbol(symbol)) {\n                var style = cm.getTokenTypeAt(new Pos(line, ch + 1));\n                if (style !== \"string\" && style !== \"comment\") {\n                    break;\n                }\n            }\n        }\n        if (ch < lineText.length) {\n            var re = /[<>]/.test(lineText[ch]) ? /[(){}[\\]<>]/ : /[(){}[\\]]/; //ace_patch?\n            var matched = cm.findMatchingBracket(new Pos(line, ch + 1), { bracketRegex: re });\n            return matched.to;\n        }\n        else {\n            return cursor;\n        }\n    },\n    moveToStartOfLine: function (_cm, head) {\n        return new Pos(head.line, 0);\n    },\n    moveToLineOrEdgeOfDocument: function (cm, _head, motionArgs) {\n        var lineNum = motionArgs.forward ? cm.lastLine() : cm.firstLine();\n        if (motionArgs.repeatIsExplicit) {\n            lineNum = motionArgs.repeat - cm.getOption('firstLineNumber');\n        }\n        return new Pos(lineNum, findFirstNonWhiteSpaceCharacter(cm.getLine(lineNum)));\n    },\n    moveToStartOfDisplayLine: function (cm) {\n        cm.execCommand(\"goLineLeft\");\n        return cm.getCursor();\n    },\n    moveToEndOfDisplayLine: function (cm) {\n        cm.execCommand(\"goLineRight\");\n        var head = cm.getCursor();\n        if (head.sticky == \"before\")\n            head.ch--;\n        return head;\n    },\n    textObjectManipulation: function (cm, head, motionArgs, vim) {\n        var mirroredPairs = { '(': ')', ')': '(',\n            '{': '}', '}': '{',\n            '[': ']', ']': '[',\n            '<': '>', '>': '<' };\n        var selfPaired = { '\\'': true, '\"': true, '`': true };\n        var character = motionArgs.selectedCharacter;\n        if (character == 'b') {\n            character = '(';\n        }\n        else if (character == 'B') {\n            character = '{';\n        }\n        var inclusive = !motionArgs.textObjectInner;\n        var tmp;\n        if (mirroredPairs[character]) {\n            tmp = selectCompanionObject(cm, head, character, inclusive);\n        }\n        else if (selfPaired[character]) {\n            tmp = findBeginningAndEnd(cm, head, character, inclusive);\n        }\n        else if (character === 'W') {\n            tmp = expandWordUnderCursor(cm, inclusive, true /** forward */, true /** bigWord */);\n        }\n        else if (character === 'w') {\n            tmp = expandWordUnderCursor(cm, inclusive, true /** forward */, false /** bigWord */);\n        }\n        else if (character === 'p') {\n            tmp = findParagraph(cm, head, motionArgs.repeat, 0, inclusive);\n            motionArgs.linewise = true;\n            if (vim.visualMode) {\n                if (!vim.visualLine) {\n                    vim.visualLine = true;\n                }\n            }\n            else {\n                var operatorArgs = vim.inputState.operatorArgs;\n                if (operatorArgs) {\n                    operatorArgs.linewise = true;\n                }\n                tmp.end.line--;\n            }\n        }\n        else if (character === 't') {\n            tmp = expandTagUnderCursor(cm, head, inclusive);\n        }\n        else if (character === 's') {\n            var content = cm.getLine(head.line);\n            if (head.ch > 0 && isEndOfSentenceSymbol(content[head.ch])) {\n                head.ch -= 1;\n            }\n            var end = getSentence(cm, head, motionArgs.repeat, 1, inclusive);\n            var start = getSentence(cm, head, motionArgs.repeat, -1, inclusive);\n            if (isWhiteSpaceString(cm.getLine(start.line)[start.ch])\n                && isWhiteSpaceString(cm.getLine(end.line)[end.ch - 1])) {\n                start = { line: start.line, ch: start.ch + 1 };\n            }\n            tmp = { start: start, end: end };\n        }\n        else {\n            return null;\n        }\n        if (!cm.state.vim.visualMode) {\n            return [tmp.start, tmp.end];\n        }\n        else {\n            return expandSelection(cm, tmp.start, tmp.end);\n        }\n    },\n    repeatLastCharacterSearch: function (cm, head, motionArgs) {\n        var lastSearch = vimGlobalState.lastCharacterSearch;\n        var repeat = motionArgs.repeat;\n        var forward = motionArgs.forward === lastSearch.forward;\n        var increment = (lastSearch.increment ? 1 : 0) * (forward ? -1 : 1);\n        cm.moveH(-increment, 'char');\n        motionArgs.inclusive = forward ? true : false;\n        var curEnd = moveToCharacter(cm, repeat, forward, lastSearch.selectedCharacter);\n        if (!curEnd) {\n            cm.moveH(increment, 'char');\n            return head;\n        }\n        curEnd.ch += increment;\n        return curEnd;\n    }\n};\nfunction defineMotion(name, fn) {\n    motions[name] = fn;\n}\nfunction fillArray(val, times) {\n    var arr = [];\n    for (var i = 0; i < times; i++) {\n        arr.push(val);\n    }\n    return arr;\n}\nvar operators = {\n    change: function (cm, args, ranges) {\n        var finalHead, text;\n        var vim = cm.state.vim;\n        var anchor = ranges[0].anchor, head = ranges[0].head;\n        if (!vim.visualMode) {\n            text = cm.getRange(anchor, head);\n            var lastState = vim.lastEditInputState || {};\n            if (lastState.motion == \"moveByWords\" && !isWhiteSpaceString(text)) {\n                var match = (/\\s+$/).exec(text);\n                if (match && lastState.motionArgs && lastState.motionArgs.forward) {\n                    head = offsetCursor(head, 0, -match[0].length);\n                    text = text.slice(0, -match[0].length);\n                }\n            }\n            var prevLineEnd = new Pos(anchor.line - 1, Number.MAX_VALUE);\n            var wasLastLine = cm.firstLine() == cm.lastLine();\n            if (head.line > cm.lastLine() && args.linewise && !wasLastLine) {\n                cm.replaceRange('', prevLineEnd, head);\n            }\n            else {\n                cm.replaceRange('', anchor, head);\n            }\n            if (args.linewise) {\n                if (!wasLastLine) {\n                    cm.setCursor(prevLineEnd);\n                    CodeMirror.commands.newlineAndIndent(cm);\n                }\n                anchor.ch = Number.MAX_VALUE;\n            }\n            finalHead = anchor;\n        }\n        else if (args.fullLine) {\n            head.ch = Number.MAX_VALUE;\n            head.line--;\n            cm.setSelection(anchor, head);\n            text = cm.getSelection();\n            cm.replaceSelection(\"\");\n            finalHead = anchor;\n        }\n        else {\n            text = cm.getSelection();\n            var replacement = fillArray('', ranges.length);\n            cm.replaceSelections(replacement);\n            finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\n        }\n        vimGlobalState.registerController.pushText(args.registerName, 'change', text, args.linewise, ranges.length > 1);\n        actions.enterInsertMode(cm, { head: finalHead }, cm.state.vim);\n    },\n    'delete': function (cm, args, ranges) {\n        var finalHead, text;\n        var vim = cm.state.vim;\n        if (!vim.visualBlock) {\n            var anchor = ranges[0].anchor, head = ranges[0].head;\n            if (args.linewise &&\n                head.line != cm.firstLine() &&\n                anchor.line == cm.lastLine() &&\n                anchor.line == head.line - 1) {\n                if (anchor.line == cm.firstLine()) {\n                    anchor.ch = 0;\n                }\n                else {\n                    anchor = new Pos(anchor.line - 1, lineLength(cm, anchor.line - 1));\n                }\n            }\n            text = cm.getRange(anchor, head);\n            cm.replaceRange('', anchor, head);\n            finalHead = anchor;\n            if (args.linewise) {\n                finalHead = motions.moveToFirstNonWhiteSpaceCharacter(cm, anchor);\n            }\n        }\n        else {\n            text = cm.getSelection();\n            var replacement = fillArray('', ranges.length);\n            cm.replaceSelections(replacement);\n            finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\n        }\n        vimGlobalState.registerController.pushText(args.registerName, 'delete', text, args.linewise, vim.visualBlock);\n        return clipCursorToContent(cm, finalHead);\n    },\n    indent: function (cm, args, ranges) {\n        var vim = cm.state.vim;\n        if (cm.indentMore) {\n            var repeat = (vim.visualMode) ? args.repeat : 1;\n            for (var j = 0; j < repeat; j++) {\n                if (args.indentRight)\n                    cm.indentMore();\n                else\n                    cm.indentLess();\n            }\n        }\n        else {\n            var startLine = ranges[0].anchor.line;\n            var endLine = vim.visualBlock ?\n                ranges[ranges.length - 1].anchor.line :\n                ranges[0].head.line;\n            var repeat = (vim.visualMode) ? args.repeat : 1;\n            if (args.linewise) {\n                endLine--;\n            }\n            for (var i = startLine; i <= endLine; i++) {\n                for (var j = 0; j < repeat; j++) {\n                    cm.indentLine(i, args.indentRight);\n                }\n            }\n        }\n        return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n    },\n    indentAuto: function (cm, _args, ranges) {\n        if (ranges.length > 1) { // ace_patch\n            cm.setSelection(ranges[0].anchor, ranges[ranges.length - 1].head);\n        }\n        cm.execCommand(\"indentAuto\");\n        return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n    },\n    changeCase: function (cm, args, ranges, oldAnchor, newHead) {\n        var selections = cm.getSelections();\n        var swapped = [];\n        var toLower = args.toLower;\n        for (var j = 0; j < selections.length; j++) {\n            var toSwap = selections[j];\n            var text = '';\n            if (toLower === true) {\n                text = toSwap.toLowerCase();\n            }\n            else if (toLower === false) {\n                text = toSwap.toUpperCase();\n            }\n            else {\n                for (var i = 0; i < toSwap.length; i++) {\n                    var character = toSwap.charAt(i);\n                    text += isUpperCase(character) ? character.toLowerCase() :\n                        character.toUpperCase();\n                }\n            }\n            swapped.push(text);\n        }\n        cm.replaceSelections(swapped);\n        if (args.shouldMoveCursor) {\n            return newHead;\n        }\n        else if (!cm.state.vim.visualMode && args.linewise && ranges[0].anchor.line + 1 == ranges[0].head.line) {\n            return motions.moveToFirstNonWhiteSpaceCharacter(cm, oldAnchor);\n        }\n        else if (args.linewise) {\n            return oldAnchor;\n        }\n        else {\n            return cursorMin(ranges[0].anchor, ranges[0].head);\n        }\n    },\n    yank: function (cm, args, ranges, oldAnchor) {\n        var vim = cm.state.vim;\n        var text = cm.getSelection();\n        var endPos = vim.visualMode\n            ? cursorMin(vim.sel.anchor, vim.sel.head, ranges[0].head, ranges[0].anchor)\n            : oldAnchor;\n        vimGlobalState.registerController.pushText(args.registerName, 'yank', text, args.linewise, vim.visualBlock);\n        return endPos;\n    }\n};\nfunction defineOperator(name, fn) {\n    operators[name] = fn;\n}\nvar actions = {\n    jumpListWalk: function (cm, actionArgs, vim) {\n        if (vim.visualMode) {\n            return;\n        }\n        var repeat = actionArgs.repeat;\n        var forward = actionArgs.forward;\n        var jumpList = vimGlobalState.jumpList;\n        var mark = jumpList.move(cm, forward ? repeat : -repeat);\n        var markPos = mark ? mark.find() : undefined;\n        markPos = markPos ? markPos : cm.getCursor();\n        cm.setCursor(markPos);\n        cm.ace.curOp.command.scrollIntoView = \"center-animate\"; // ace_patch\n    },\n    scroll: function (cm, actionArgs, vim) {\n        if (vim.visualMode) {\n            return;\n        }\n        var repeat = actionArgs.repeat || 1;\n        var lineHeight = cm.defaultTextHeight();\n        var top = cm.getScrollInfo().top;\n        var delta = lineHeight * repeat;\n        var newPos = actionArgs.forward ? top + delta : top - delta;\n        var cursor = copyCursor(cm.getCursor());\n        var cursorCoords = cm.charCoords(cursor, 'local');\n        if (actionArgs.forward) {\n            if (newPos > cursorCoords.top) {\n                cursor.line += (newPos - cursorCoords.top) / lineHeight;\n                cursor.line = Math.ceil(cursor.line);\n                cm.setCursor(cursor);\n                cursorCoords = cm.charCoords(cursor, 'local');\n                cm.scrollTo(null, cursorCoords.top);\n            }\n            else {\n                cm.scrollTo(null, newPos);\n            }\n        }\n        else {\n            var newBottom = newPos + cm.getScrollInfo().clientHeight;\n            if (newBottom < cursorCoords.bottom) {\n                cursor.line -= (cursorCoords.bottom - newBottom) / lineHeight;\n                cursor.line = Math.floor(cursor.line);\n                cm.setCursor(cursor);\n                cursorCoords = cm.charCoords(cursor, 'local');\n                cm.scrollTo(null, cursorCoords.bottom - cm.getScrollInfo().clientHeight);\n            }\n            else {\n                cm.scrollTo(null, newPos);\n            }\n        }\n    },\n    scrollToCursor: function (cm, actionArgs) {\n        var lineNum = cm.getCursor().line;\n        var charCoords = cm.charCoords(new Pos(lineNum, 0), 'local');\n        var height = cm.getScrollInfo().clientHeight;\n        var y = charCoords.top;\n        switch (actionArgs.position) {\n            case 'center':\n                y = charCoords.bottom - height / 2;\n                break;\n            case 'bottom':\n                var lineLastCharPos = new Pos(lineNum, cm.getLine(lineNum).length - 1);\n                var lineLastCharCoords = cm.charCoords(lineLastCharPos, 'local');\n                var lineHeight = lineLastCharCoords.bottom - y;\n                y = y - height + lineHeight;\n                break;\n        }\n        cm.scrollTo(null, y);\n    },\n    replayMacro: function (cm, actionArgs, vim) {\n        var registerName = actionArgs.selectedCharacter;\n        var repeat = actionArgs.repeat;\n        var macroModeState = vimGlobalState.macroModeState;\n        if (registerName == '@') {\n            registerName = macroModeState.latestRegister;\n        }\n        else {\n            macroModeState.latestRegister = registerName;\n        }\n        while (repeat--) {\n            executeMacroRegister(cm, vim, macroModeState, registerName);\n        }\n    },\n    enterMacroRecordMode: function (cm, actionArgs) {\n        var macroModeState = vimGlobalState.macroModeState;\n        var registerName = actionArgs.selectedCharacter;\n        if (vimGlobalState.registerController.isValidRegister(registerName)) {\n            macroModeState.enterMacroRecordMode(cm, registerName);\n        }\n    },\n    toggleOverwrite: function (cm) {\n        if (!cm.state.overwrite) {\n            cm.toggleOverwrite(true);\n            cm.setOption('keyMap', 'vim-replace');\n            CodeMirror.signal(cm, \"vim-mode-change\", { mode: \"replace\" });\n        }\n        else {\n            cm.toggleOverwrite(false);\n            cm.setOption('keyMap', 'vim-insert');\n            CodeMirror.signal(cm, \"vim-mode-change\", { mode: \"insert\" });\n        }\n    },\n    enterInsertMode: function (cm, actionArgs, vim) {\n        if (cm.getOption('readOnly')) {\n            return;\n        }\n        vim.insertMode = true;\n        vim.insertModeRepeat = actionArgs && actionArgs.repeat || 1;\n        var insertAt = (actionArgs) ? actionArgs.insertAt : null;\n        var sel = vim.sel;\n        var head = actionArgs.head || cm.getCursor('head');\n        var height = cm.listSelections().length;\n        if (insertAt == 'eol') {\n            head = new Pos(head.line, lineLength(cm, head.line));\n        }\n        else if (insertAt == 'bol') {\n            head = new Pos(head.line, 0);\n        }\n        else if (insertAt == 'charAfter') {\n            var newPosition = updateSelectionForSurrogateCharacters(cm, head, offsetCursor(head, 0, 1));\n            head = newPosition.end;\n        }\n        else if (insertAt == 'firstNonBlank') {\n            var newPosition = updateSelectionForSurrogateCharacters(cm, head, motions.moveToFirstNonWhiteSpaceCharacter(cm, head));\n            head = newPosition.end;\n        }\n        else if (insertAt == 'startOfSelectedArea') {\n            if (!vim.visualMode)\n                return;\n            if (!vim.visualBlock) {\n                if (sel.head.line < sel.anchor.line) {\n                    head = sel.head;\n                }\n                else {\n                    head = new Pos(sel.anchor.line, 0);\n                }\n            }\n            else {\n                head = new Pos(Math.min(sel.head.line, sel.anchor.line), Math.min(sel.head.ch, sel.anchor.ch));\n                height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n            }\n        }\n        else if (insertAt == 'endOfSelectedArea') {\n            if (!vim.visualMode)\n                return;\n            if (!vim.visualBlock) {\n                if (sel.head.line >= sel.anchor.line) {\n                    head = offsetCursor(sel.head, 0, 1);\n                }\n                else {\n                    head = new Pos(sel.anchor.line, 0);\n                }\n            }\n            else {\n                head = new Pos(Math.min(sel.head.line, sel.anchor.line), Math.max(sel.head.ch, sel.anchor.ch) + 1);\n                height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n            }\n        }\n        else if (insertAt == 'inplace') {\n            if (vim.visualMode) {\n                return;\n            }\n        }\n        else if (insertAt == 'lastEdit') {\n            head = getLastEditPos(cm) || head;\n        }\n        cm.setOption('disableInput', false);\n        if (actionArgs && actionArgs.replace) {\n            cm.toggleOverwrite(true);\n            cm.setOption('keyMap', 'vim-replace');\n            CodeMirror.signal(cm, \"vim-mode-change\", { mode: \"replace\" });\n        }\n        else {\n            cm.toggleOverwrite(false);\n            cm.setOption('keyMap', 'vim-insert');\n            CodeMirror.signal(cm, \"vim-mode-change\", { mode: \"insert\" });\n        }\n        if (!vimGlobalState.macroModeState.isPlaying) {\n            cm.on('change', onChange);\n            CodeMirror.on(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n        }\n        if (vim.visualMode) {\n            exitVisualMode(cm);\n        }\n        selectForInsert(cm, head, height);\n    },\n    toggleVisualMode: function (cm, actionArgs, vim) {\n        var repeat = actionArgs.repeat;\n        var anchor = cm.getCursor();\n        var head;\n        if (!vim.visualMode) {\n            vim.visualMode = true;\n            vim.visualLine = !!actionArgs.linewise;\n            vim.visualBlock = !!actionArgs.blockwise;\n            head = clipCursorToContent(cm, new Pos(anchor.line, anchor.ch + repeat - 1));\n            var newPosition = updateSelectionForSurrogateCharacters(cm, anchor, head);\n            vim.sel = {\n                anchor: newPosition.start,\n                head: newPosition.end\n            };\n            CodeMirror.signal(cm, \"vim-mode-change\", { mode: \"visual\", subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\" });\n            updateCmSelection(cm);\n            updateMark(cm, vim, '<', cursorMin(anchor, head));\n            updateMark(cm, vim, '>', cursorMax(anchor, head));\n        }\n        else if (vim.visualLine ^ actionArgs.linewise ||\n            vim.visualBlock ^ actionArgs.blockwise) {\n            vim.visualLine = !!actionArgs.linewise;\n            vim.visualBlock = !!actionArgs.blockwise;\n            CodeMirror.signal(cm, \"vim-mode-change\", { mode: \"visual\", subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\" });\n            updateCmSelection(cm);\n        }\n        else {\n            exitVisualMode(cm);\n        }\n    },\n    reselectLastSelection: function (cm, _actionArgs, vim) {\n        var lastSelection = vim.lastSelection;\n        if (vim.visualMode) {\n            updateLastSelection(cm, vim);\n        }\n        if (lastSelection) {\n            var anchor = lastSelection.anchorMark.find();\n            var head = lastSelection.headMark.find();\n            if (!anchor || !head) {\n                return;\n            }\n            vim.sel = {\n                anchor: anchor,\n                head: head\n            };\n            vim.visualMode = true;\n            vim.visualLine = lastSelection.visualLine;\n            vim.visualBlock = lastSelection.visualBlock;\n            updateCmSelection(cm);\n            updateMark(cm, vim, '<', cursorMin(anchor, head));\n            updateMark(cm, vim, '>', cursorMax(anchor, head));\n            CodeMirror.signal(cm, 'vim-mode-change', {\n                mode: 'visual',\n                subMode: vim.visualLine ? 'linewise' :\n                    vim.visualBlock ? 'blockwise' : ''\n            });\n        }\n    },\n    joinLines: function (cm, actionArgs, vim) {\n        var curStart, curEnd;\n        if (vim.visualMode) {\n            curStart = cm.getCursor('anchor');\n            curEnd = cm.getCursor('head');\n            if (cursorIsBefore(curEnd, curStart)) {\n                var tmp = curEnd;\n                curEnd = curStart;\n                curStart = tmp;\n            }\n            curEnd.ch = lineLength(cm, curEnd.line) - 1;\n        }\n        else {\n            var repeat = Math.max(actionArgs.repeat, 2);\n            curStart = cm.getCursor();\n            curEnd = clipCursorToContent(cm, new Pos(curStart.line + repeat - 1, Infinity));\n        }\n        var finalCh = 0;\n        for (var i = curStart.line; i < curEnd.line; i++) {\n            finalCh = lineLength(cm, curStart.line);\n            var text = '';\n            var nextStartCh = 0;\n            if (!actionArgs.keepSpaces) {\n                var nextLine = cm.getLine(curStart.line + 1);\n                nextStartCh = nextLine.search(/\\S/);\n                if (nextStartCh == -1) {\n                    nextStartCh = nextLine.length;\n                }\n                else {\n                    text = \" \";\n                }\n            }\n            cm.replaceRange(text, new Pos(curStart.line, finalCh), new Pos(curStart.line + 1, nextStartCh));\n        }\n        var curFinalPos = clipCursorToContent(cm, new Pos(curStart.line, finalCh));\n        if (vim.visualMode) {\n            exitVisualMode(cm, false);\n        }\n        cm.setCursor(curFinalPos);\n    },\n    newLineAndEnterInsertMode: function (cm, actionArgs, vim) {\n        vim.insertMode = true;\n        var insertAt = copyCursor(cm.getCursor());\n        if (insertAt.line === cm.firstLine() && !actionArgs.after) {\n            cm.replaceRange('\\n', new Pos(cm.firstLine(), 0));\n            cm.setCursor(cm.firstLine(), 0);\n        }\n        else {\n            insertAt.line = (actionArgs.after) ? insertAt.line :\n                insertAt.line - 1;\n            insertAt.ch = lineLength(cm, insertAt.line);\n            cm.setCursor(insertAt);\n            var newlineFn = CodeMirror.commands.newlineAndIndentContinueComment ||\n                CodeMirror.commands.newlineAndIndent;\n            newlineFn(cm);\n        }\n        this.enterInsertMode(cm, { repeat: actionArgs.repeat }, vim);\n    },\n    paste: function (cm, actionArgs, vim) {\n        var _this = this;\n        var register = vimGlobalState.registerController.getRegister(actionArgs.registerName);\n        var fallback = function () {\n            var text = register.toString();\n            _this.continuePaste(cm, actionArgs, vim, text, register);\n        };\n        if (actionArgs.registerName === '+' &&\n            typeof navigator !== 'undefined' &&\n            typeof navigator.clipboard !== 'undefined' &&\n            typeof navigator.clipboard.readText === 'function') {\n            navigator.clipboard.readText().then(function (value) {\n                _this.continuePaste(cm, actionArgs, vim, value, register);\n            }, function () { fallback(); });\n        }\n        else {\n            fallback();\n        }\n    },\n    continuePaste: function (cm, actionArgs, vim, text, register) {\n        var cur = copyCursor(cm.getCursor());\n        if (!text) {\n            return;\n        }\n        if (actionArgs.matchIndent) {\n            var tabSize = cm.getOption(\"tabSize\");\n            var whitespaceLength = function (str) {\n                var tabs = (str.split(\"\\t\").length - 1);\n                var spaces = (str.split(\" \").length - 1);\n                return tabs * tabSize + spaces * 1;\n            };\n            var currentLine = cm.getLine(cm.getCursor().line);\n            var indent = whitespaceLength(currentLine.match(/^\\s*/)[0]);\n            var chompedText = text.replace(/\\n$/, '');\n            var wasChomped = text !== chompedText;\n            var firstIndent = whitespaceLength(text.match(/^\\s*/)[0]);\n            var text = chompedText.replace(/^\\s*/gm, function (wspace) {\n                var newIndent = indent + (whitespaceLength(wspace) - firstIndent);\n                if (newIndent < 0) {\n                    return \"\";\n                }\n                else if (cm.getOption(\"indentWithTabs\")) {\n                    var quotient = Math.floor(newIndent / tabSize);\n                    return Array(quotient + 1).join('\\t');\n                }\n                else {\n                    return Array(newIndent + 1).join(' ');\n                }\n            });\n            text += wasChomped ? \"\\n\" : \"\";\n        }\n        if (actionArgs.repeat > 1) {\n            var text = Array(actionArgs.repeat + 1).join(text);\n        }\n        var linewise = register.linewise;\n        var blockwise = register.blockwise;\n        if (blockwise) {\n            text = text.split('\\n');\n            if (linewise) {\n                text.pop();\n            }\n            for (var i = 0; i < text.length; i++) {\n                text[i] = (text[i] == '') ? ' ' : text[i];\n            }\n            cur.ch += actionArgs.after ? 1 : 0;\n            cur.ch = Math.min(lineLength(cm, cur.line), cur.ch);\n        }\n        else if (linewise) {\n            if (vim.visualMode) {\n                text = vim.visualLine ? text.slice(0, -1) : '\\n' + text.slice(0, text.length - 1) + '\\n';\n            }\n            else if (actionArgs.after) {\n                text = '\\n' + text.slice(0, text.length - 1);\n                cur.ch = lineLength(cm, cur.line);\n            }\n            else {\n                cur.ch = 0;\n            }\n        }\n        else {\n            cur.ch += actionArgs.after ? 1 : 0;\n        }\n        var curPosFinal;\n        var idx;\n        if (vim.visualMode) {\n            vim.lastPastedText = text;\n            var lastSelectionCurEnd;\n            var selectedArea = getSelectedAreaRange(cm, vim);\n            var selectionStart = selectedArea[0];\n            var selectionEnd = selectedArea[1];\n            var selectedText = cm.getSelection();\n            var selections = cm.listSelections();\n            var emptyStrings = new Array(selections.length).join('1').split('1');\n            if (vim.lastSelection) {\n                lastSelectionCurEnd = vim.lastSelection.headMark.find();\n            }\n            vimGlobalState.registerController.unnamedRegister.setText(selectedText);\n            if (blockwise) {\n                cm.replaceSelections(emptyStrings);\n                selectionEnd = new Pos(selectionStart.line + text.length - 1, selectionStart.ch);\n                cm.setCursor(selectionStart);\n                selectBlock(cm, selectionEnd);\n                cm.replaceSelections(text);\n                curPosFinal = selectionStart;\n            }\n            else if (vim.visualBlock) {\n                cm.replaceSelections(emptyStrings);\n                cm.setCursor(selectionStart);\n                cm.replaceRange(text, selectionStart, selectionStart);\n                curPosFinal = selectionStart;\n            }\n            else {\n                cm.replaceRange(text, selectionStart, selectionEnd);\n                curPosFinal = cm.posFromIndex(cm.indexFromPos(selectionStart) + text.length - 1);\n            }\n            if (lastSelectionCurEnd) {\n                vim.lastSelection.headMark = cm.setBookmark(lastSelectionCurEnd);\n            }\n            if (linewise) {\n                curPosFinal.ch = 0;\n            }\n        }\n        else {\n            if (blockwise) {\n                cm.setCursor(cur);\n                for (var i = 0; i < text.length; i++) {\n                    var line = cur.line + i;\n                    if (line > cm.lastLine()) {\n                        cm.replaceRange('\\n', new Pos(line, 0));\n                    }\n                    var lastCh = lineLength(cm, line);\n                    if (lastCh < cur.ch) {\n                        extendLineToColumn(cm, line, cur.ch);\n                    }\n                }\n                cm.setCursor(cur);\n                selectBlock(cm, new Pos(cur.line + text.length - 1, cur.ch));\n                cm.replaceSelections(text);\n                curPosFinal = cur;\n            }\n            else {\n                cm.replaceRange(text, cur);\n                if (linewise && actionArgs.after) {\n                    curPosFinal = new Pos(cur.line + 1, findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line + 1)));\n                }\n                else if (linewise && !actionArgs.after) {\n                    curPosFinal = new Pos(cur.line, findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line)));\n                }\n                else if (!linewise && actionArgs.after) {\n                    idx = cm.indexFromPos(cur);\n                    curPosFinal = cm.posFromIndex(idx + text.length - 1);\n                }\n                else {\n                    idx = cm.indexFromPos(cur);\n                    curPosFinal = cm.posFromIndex(idx + text.length);\n                }\n            }\n        }\n        if (vim.visualMode) {\n            exitVisualMode(cm, false);\n        }\n        cm.setCursor(curPosFinal);\n    },\n    undo: function (cm, actionArgs) {\n        cm.operation(function () {\n            repeatFn(cm, CodeMirror.commands.undo, actionArgs.repeat)();\n            cm.setCursor(clipCursorToContent(cm, cm.getCursor('start')));\n        });\n    },\n    redo: function (cm, actionArgs) {\n        repeatFn(cm, CodeMirror.commands.redo, actionArgs.repeat)();\n    },\n    setRegister: function (_cm, actionArgs, vim) {\n        vim.inputState.registerName = actionArgs.selectedCharacter;\n    },\n    setMark: function (cm, actionArgs, vim) {\n        var markName = actionArgs.selectedCharacter;\n        updateMark(cm, vim, markName, cm.getCursor());\n    },\n    replace: function (cm, actionArgs, vim) {\n        var replaceWith = actionArgs.selectedCharacter;\n        var curStart = cm.getCursor();\n        var replaceTo;\n        var curEnd;\n        var selections = cm.listSelections();\n        if (vim.visualMode) {\n            curStart = cm.getCursor('start');\n            curEnd = cm.getCursor('end');\n        }\n        else {\n            var line = cm.getLine(curStart.line);\n            replaceTo = curStart.ch + actionArgs.repeat;\n            if (replaceTo > line.length) {\n                replaceTo = line.length;\n            }\n            curEnd = new Pos(curStart.line, replaceTo);\n        }\n        var newPositions = updateSelectionForSurrogateCharacters(cm, curStart, curEnd);\n        curStart = newPositions.start;\n        curEnd = newPositions.end;\n        if (replaceWith == '\\n') {\n            if (!vim.visualMode)\n                cm.replaceRange('', curStart, curEnd);\n            (CodeMirror.commands.newlineAndIndentContinueComment || CodeMirror.commands.newlineAndIndent)(cm);\n        }\n        else {\n            var replaceWithStr = cm.getRange(curStart, curEnd);\n            replaceWithStr = replaceWithStr.replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, replaceWith);\n            replaceWithStr = replaceWithStr.replace(/[^\\n]/g, replaceWith);\n            if (vim.visualBlock) {\n                var spaces = new Array(cm.getOption(\"tabSize\") + 1).join(' ');\n                replaceWithStr = cm.getSelection();\n                replaceWithStr = replaceWithStr.replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, replaceWith);\n                replaceWithStr = replaceWithStr.replace(/\\t/g, spaces).replace(/[^\\n]/g, replaceWith).split('\\n');\n                cm.replaceSelections(replaceWithStr);\n            }\n            else {\n                cm.replaceRange(replaceWithStr, curStart, curEnd);\n            }\n            if (vim.visualMode) {\n                curStart = cursorIsBefore(selections[0].anchor, selections[0].head) ?\n                    selections[0].anchor : selections[0].head;\n                cm.setCursor(curStart);\n                exitVisualMode(cm, false);\n            }\n            else {\n                cm.setCursor(offsetCursor(curEnd, 0, -1));\n            }\n        }\n    },\n    incrementNumberToken: function (cm, actionArgs) {\n        var cur = cm.getCursor();\n        var lineStr = cm.getLine(cur.line);\n        var re = /(-?)(?:(0x)([\\da-f]+)|(0b|0|)(\\d+))/gi;\n        var match;\n        var start;\n        var end;\n        var numberStr;\n        while ((match = re.exec(lineStr)) !== null) {\n            start = match.index;\n            end = start + match[0].length;\n            if (cur.ch < end)\n                break;\n        }\n        if (!actionArgs.backtrack && (end <= cur.ch))\n            return;\n        if (match) {\n            var baseStr = match[2] || match[4];\n            var digits = match[3] || match[5];\n            var increment = actionArgs.increase ? 1 : -1;\n            var base = { '0b': 2, '0': 8, '': 10, '0x': 16 }[baseStr.toLowerCase()];\n            var number = parseInt(match[1] + digits, base) + (increment * actionArgs.repeat);\n            numberStr = number.toString(base);\n            var zeroPadding = baseStr ? new Array(digits.length - numberStr.length + 1 + match[1].length).join('0') : '';\n            if (numberStr.charAt(0) === '-') {\n                numberStr = '-' + baseStr + zeroPadding + numberStr.substr(1);\n            }\n            else {\n                numberStr = baseStr + zeroPadding + numberStr;\n            }\n            var from = new Pos(cur.line, start);\n            var to = new Pos(cur.line, end);\n            cm.replaceRange(numberStr, from, to);\n        }\n        else {\n            return;\n        }\n        cm.setCursor(new Pos(cur.line, start + numberStr.length - 1));\n    },\n    repeatLastEdit: function (cm, actionArgs, vim) {\n        var lastEditInputState = vim.lastEditInputState;\n        if (!lastEditInputState) {\n            return;\n        }\n        var repeat = actionArgs.repeat;\n        if (repeat && actionArgs.repeatIsExplicit) {\n            vim.lastEditInputState.repeatOverride = repeat;\n        }\n        else {\n            repeat = vim.lastEditInputState.repeatOverride || repeat;\n        }\n        repeatLastEdit(cm, vim, repeat, false /** repeatForInsert */);\n    },\n    indent: function (cm, actionArgs) {\n        cm.indentLine(cm.getCursor().line, actionArgs.indentRight);\n    },\n    exitInsertMode: exitInsertMode\n};\nfunction defineAction(name, fn) {\n    actions[name] = fn;\n}\nfunction clipCursorToContent(cm, cur, oldCur) {\n    var vim = cm.state.vim;\n    var includeLineBreak = vim.insertMode || vim.visualMode;\n    var line = Math.min(Math.max(cm.firstLine(), cur.line), cm.lastLine());\n    var text = cm.getLine(line);\n    var maxCh = text.length - 1 + !!includeLineBreak;\n    var ch = Math.min(Math.max(0, cur.ch), maxCh);\n    var charCode = text.charCodeAt(ch);\n    if (0xDC00 < charCode && charCode < 0xDFFF) {\n        var direction = 1;\n        if (oldCur && oldCur.line == line) {\n            if (oldCur.ch > ch) {\n                direction = -1;\n            }\n        }\n        ch += direction;\n        if (ch > maxCh)\n            ch -= 2;\n    }\n    return new Pos(line, ch);\n}\nfunction copyArgs(args) {\n    var ret = {};\n    for (var prop in args) {\n        if (args.hasOwnProperty(prop)) {\n            ret[prop] = args[prop];\n        }\n    }\n    return ret;\n}\nfunction offsetCursor(cur, offsetLine, offsetCh) {\n    if (typeof offsetLine === 'object') {\n        offsetCh = offsetLine.ch;\n        offsetLine = offsetLine.line;\n    }\n    return new Pos(cur.line + offsetLine, cur.ch + offsetCh);\n}\nfunction commandMatches(keys, keyMap, context, inputState) {\n    var match, partial = [], full = [];\n    for (var i = 0; i < keyMap.length; i++) {\n        var command = keyMap[i];\n        if (context == 'insert' && command.context != 'insert' ||\n            command.context && command.context != context ||\n            inputState.operator && command.type == 'action' ||\n            !(match = commandMatch(keys, command.keys))) {\n            continue;\n        }\n        if (match == 'partial') {\n            partial.push(command);\n        }\n        if (match == 'full') {\n            full.push(command);\n        }\n    }\n    return {\n        partial: partial.length && partial,\n        full: full.length && full\n    };\n}\nfunction commandMatch(pressed, mapped) {\n    if (mapped.slice(-11) == '<character>') {\n        var prefixLen = mapped.length - 11;\n        var pressedPrefix = pressed.slice(0, prefixLen);\n        var mappedPrefix = mapped.slice(0, prefixLen);\n        return pressedPrefix == mappedPrefix && pressed.length > prefixLen ? 'full' :\n            mappedPrefix.indexOf(pressedPrefix) == 0 ? 'partial' : false;\n    }\n    else {\n        return pressed == mapped ? 'full' :\n            mapped.indexOf(pressed) == 0 ? 'partial' : false;\n    }\n}\nfunction lastChar(keys) {\n    var match = /^.*(<[^>]+>)$/.exec(keys);\n    var selectedCharacter = match ? match[1] : keys.slice(-1);\n    if (selectedCharacter.length > 1) {\n        switch (selectedCharacter) {\n            case '<CR>':\n                selectedCharacter = '\\n';\n                break;\n            case '<Space>':\n                selectedCharacter = ' ';\n                break;\n            default:\n                selectedCharacter = '';\n                break;\n        }\n    }\n    return selectedCharacter;\n}\nfunction repeatFn(cm, fn, repeat) {\n    return function () {\n        for (var i = 0; i < repeat; i++) {\n            fn(cm);\n        }\n    };\n}\nfunction copyCursor(cur) {\n    return new Pos(cur.line, cur.ch);\n}\nfunction cursorEqual(cur1, cur2) {\n    return cur1.ch == cur2.ch && cur1.line == cur2.line;\n}\nfunction cursorIsBefore(cur1, cur2) {\n    if (cur1.line < cur2.line) {\n        return true;\n    }\n    if (cur1.line == cur2.line && cur1.ch < cur2.ch) {\n        return true;\n    }\n    return false;\n}\nfunction cursorMin(cur1, cur2) {\n    if (arguments.length > 2) {\n        cur2 = cursorMin.apply(undefined, Array.prototype.slice.call(arguments, 1));\n    }\n    return cursorIsBefore(cur1, cur2) ? cur1 : cur2;\n}\nfunction cursorMax(cur1, cur2) {\n    if (arguments.length > 2) {\n        cur2 = cursorMax.apply(undefined, Array.prototype.slice.call(arguments, 1));\n    }\n    return cursorIsBefore(cur1, cur2) ? cur2 : cur1;\n}\nfunction cursorIsBetween(cur1, cur2, cur3) {\n    var cur1before2 = cursorIsBefore(cur1, cur2);\n    var cur2before3 = cursorIsBefore(cur2, cur3);\n    return cur1before2 && cur2before3;\n}\nfunction lineLength(cm, lineNum) {\n    return cm.getLine(lineNum).length;\n}\nfunction trim(s) {\n    if (s.trim) {\n        return s.trim();\n    }\n    return s.replace(/^\\s+|\\s+$/g, '');\n}\nfunction escapeRegex(s) {\n    return s.replace(/([.?*+$\\[\\]\\/\\\\(){}|\\-])/g, '\\\\$1');\n}\nfunction extendLineToColumn(cm, lineNum, column) {\n    var endCh = lineLength(cm, lineNum);\n    var spaces = new Array(column - endCh + 1).join(' ');\n    cm.setCursor(new Pos(lineNum, endCh));\n    cm.replaceRange(spaces, cm.getCursor());\n}\nfunction selectBlock(cm, selectionEnd) {\n    var selections = [], ranges = cm.listSelections();\n    var head = copyCursor(cm.clipPos(selectionEnd));\n    var isClipped = !cursorEqual(selectionEnd, head);\n    var curHead = cm.getCursor('head');\n    var primIndex = getIndex(ranges, curHead);\n    var wasClipped = cursorEqual(ranges[primIndex].head, ranges[primIndex].anchor);\n    var max = ranges.length - 1;\n    var index = max - primIndex > primIndex ? max : 0;\n    var base = ranges[index].anchor;\n    var firstLine = Math.min(base.line, head.line);\n    var lastLine = Math.max(base.line, head.line);\n    var baseCh = base.ch, headCh = head.ch;\n    var dir = ranges[index].head.ch - baseCh;\n    var newDir = headCh - baseCh;\n    if (dir > 0 && newDir <= 0) {\n        baseCh++;\n        if (!isClipped) {\n            headCh--;\n        }\n    }\n    else if (dir < 0 && newDir >= 0) {\n        baseCh--;\n        if (!wasClipped) {\n            headCh++;\n        }\n    }\n    else if (dir < 0 && newDir == -1) {\n        baseCh--;\n        headCh++;\n    }\n    for (var line = firstLine; line <= lastLine; line++) {\n        var range = { anchor: new Pos(line, baseCh), head: new Pos(line, headCh) };\n        selections.push(range);\n    }\n    cm.setSelections(selections);\n    selectionEnd.ch = headCh;\n    base.ch = baseCh;\n    return base;\n}\nfunction selectForInsert(cm, head, height) {\n    var sel = [];\n    for (var i = 0; i < height; i++) {\n        var lineHead = offsetCursor(head, i, 0);\n        sel.push({ anchor: lineHead, head: lineHead });\n    }\n    cm.setSelections(sel, 0);\n}\nfunction getIndex(ranges, cursor, end) {\n    for (var i = 0; i < ranges.length; i++) {\n        var atAnchor = end != 'head' && cursorEqual(ranges[i].anchor, cursor);\n        var atHead = end != 'anchor' && cursorEqual(ranges[i].head, cursor);\n        if (atAnchor || atHead) {\n            return i;\n        }\n    }\n    return -1;\n}\nfunction getSelectedAreaRange(cm, vim) {\n    var lastSelection = vim.lastSelection;\n    var getCurrentSelectedAreaRange = function () {\n        var selections = cm.listSelections();\n        var start = selections[0];\n        var end = selections[selections.length - 1];\n        var selectionStart = cursorIsBefore(start.anchor, start.head) ? start.anchor : start.head;\n        var selectionEnd = cursorIsBefore(end.anchor, end.head) ? end.head : end.anchor;\n        return [selectionStart, selectionEnd];\n    };\n    var getLastSelectedAreaRange = function () {\n        var selectionStart = cm.getCursor();\n        var selectionEnd = cm.getCursor();\n        var block = lastSelection.visualBlock;\n        if (block) {\n            var width = block.width;\n            var height = block.height;\n            selectionEnd = new Pos(selectionStart.line + height, selectionStart.ch + width);\n            var selections = [];\n            for (var i = selectionStart.line; i < selectionEnd.line; i++) {\n                var anchor = new Pos(i, selectionStart.ch);\n                var head = new Pos(i, selectionEnd.ch);\n                var range = { anchor: anchor, head: head };\n                selections.push(range);\n            }\n            cm.setSelections(selections);\n        }\n        else {\n            var start = lastSelection.anchorMark.find();\n            var end = lastSelection.headMark.find();\n            var line = end.line - start.line;\n            var ch = end.ch - start.ch;\n            selectionEnd = { line: selectionEnd.line + line, ch: line ? selectionEnd.ch : ch + selectionEnd.ch };\n            if (lastSelection.visualLine) {\n                selectionStart = new Pos(selectionStart.line, 0);\n                selectionEnd = new Pos(selectionEnd.line, lineLength(cm, selectionEnd.line));\n            }\n            cm.setSelection(selectionStart, selectionEnd);\n        }\n        return [selectionStart, selectionEnd];\n    };\n    if (!vim.visualMode) {\n        return getLastSelectedAreaRange();\n    }\n    else {\n        return getCurrentSelectedAreaRange();\n    }\n}\nfunction updateLastSelection(cm, vim) {\n    var anchor = vim.sel.anchor;\n    var head = vim.sel.head;\n    if (vim.lastPastedText) {\n        head = cm.posFromIndex(cm.indexFromPos(anchor) + vim.lastPastedText.length);\n        vim.lastPastedText = null;\n    }\n    vim.lastSelection = { 'anchorMark': cm.setBookmark(anchor),\n        'headMark': cm.setBookmark(head),\n        'anchor': copyCursor(anchor),\n        'head': copyCursor(head),\n        'visualMode': vim.visualMode,\n        'visualLine': vim.visualLine,\n        'visualBlock': vim.visualBlock };\n}\nfunction expandSelection(cm, start, end) {\n    var sel = cm.state.vim.sel;\n    var head = sel.head;\n    var anchor = sel.anchor;\n    var tmp;\n    if (cursorIsBefore(end, start)) {\n        tmp = end;\n        end = start;\n        start = tmp;\n    }\n    if (cursorIsBefore(head, anchor)) {\n        head = cursorMin(start, head);\n        anchor = cursorMax(anchor, end);\n    }\n    else {\n        anchor = cursorMin(start, anchor);\n        head = cursorMax(head, end);\n        head = offsetCursor(head, 0, -1);\n        if (head.ch == -1 && head.line != cm.firstLine()) {\n            head = new Pos(head.line - 1, lineLength(cm, head.line - 1));\n        }\n    }\n    return [anchor, head];\n}\nfunction updateCmSelection(cm, sel, mode) {\n    var vim = cm.state.vim;\n    sel = sel || vim.sel;\n    var mode = mode ||\n        vim.visualLine ? 'line' : vim.visualBlock ? 'block' : 'char';\n    var cmSel = makeCmSelection(cm, sel, mode);\n    cm.setSelections(cmSel.ranges, cmSel.primary);\n}\nfunction makeCmSelection(cm, sel, mode, exclusive) {\n    var head = copyCursor(sel.head);\n    var anchor = copyCursor(sel.anchor);\n    if (mode == 'char') {\n        var headOffset = !exclusive && !cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n        var anchorOffset = cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n        head = offsetCursor(sel.head, 0, headOffset);\n        anchor = offsetCursor(sel.anchor, 0, anchorOffset);\n        return {\n            ranges: [{ anchor: anchor, head: head }],\n            primary: 0\n        };\n    }\n    else if (mode == 'line') {\n        if (!cursorIsBefore(sel.head, sel.anchor)) {\n            anchor.ch = 0;\n            var lastLine = cm.lastLine();\n            if (head.line > lastLine) {\n                head.line = lastLine;\n            }\n            head.ch = lineLength(cm, head.line);\n        }\n        else {\n            head.ch = 0;\n            anchor.ch = lineLength(cm, anchor.line);\n        }\n        return {\n            ranges: [{ anchor: anchor, head: head }],\n            primary: 0\n        };\n    }\n    else if (mode == 'block') {\n        var top = Math.min(anchor.line, head.line), fromCh = anchor.ch, bottom = Math.max(anchor.line, head.line), toCh = head.ch;\n        if (fromCh < toCh) {\n            toCh += 1;\n        }\n        else {\n            fromCh += 1;\n        }\n        ;\n        var height = bottom - top + 1;\n        var primary = head.line == top ? 0 : height - 1;\n        var ranges = [];\n        for (var i = 0; i < height; i++) {\n            ranges.push({\n                anchor: new Pos(top + i, fromCh),\n                head: new Pos(top + i, toCh)\n            });\n        }\n        return {\n            ranges: ranges,\n            primary: primary\n        };\n    }\n}\nfunction getHead(cm) {\n    var cur = cm.getCursor('head');\n    if (cm.getSelection().length == 1) {\n        cur = cursorMin(cur, cm.getCursor('anchor'));\n    }\n    return cur;\n}\nfunction exitVisualMode(cm, moveHead) {\n    var vim = cm.state.vim;\n    if (moveHead !== false) {\n        cm.setCursor(clipCursorToContent(cm, vim.sel.head));\n    }\n    updateLastSelection(cm, vim);\n    vim.visualMode = false;\n    vim.visualLine = false;\n    vim.visualBlock = false;\n    if (!vim.insertMode)\n        CodeMirror.signal(cm, \"vim-mode-change\", { mode: \"normal\" });\n}\nfunction clipToLine(cm, curStart, curEnd) {\n    var selection = cm.getRange(curStart, curEnd);\n    if (/\\n\\s*$/.test(selection)) {\n        var lines = selection.split('\\n');\n        lines.pop();\n        var line;\n        for (var line = lines.pop(); lines.length > 0 && line && isWhiteSpaceString(line); line = lines.pop()) {\n            curEnd.line--;\n            curEnd.ch = 0;\n        }\n        if (line) {\n            curEnd.line--;\n            curEnd.ch = lineLength(cm, curEnd.line);\n        }\n        else {\n            curEnd.ch = 0;\n        }\n    }\n}\nfunction expandSelectionToLine(_cm, curStart, curEnd) {\n    curStart.ch = 0;\n    curEnd.ch = 0;\n    curEnd.line++;\n}\nfunction findFirstNonWhiteSpaceCharacter(text) {\n    if (!text) {\n        return 0;\n    }\n    var firstNonWS = text.search(/\\S/);\n    return firstNonWS == -1 ? text.length : firstNonWS;\n}\nfunction expandWordUnderCursor(cm, inclusive, _forward, bigWord, noSymbol) {\n    var cur = getHead(cm);\n    var line = cm.getLine(cur.line);\n    var idx = cur.ch;\n    var test = noSymbol ? wordCharTest[0] : bigWordCharTest[0];\n    while (!test(line.charAt(idx))) {\n        idx++;\n        if (idx >= line.length) {\n            return null;\n        }\n    }\n    if (bigWord) {\n        test = bigWordCharTest[0];\n    }\n    else {\n        test = wordCharTest[0];\n        if (!test(line.charAt(idx))) {\n            test = wordCharTest[1];\n        }\n    }\n    var end = idx, start = idx;\n    while (test(line.charAt(end)) && end < line.length) {\n        end++;\n    }\n    while (test(line.charAt(start)) && start >= 0) {\n        start--;\n    }\n    start++;\n    if (inclusive) {\n        var wordEnd = end;\n        while (/\\s/.test(line.charAt(end)) && end < line.length) {\n            end++;\n        }\n        if (wordEnd == end) {\n            var wordStart = start;\n            while (/\\s/.test(line.charAt(start - 1)) && start > 0) {\n                start--;\n            }\n            if (!start) {\n                start = wordStart;\n            }\n        }\n    }\n    return { start: new Pos(cur.line, start), end: new Pos(cur.line, end) };\n}\nfunction expandTagUnderCursor(cm, head, inclusive) {\n    var cur = head;\n    if (!CodeMirror.findMatchingTag || !CodeMirror.findEnclosingTag) {\n        return { start: cur, end: cur };\n    }\n    var tags = CodeMirror.findMatchingTag(cm, head) || CodeMirror.findEnclosingTag(cm, head);\n    if (!tags || !tags.open || !tags.close) {\n        return { start: cur, end: cur };\n    }\n    if (inclusive) {\n        return { start: tags.open.from, end: tags.close.to };\n    }\n    return { start: tags.open.to, end: tags.close.from };\n}\nfunction recordJumpPosition(cm, oldCur, newCur) {\n    if (!cursorEqual(oldCur, newCur)) {\n        vimGlobalState.jumpList.add(cm, oldCur, newCur);\n    }\n}\nfunction recordLastCharacterSearch(increment, args) {\n    vimGlobalState.lastCharacterSearch.increment = increment;\n    vimGlobalState.lastCharacterSearch.forward = args.forward;\n    vimGlobalState.lastCharacterSearch.selectedCharacter = args.selectedCharacter;\n}\nvar symbolToMode = {\n    '(': 'bracket', ')': 'bracket', '{': 'bracket', '}': 'bracket',\n    '[': 'section', ']': 'section',\n    '*': 'comment', '/': 'comment',\n    'm': 'method', 'M': 'method',\n    '#': 'preprocess'\n};\nvar findSymbolModes = {\n    bracket: {\n        isComplete: function (state) {\n            if (state.nextCh === state.symb) {\n                state.depth++;\n                if (state.depth >= 1)\n                    return true;\n            }\n            else if (state.nextCh === state.reverseSymb) {\n                state.depth--;\n            }\n            return false;\n        }\n    },\n    section: {\n        init: function (state) {\n            state.curMoveThrough = true;\n            state.symb = (state.forward ? ']' : '[') === state.symb ? '{' : '}';\n        },\n        isComplete: function (state) {\n            return state.index === 0 && state.nextCh === state.symb;\n        }\n    },\n    comment: {\n        isComplete: function (state) {\n            var found = state.lastCh === '*' && state.nextCh === '/';\n            state.lastCh = state.nextCh;\n            return found;\n        }\n    },\n    method: {\n        init: function (state) {\n            state.symb = (state.symb === 'm' ? '{' : '}');\n            state.reverseSymb = state.symb === '{' ? '}' : '{';\n        },\n        isComplete: function (state) {\n            if (state.nextCh === state.symb)\n                return true;\n            return false;\n        }\n    },\n    preprocess: {\n        init: function (state) {\n            state.index = 0;\n        },\n        isComplete: function (state) {\n            if (state.nextCh === '#') {\n                var token = state.lineText.match(/^#(\\w+)/)[1];\n                if (token === 'endif') {\n                    if (state.forward && state.depth === 0) {\n                        return true;\n                    }\n                    state.depth++;\n                }\n                else if (token === 'if') {\n                    if (!state.forward && state.depth === 0) {\n                        return true;\n                    }\n                    state.depth--;\n                }\n                if (token === 'else' && state.depth === 0)\n                    return true;\n            }\n            return false;\n        }\n    }\n};\nfunction findSymbol(cm, repeat, forward, symb) {\n    var cur = copyCursor(cm.getCursor());\n    var increment = forward ? 1 : -1;\n    var endLine = forward ? cm.lineCount() : -1;\n    var curCh = cur.ch;\n    var line = cur.line;\n    var lineText = cm.getLine(line);\n    var state = {\n        lineText: lineText,\n        nextCh: lineText.charAt(curCh),\n        lastCh: null,\n        index: curCh,\n        symb: symb,\n        reverseSymb: (forward ? { ')': '(', '}': '{' } : { '(': ')', '{': '}' })[symb],\n        forward: forward,\n        depth: 0,\n        curMoveThrough: false\n    };\n    var mode = symbolToMode[symb];\n    if (!mode)\n        return cur;\n    var init = findSymbolModes[mode].init;\n    var isComplete = findSymbolModes[mode].isComplete;\n    if (init) {\n        init(state);\n    }\n    while (line !== endLine && repeat) {\n        state.index += increment;\n        state.nextCh = state.lineText.charAt(state.index);\n        if (!state.nextCh) {\n            line += increment;\n            state.lineText = cm.getLine(line) || '';\n            if (increment > 0) {\n                state.index = 0;\n            }\n            else {\n                var lineLen = state.lineText.length;\n                state.index = (lineLen > 0) ? (lineLen - 1) : 0;\n            }\n            state.nextCh = state.lineText.charAt(state.index);\n        }\n        if (isComplete(state)) {\n            cur.line = line;\n            cur.ch = state.index;\n            repeat--;\n        }\n    }\n    if (state.nextCh || state.curMoveThrough) {\n        return new Pos(line, state.index);\n    }\n    return cur;\n}\nfunction findWord(cm, cur, forward, bigWord, emptyLineIsWord) {\n    var lineNum = cur.line;\n    var pos = cur.ch;\n    var line = cm.getLine(lineNum);\n    var dir = forward ? 1 : -1;\n    var charTests = bigWord ? bigWordCharTest : wordCharTest;\n    if (emptyLineIsWord && line == '') {\n        lineNum += dir;\n        line = cm.getLine(lineNum);\n        if (!isLine(cm, lineNum)) {\n            return null;\n        }\n        pos = (forward) ? 0 : line.length;\n    }\n    while (true) {\n        if (emptyLineIsWord && line == '') {\n            return { from: 0, to: 0, line: lineNum };\n        }\n        var stop = (dir > 0) ? line.length : -1;\n        var wordStart = stop, wordEnd = stop;\n        while (pos != stop) {\n            var foundWord = false;\n            for (var i = 0; i < charTests.length && !foundWord; ++i) {\n                if (charTests[i](line.charAt(pos))) {\n                    wordStart = pos;\n                    while (pos != stop && charTests[i](line.charAt(pos))) {\n                        pos += dir;\n                    }\n                    wordEnd = pos;\n                    foundWord = wordStart != wordEnd;\n                    if (wordStart == cur.ch && lineNum == cur.line &&\n                        wordEnd == wordStart + dir) {\n                        continue;\n                    }\n                    else {\n                        return {\n                            from: Math.min(wordStart, wordEnd + 1),\n                            to: Math.max(wordStart, wordEnd),\n                            line: lineNum\n                        };\n                    }\n                }\n            }\n            if (!foundWord) {\n                pos += dir;\n            }\n        }\n        lineNum += dir;\n        if (!isLine(cm, lineNum)) {\n            return null;\n        }\n        line = cm.getLine(lineNum);\n        pos = (dir > 0) ? 0 : line.length;\n    }\n}\nfunction moveToWord(cm, cur, repeat, forward, wordEnd, bigWord) {\n    var curStart = copyCursor(cur);\n    var words = [];\n    if (forward && !wordEnd || !forward && wordEnd) {\n        repeat++;\n    }\n    var emptyLineIsWord = !(forward && wordEnd);\n    for (var i = 0; i < repeat; i++) {\n        var word = findWord(cm, cur, forward, bigWord, emptyLineIsWord);\n        if (!word) {\n            var eodCh = lineLength(cm, cm.lastLine());\n            words.push(forward\n                ? { line: cm.lastLine(), from: eodCh, to: eodCh }\n                : { line: 0, from: 0, to: 0 });\n            break;\n        }\n        words.push(word);\n        cur = new Pos(word.line, forward ? (word.to - 1) : word.from);\n    }\n    var shortCircuit = words.length != repeat;\n    var firstWord = words[0];\n    var lastWord = words.pop();\n    if (forward && !wordEnd) {\n        if (!shortCircuit && (firstWord.from != curStart.ch || firstWord.line != curStart.line)) {\n            lastWord = words.pop();\n        }\n        return new Pos(lastWord.line, lastWord.from);\n    }\n    else if (forward && wordEnd) {\n        return new Pos(lastWord.line, lastWord.to - 1);\n    }\n    else if (!forward && wordEnd) {\n        if (!shortCircuit && (firstWord.to != curStart.ch || firstWord.line != curStart.line)) {\n            lastWord = words.pop();\n        }\n        return new Pos(lastWord.line, lastWord.to);\n    }\n    else {\n        return new Pos(lastWord.line, lastWord.from);\n    }\n}\nfunction moveToEol(cm, head, motionArgs, vim, keepHPos) {\n    var cur = head;\n    var retval = new Pos(cur.line + motionArgs.repeat - 1, Infinity);\n    var end = cm.clipPos(retval);\n    end.ch--;\n    if (!keepHPos) {\n        vim.lastHPos = Infinity;\n        vim.lastHSPos = cm.charCoords(end, 'div').left;\n    }\n    return retval;\n}\nfunction moveToCharacter(cm, repeat, forward, character) {\n    var cur = cm.getCursor();\n    var start = cur.ch;\n    var idx;\n    for (var i = 0; i < repeat; i++) {\n        var line = cm.getLine(cur.line);\n        idx = charIdxInLine(start, line, character, forward, true);\n        if (idx == -1) {\n            return null;\n        }\n        start = idx;\n    }\n    return new Pos(cm.getCursor().line, idx);\n}\nfunction moveToColumn(cm, repeat) {\n    var line = cm.getCursor().line;\n    return clipCursorToContent(cm, new Pos(line, repeat - 1));\n}\nfunction updateMark(cm, vim, markName, pos) {\n    if (!inArray(markName, validMarks)) {\n        return;\n    }\n    if (vim.marks[markName]) {\n        vim.marks[markName].clear();\n    }\n    vim.marks[markName] = cm.setBookmark(pos);\n}\nfunction charIdxInLine(start, line, character, forward, includeChar) {\n    var idx;\n    if (forward) {\n        idx = line.indexOf(character, start + 1);\n        if (idx != -1 && !includeChar) {\n            idx -= 1;\n        }\n    }\n    else {\n        idx = line.lastIndexOf(character, start - 1);\n        if (idx != -1 && !includeChar) {\n            idx += 1;\n        }\n    }\n    return idx;\n}\nfunction findParagraph(cm, head, repeat, dir, inclusive) {\n    var line = head.line;\n    var min = cm.firstLine();\n    var max = cm.lastLine();\n    var start, end, i = line;\n    function isEmpty(i) { return !/\\S/.test(cm.getLine(i)); } // ace_patch\n    function isBoundary(i, dir, any) {\n        if (any) {\n            return isEmpty(i) != isEmpty(i + dir);\n        }\n        return !isEmpty(i) && isEmpty(i + dir);\n    }\n    function skipFold(i) {\n        dir = dir > 0 ? 1 : -1;\n        var foldLine = cm.ace.session.getFoldLine(i);\n        if (foldLine) {\n            if (i + dir > foldLine.start.row && i + dir < foldLine.end.row)\n                dir = (dir > 0 ? foldLine.end.row : foldLine.start.row) - i;\n        }\n    }\n    if (dir) {\n        while (min <= i && i <= max && repeat > 0) {\n            skipFold(i);\n            if (isBoundary(i, dir)) {\n                repeat--;\n            }\n            i += dir;\n        }\n        return new Pos(i, 0);\n    }\n    var vim = cm.state.vim;\n    if (vim.visualLine && isBoundary(line, 1, true)) {\n        var anchor = vim.sel.anchor;\n        if (isBoundary(anchor.line, -1, true)) {\n            if (!inclusive || anchor.line != line) {\n                line += 1;\n            }\n        }\n    }\n    var startState = isEmpty(line);\n    for (i = line; i <= max && repeat; i++) {\n        if (isBoundary(i, 1, true)) {\n            if (!inclusive || isEmpty(i) != startState) {\n                repeat--;\n            }\n        }\n    }\n    end = new Pos(i, 0);\n    if (i > max && !startState) {\n        startState = true;\n    }\n    else {\n        inclusive = false;\n    }\n    for (i = line; i > min; i--) {\n        if (!inclusive || isEmpty(i) == startState || i == line) {\n            if (isBoundary(i, -1, true)) {\n                break;\n            }\n        }\n    }\n    start = new Pos(i, 0);\n    return { start: start, end: end };\n}\nfunction getSentence(cm, cur, repeat, dir, inclusive /*includes whitespace*/) {\n    function nextChar(curr) {\n        if (curr.pos + curr.dir < 0 || curr.pos + curr.dir >= curr.line.length) {\n            curr.line = null;\n        }\n        else {\n            curr.pos += curr.dir;\n        }\n    }\n    function forward(cm, ln, pos, dir) {\n        var line = cm.getLine(ln);\n        var curr = {\n            line: line,\n            ln: ln,\n            pos: pos,\n            dir: dir,\n        };\n        if (curr.line === \"\") {\n            return { ln: curr.ln, pos: curr.pos };\n        }\n        var lastSentencePos = curr.pos;\n        nextChar(curr);\n        while (curr.line !== null) {\n            lastSentencePos = curr.pos;\n            if (isEndOfSentenceSymbol(curr.line[curr.pos])) {\n                if (!inclusive) {\n                    return { ln: curr.ln, pos: curr.pos + 1 };\n                }\n                else {\n                    nextChar(curr);\n                    while (curr.line !== null) {\n                        if (isWhiteSpaceString(curr.line[curr.pos])) {\n                            lastSentencePos = curr.pos;\n                            nextChar(curr);\n                        }\n                        else {\n                            break;\n                        }\n                    }\n                    return { ln: curr.ln, pos: lastSentencePos + 1 };\n                }\n            }\n            nextChar(curr);\n        }\n        return { ln: curr.ln, pos: lastSentencePos + 1 };\n    }\n    function reverse(cm, ln, pos, dir) {\n        var line = cm.getLine(ln);\n        var curr = {\n            line: line,\n            ln: ln,\n            pos: pos,\n            dir: dir,\n        };\n        if (curr.line === \"\") {\n            return { ln: curr.ln, pos: curr.pos };\n        }\n        var lastSentencePos = curr.pos;\n        nextChar(curr);\n        while (curr.line !== null) {\n            if (!isWhiteSpaceString(curr.line[curr.pos]) && !isEndOfSentenceSymbol(curr.line[curr.pos])) {\n                lastSentencePos = curr.pos;\n            }\n            else if (isEndOfSentenceSymbol(curr.line[curr.pos])) {\n                if (!inclusive) {\n                    return { ln: curr.ln, pos: lastSentencePos };\n                }\n                else {\n                    if (isWhiteSpaceString(curr.line[curr.pos + 1])) {\n                        return { ln: curr.ln, pos: curr.pos + 1 };\n                    }\n                    else {\n                        return { ln: curr.ln, pos: lastSentencePos };\n                    }\n                }\n            }\n            nextChar(curr);\n        }\n        curr.line = line;\n        if (inclusive && isWhiteSpaceString(curr.line[curr.pos])) {\n            return { ln: curr.ln, pos: curr.pos };\n        }\n        else {\n            return { ln: curr.ln, pos: lastSentencePos };\n        }\n    }\n    var curr_index = {\n        ln: cur.line,\n        pos: cur.ch,\n    };\n    while (repeat > 0) {\n        if (dir < 0) {\n            curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);\n        }\n        else {\n            curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);\n        }\n        repeat--;\n    }\n    return new Pos(curr_index.ln, curr_index.pos);\n}\nfunction findSentence(cm, cur, repeat, dir) {\n    function nextChar(cm, idx) {\n        if (idx.pos + idx.dir < 0 || idx.pos + idx.dir >= idx.line.length) {\n            idx.ln += idx.dir;\n            if (!isLine(cm, idx.ln)) {\n                idx.line = null;\n                idx.ln = null;\n                idx.pos = null;\n                return;\n            }\n            idx.line = cm.getLine(idx.ln);\n            idx.pos = (idx.dir > 0) ? 0 : idx.line.length - 1;\n        }\n        else {\n            idx.pos += idx.dir;\n        }\n    }\n    function forward(cm, ln, pos, dir) {\n        var line = cm.getLine(ln);\n        var stop = (line === \"\");\n        var curr = {\n            line: line,\n            ln: ln,\n            pos: pos,\n            dir: dir,\n        };\n        var last_valid = {\n            ln: curr.ln,\n            pos: curr.pos,\n        };\n        var skip_empty_lines = (curr.line === \"\");\n        nextChar(cm, curr);\n        while (curr.line !== null) {\n            last_valid.ln = curr.ln;\n            last_valid.pos = curr.pos;\n            if (curr.line === \"\" && !skip_empty_lines) {\n                return { ln: curr.ln, pos: curr.pos, };\n            }\n            else if (stop && curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n                return { ln: curr.ln, pos: curr.pos, };\n            }\n            else if (isEndOfSentenceSymbol(curr.line[curr.pos])\n                && !stop\n                && (curr.pos === curr.line.length - 1\n                    || isWhiteSpaceString(curr.line[curr.pos + 1]))) {\n                stop = true;\n            }\n            nextChar(cm, curr);\n        }\n        var line = cm.getLine(last_valid.ln);\n        last_valid.pos = 0;\n        for (var i = line.length - 1; i >= 0; --i) {\n            if (!isWhiteSpaceString(line[i])) {\n                last_valid.pos = i;\n                break;\n            }\n        }\n        return last_valid;\n    }\n    function reverse(cm, ln, pos, dir) {\n        var line = cm.getLine(ln);\n        var curr = {\n            line: line,\n            ln: ln,\n            pos: pos,\n            dir: dir,\n        };\n        var last_valid = {\n            ln: curr.ln,\n            pos: null,\n        };\n        var skip_empty_lines = (curr.line === \"\");\n        nextChar(cm, curr);\n        while (curr.line !== null) {\n            if (curr.line === \"\" && !skip_empty_lines) {\n                if (last_valid.pos !== null) {\n                    return last_valid;\n                }\n                else {\n                    return { ln: curr.ln, pos: curr.pos };\n                }\n            }\n            else if (isEndOfSentenceSymbol(curr.line[curr.pos])\n                && last_valid.pos !== null\n                && !(curr.ln === last_valid.ln && curr.pos + 1 === last_valid.pos)) {\n                return last_valid;\n            }\n            else if (curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n                skip_empty_lines = false;\n                last_valid = { ln: curr.ln, pos: curr.pos };\n            }\n            nextChar(cm, curr);\n        }\n        var line = cm.getLine(last_valid.ln);\n        last_valid.pos = 0;\n        for (var i = 0; i < line.length; ++i) {\n            if (!isWhiteSpaceString(line[i])) {\n                last_valid.pos = i;\n                break;\n            }\n        }\n        return last_valid;\n    }\n    var curr_index = {\n        ln: cur.line,\n        pos: cur.ch,\n    };\n    while (repeat > 0) {\n        if (dir < 0) {\n            curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);\n        }\n        else {\n            curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);\n        }\n        repeat--;\n    }\n    return new Pos(curr_index.ln, curr_index.pos);\n}\nfunction selectCompanionObject(cm, head, symb, inclusive) {\n    var cur = head, start, end;\n    var bracketRegexp = ({\n        '(': /[()]/, ')': /[()]/,\n        '[': /[[\\]]/, ']': /[[\\]]/,\n        '{': /[{}]/, '}': /[{}]/,\n        '<': /[<>]/, '>': /[<>]/\n    })[symb];\n    var openSym = ({\n        '(': '(', ')': '(',\n        '[': '[', ']': '[',\n        '{': '{', '}': '{',\n        '<': '<', '>': '<'\n    })[symb];\n    var curChar = cm.getLine(cur.line).charAt(cur.ch);\n    var offset = curChar === openSym ? 1 : 0;\n    start = cm.scanForBracket(new Pos(cur.line, cur.ch + offset), -1, undefined, { 'bracketRegex': bracketRegexp });\n    end = cm.scanForBracket(new Pos(cur.line, cur.ch + offset), 1, undefined, { 'bracketRegex': bracketRegexp });\n    if (!start || !end) {\n        return { start: cur, end: cur };\n    }\n    start = start.pos;\n    end = end.pos;\n    if ((start.line == end.line && start.ch > end.ch)\n        || (start.line > end.line)) {\n        var tmp = start;\n        start = end;\n        end = tmp;\n    }\n    if (inclusive) {\n        end.ch += 1;\n    }\n    else {\n        start.ch += 1;\n    }\n    return { start: start, end: end };\n}\nfunction findBeginningAndEnd(cm, head, symb, inclusive) {\n    var cur = copyCursor(head);\n    var line = cm.getLine(cur.line);\n    var chars = line.split('');\n    var start, end, i, len;\n    var firstIndex = chars.indexOf(symb);\n    if (cur.ch < firstIndex) {\n        cur.ch = firstIndex;\n    }\n    else if (firstIndex < cur.ch && chars[cur.ch] == symb) {\n        end = cur.ch; // assign end to the current cursor\n        --cur.ch; // make sure to look backwards\n    }\n    if (chars[cur.ch] == symb && !end) {\n        start = cur.ch + 1; // assign start to ahead of the cursor\n    }\n    else {\n        for (i = cur.ch; i > -1 && !start; i--) {\n            if (chars[i] == symb) {\n                start = i + 1;\n            }\n        }\n    }\n    if (start && !end) {\n        for (i = start, len = chars.length; i < len && !end; i++) {\n            if (chars[i] == symb) {\n                end = i;\n            }\n        }\n    }\n    if (!start || !end) {\n        return { start: cur, end: cur };\n    }\n    if (inclusive) {\n        --start;\n        ++end;\n    }\n    return {\n        start: new Pos(cur.line, start),\n        end: new Pos(cur.line, end)\n    };\n}\ndefineOption('pcre', true, 'boolean');\nfunction SearchState() { }\nSearchState.prototype = {\n    getQuery: function () {\n        return vimGlobalState.query;\n    },\n    setQuery: function (query) {\n        vimGlobalState.query = query;\n    },\n    getOverlay: function () {\n        return this.searchOverlay;\n    },\n    setOverlay: function (overlay) {\n        this.searchOverlay = overlay;\n    },\n    isReversed: function () {\n        return vimGlobalState.isReversed;\n    },\n    setReversed: function (reversed) {\n        vimGlobalState.isReversed = reversed;\n    },\n    getScrollbarAnnotate: function () {\n        return this.annotate;\n    },\n    setScrollbarAnnotate: function (annotate) {\n        this.annotate = annotate;\n    }\n};\nfunction getSearchState(cm) {\n    var vim = cm.state.vim;\n    return vim.searchState_ || (vim.searchState_ = new SearchState());\n}\nfunction splitBySlash(argString) {\n    return splitBySeparator(argString, '/');\n}\nfunction findUnescapedSlashes(argString) {\n    return findUnescapedSeparators(argString, '/');\n}\nfunction splitBySeparator(argString, separator) {\n    var slashes = findUnescapedSeparators(argString, separator) || [];\n    if (!slashes.length)\n        return [];\n    var tokens = [];\n    if (slashes[0] !== 0)\n        return;\n    for (var i = 0; i < slashes.length; i++) {\n        if (typeof slashes[i] == 'number')\n            tokens.push(argString.substring(slashes[i] + 1, slashes[i + 1]));\n    }\n    return tokens;\n}\nfunction findUnescapedSeparators(str, separator) {\n    if (!separator)\n        separator = '/';\n    var escapeNextChar = false;\n    var slashes = [];\n    for (var i = 0; i < str.length; i++) {\n        var c = str.charAt(i);\n        if (!escapeNextChar && c == separator) {\n            slashes.push(i);\n        }\n        escapeNextChar = !escapeNextChar && (c == '\\\\');\n    }\n    return slashes;\n}\nfunction translateRegex(str) {\n    var specials = '|(){';\n    var unescape = '}';\n    var escapeNextChar = false;\n    var out = [];\n    for (var i = -1; i < str.length; i++) {\n        var c = str.charAt(i) || '';\n        var n = str.charAt(i + 1) || '';\n        var specialComesNext = (n && specials.indexOf(n) != -1);\n        if (escapeNextChar) {\n            if (c !== '\\\\' || !specialComesNext) {\n                out.push(c);\n            }\n            escapeNextChar = false;\n        }\n        else {\n            if (c === '\\\\') {\n                escapeNextChar = true;\n                if (n && unescape.indexOf(n) != -1) {\n                    specialComesNext = true;\n                }\n                if (!specialComesNext || n === '\\\\') {\n                    out.push(c);\n                }\n            }\n            else {\n                out.push(c);\n                if (specialComesNext && n !== '\\\\') {\n                    out.push('\\\\');\n                }\n            }\n        }\n    }\n    return out.join('');\n}\nvar charUnescapes = { '\\\\n': '\\n', '\\\\r': '\\r', '\\\\t': '\\t' };\nfunction translateRegexReplace(str) {\n    var escapeNextChar = false;\n    var out = [];\n    for (var i = -1; i < str.length; i++) {\n        var c = str.charAt(i) || '';\n        var n = str.charAt(i + 1) || '';\n        if (charUnescapes[c + n]) {\n            out.push(charUnescapes[c + n]);\n            i++;\n        }\n        else if (escapeNextChar) {\n            out.push(c);\n            escapeNextChar = false;\n        }\n        else {\n            if (c === '\\\\') {\n                escapeNextChar = true;\n                if ((isNumber(n) || n === '$')) {\n                    out.push('$');\n                }\n                else if (n !== '/' && n !== '\\\\') {\n                    out.push('\\\\');\n                }\n            }\n            else {\n                if (c === '$') {\n                    out.push('$');\n                }\n                out.push(c);\n                if (n === '/') {\n                    out.push('\\\\');\n                }\n            }\n        }\n    }\n    return out.join('');\n}\nvar unescapes = { '\\\\/': '/', '\\\\\\\\': '\\\\', '\\\\n': '\\n', '\\\\r': '\\r', '\\\\t': '\\t', '\\\\&': '&' };\nfunction unescapeRegexReplace(str) {\n    var stream = new CodeMirror.StringStream(str);\n    var output = [];\n    while (!stream.eol()) {\n        while (stream.peek() && stream.peek() != '\\\\') {\n            output.push(stream.next());\n        }\n        var matched = false;\n        for (var matcher in unescapes) {\n            if (stream.match(matcher, true)) {\n                matched = true;\n                output.push(unescapes[matcher]);\n                break;\n            }\n        }\n        if (!matched) {\n            output.push(stream.next());\n        }\n    }\n    return output.join('');\n}\nfunction parseQuery(query, ignoreCase, smartCase) {\n    var lastSearchRegister = vimGlobalState.registerController.getRegister('/');\n    lastSearchRegister.setText(query);\n    if (query instanceof RegExp) {\n        return query;\n    }\n    var slashes = findUnescapedSlashes(query);\n    var regexPart;\n    var forceIgnoreCase;\n    if (!slashes.length) {\n        regexPart = query;\n    }\n    else {\n        regexPart = query.substring(0, slashes[0]);\n        var flagsPart = query.substring(slashes[0]);\n        forceIgnoreCase = (flagsPart.indexOf('i') != -1);\n    }\n    if (!regexPart) {\n        return null;\n    }\n    if (!getOption('pcre')) {\n        regexPart = translateRegex(regexPart);\n    }\n    if (smartCase) {\n        ignoreCase = (/^[^A-Z]*$/).test(regexPart);\n    }\n    var regexp = new RegExp(regexPart, (ignoreCase || forceIgnoreCase) ? 'im' : 'm');\n    return regexp;\n}\nfunction dom(n) {\n    if (typeof n === 'string')\n        n = document.createElement(n);\n    for (var a, i = 1; i < arguments.length; i++) {\n        if (!(a = arguments[i]))\n            continue;\n        if (typeof a !== 'object')\n            a = document.createTextNode(a);\n        if (a.nodeType)\n            n.appendChild(a);\n        else\n            for (var key in a) {\n                if (!Object.prototype.hasOwnProperty.call(a, key))\n                    continue;\n                if (key[0] === '$')\n                    n.style[key.slice(1)] = a[key];\n                else\n                    n.setAttribute(key, a[key]);\n            }\n    }\n    return n;\n}\nfunction showConfirm(cm, template) {\n    var pre = dom('div', { $color: 'red', $whiteSpace: 'pre', class: 'cm-vim-message' }, template);\n    if (cm.openNotification) {\n        cm.openNotification(pre, { bottom: true, duration: 5000 });\n    }\n    else {\n        alert(pre.innerText);\n    }\n}\nfunction makePrompt(prefix, desc) {\n    return dom(document.createDocumentFragment(), dom('span', { $fontFamily: 'monospace', $whiteSpace: 'pre' }, prefix, dom('input', { type: 'text', autocorrect: 'off',\n        autocapitalize: 'off', spellcheck: 'false' })), desc && dom('span', { $color: '#888' }, desc));\n}\nfunction showPrompt(cm, options) {\n    var template = makePrompt(options.prefix, options.desc);\n    if (cm.openDialog) {\n        cm.openDialog(template, options.onClose, {\n            onKeyDown: options.onKeyDown, onKeyUp: options.onKeyUp,\n            bottom: true, selectValueOnOpen: false, value: options.value\n        });\n    }\n    else {\n        var shortText = '';\n        if (typeof options.prefix != \"string\" && options.prefix)\n            shortText += options.prefix.textContent;\n        if (options.desc)\n            shortText += \" \" + options.desc;\n        options.onClose(prompt(shortText, ''));\n    }\n}\nfunction regexEqual(r1, r2) {\n    if (r1 instanceof RegExp && r2 instanceof RegExp) {\n        var props = ['global', 'multiline', 'ignoreCase', 'source'];\n        for (var i = 0; i < props.length; i++) {\n            var prop = props[i];\n            if (r1[prop] !== r2[prop]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return false;\n}\nfunction updateSearchQuery(cm, rawQuery, ignoreCase, smartCase) {\n    if (!rawQuery) {\n        return;\n    }\n    var state = getSearchState(cm);\n    var query = parseQuery(rawQuery, !!ignoreCase, !!smartCase);\n    if (!query) {\n        return;\n    }\n    highlightSearchMatches(cm, query);\n    if (regexEqual(query, state.getQuery())) {\n        return query;\n    }\n    state.setQuery(query);\n    return query;\n}\nfunction searchOverlay(query) {\n    if (query.source.charAt(0) == '^') {\n        var matchSol = true;\n    }\n    return {\n        token: function (stream) {\n            if (matchSol && !stream.sol()) {\n                stream.skipToEnd();\n                return;\n            }\n            var match = stream.match(query, false);\n            if (match) {\n                if (match[0].length == 0) {\n                    stream.next();\n                    return 'searching';\n                }\n                if (!stream.sol()) {\n                    stream.backUp(1);\n                    if (!query.exec(stream.next() + match[0])) {\n                        stream.next();\n                        return null;\n                    }\n                }\n                stream.match(query);\n                return 'searching';\n            }\n            while (!stream.eol()) {\n                stream.next();\n                if (stream.match(query, false))\n                    break;\n            }\n        },\n        query: query\n    };\n}\nvar highlightTimeout = 0;\nfunction highlightSearchMatches(cm, query) {\n    clearTimeout(highlightTimeout);\n    highlightTimeout = setTimeout(function () {\n        if (!cm.state.vim)\n            return;\n        var searchState = getSearchState(cm);\n        var overlay = searchState.getOverlay();\n        if (!overlay || query != overlay.query) {\n            if (overlay) {\n                cm.removeOverlay(overlay);\n            }\n            overlay = searchOverlay(query);\n            cm.addOverlay(overlay);\n            if (cm.showMatchesOnScrollbar) {\n                if (searchState.getScrollbarAnnotate()) {\n                    searchState.getScrollbarAnnotate().clear();\n                }\n                searchState.setScrollbarAnnotate(cm.showMatchesOnScrollbar(query));\n            }\n            searchState.setOverlay(overlay);\n        }\n    }, 50);\n}\nfunction findNext(cm, prev, query, repeat) {\n    if (repeat === undefined) {\n        repeat = 1;\n    }\n    return cm.operation(function () {\n        var pos = cm.getCursor();\n        var cursor = cm.getSearchCursor(query, pos);\n        for (var i = 0; i < repeat; i++) {\n            var found = cursor.find(prev);\n            if (i == 0 && found && cursorEqual(cursor.from(), pos)) {\n                var lastEndPos = prev ? cursor.from() : cursor.to();\n                found = cursor.find(prev);\n                if (found && !found[0] && cursorEqual(cursor.from(), lastEndPos)) {\n                    if (cm.getLine(lastEndPos.line).length == lastEndPos.ch)\n                        found = cursor.find(prev);\n                }\n            }\n            if (!found) {\n                cursor = cm.getSearchCursor(query, (prev) ? new Pos(cm.lastLine()) : new Pos(cm.firstLine(), 0));\n                if (!cursor.find(prev)) {\n                    return;\n                }\n            }\n        }\n        return cursor.from();\n    });\n}\nfunction findNextFromAndToInclusive(cm, prev, query, repeat, vim) {\n    if (repeat === undefined) {\n        repeat = 1;\n    }\n    return cm.operation(function () {\n        var pos = cm.getCursor();\n        var cursor = cm.getSearchCursor(query, pos);\n        var found = cursor.find(!prev);\n        if (!vim.visualMode && found && cursorEqual(cursor.from(), pos)) {\n            cursor.find(!prev);\n        }\n        for (var i = 0; i < repeat; i++) {\n            found = cursor.find(prev);\n            if (!found) {\n                cursor = cm.getSearchCursor(query, (prev) ? new Pos(cm.lastLine()) : new Pos(cm.firstLine(), 0));\n                if (!cursor.find(prev)) {\n                    return;\n                }\n            }\n        }\n        return [cursor.from(), cursor.to()];\n    });\n}\nfunction clearSearchHighlight(cm) {\n    var state = getSearchState(cm);\n    cm.removeOverlay(getSearchState(cm).getOverlay());\n    state.setOverlay(null);\n    if (state.getScrollbarAnnotate()) {\n        state.getScrollbarAnnotate().clear();\n        state.setScrollbarAnnotate(null);\n    }\n}\nfunction isInRange(pos, start, end) {\n    if (typeof pos != 'number') {\n        pos = pos.line;\n    }\n    if (start instanceof Array) {\n        return inArray(pos, start);\n    }\n    else {\n        if (typeof end == 'number') {\n            return (pos >= start && pos <= end);\n        }\n        else {\n            return pos == start;\n        }\n    }\n}\nfunction getUserVisibleLines(cm) {\n    var renderer = cm.ace.renderer;\n    return {\n        top: renderer.getFirstFullyVisibleRow(),\n        bottom: renderer.getLastFullyVisibleRow()\n    };\n}\nfunction getMarkPos(cm, vim, markName) {\n    if (markName == '\\'' || markName == '`') {\n        return vimGlobalState.jumpList.find(cm, -1) || new Pos(0, 0);\n    }\n    else if (markName == '.') {\n        return getLastEditPos(cm);\n    }\n    var mark = vim.marks[markName];\n    return mark && mark.find();\n}\nfunction getLastEditPos(cm) {\n    var undoManager = cm.ace.session.$undoManager;\n    if (undoManager && undoManager.$lastDelta)\n        return toCmPos(undoManager.$lastDelta.end);\n}\nvar ExCommandDispatcher = function () {\n    this.buildCommandMap_();\n};\nExCommandDispatcher.prototype = {\n    processCommand: function (cm, input, opt_params) {\n        var that = this;\n        cm.operation(function () {\n            cm.curOp.isVimOp = true;\n            that._processCommand(cm, input, opt_params);\n        });\n    },\n    _processCommand: function (cm, input, opt_params) {\n        var vim = cm.state.vim;\n        var commandHistoryRegister = vimGlobalState.registerController.getRegister(':');\n        var previousCommand = commandHistoryRegister.toString();\n        if (vim.visualMode) {\n            exitVisualMode(cm);\n        }\n        var inputStream = new CodeMirror.StringStream(input);\n        commandHistoryRegister.setText(input);\n        var params = opt_params || {};\n        params.input = input;\n        try {\n            this.parseInput_(cm, inputStream, params);\n        }\n        catch (e) {\n            showConfirm(cm, e.toString());\n            throw e;\n        }\n        var command;\n        var commandName;\n        if (!params.commandName) {\n            if (params.line !== undefined) {\n                commandName = 'move';\n            }\n        }\n        else {\n            command = this.matchCommand_(params.commandName);\n            if (command) {\n                commandName = command.name;\n                if (command.excludeFromCommandHistory) {\n                    commandHistoryRegister.setText(previousCommand);\n                }\n                this.parseCommandArgs_(inputStream, params, command);\n                if (command.type == 'exToKey') {\n                    for (var i = 0; i < command.toKeys.length; i++) {\n                        vimApi.handleKey(cm, command.toKeys[i], 'mapping');\n                    }\n                    return;\n                }\n                else if (command.type == 'exToEx') {\n                    this.processCommand(cm, command.toInput);\n                    return;\n                }\n            }\n        }\n        if (!commandName) {\n            showConfirm(cm, 'Not an editor command \":' + input + '\"');\n            return;\n        }\n        try {\n            exCommands[commandName](cm, params);\n            if ((!command || !command.possiblyAsync) && params.callback) {\n                params.callback();\n            }\n        }\n        catch (e) {\n            showConfirm(cm, e.toString());\n            throw e;\n        }\n    },\n    parseInput_: function (cm, inputStream, result) {\n        inputStream.eatWhile(':');\n        if (inputStream.eat('%')) {\n            result.line = cm.firstLine();\n            result.lineEnd = cm.lastLine();\n        }\n        else {\n            result.line = this.parseLineSpec_(cm, inputStream);\n            if (result.line !== undefined && inputStream.eat(',')) {\n                result.lineEnd = this.parseLineSpec_(cm, inputStream);\n            }\n        }\n        var commandMatch = inputStream.match(/^(\\w+|!!|@@|[!#&*<=>@~])/);\n        if (commandMatch) {\n            result.commandName = commandMatch[1];\n        }\n        else {\n            result.commandName = inputStream.match(/.*/)[0];\n        }\n        return result;\n    },\n    parseLineSpec_: function (cm, inputStream) {\n        var numberMatch = inputStream.match(/^(\\d+)/);\n        if (numberMatch) {\n            return parseInt(numberMatch[1], 10) - 1;\n        }\n        switch (inputStream.next()) {\n            case '.':\n                return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n            case '$':\n                return this.parseLineSpecOffset_(inputStream, cm.lastLine());\n            case '\\'':\n                var markName = inputStream.next();\n                var markPos = getMarkPos(cm, cm.state.vim, markName);\n                if (!markPos)\n                    throw new Error('Mark not set');\n                return this.parseLineSpecOffset_(inputStream, markPos.line);\n            case '-':\n            case '+':\n                inputStream.backUp(1);\n                return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n            default:\n                inputStream.backUp(1);\n                return undefined;\n        }\n    },\n    parseLineSpecOffset_: function (inputStream, line) {\n        var offsetMatch = inputStream.match(/^([+-])?(\\d+)/);\n        if (offsetMatch) {\n            var offset = parseInt(offsetMatch[2], 10);\n            if (offsetMatch[1] == \"-\") {\n                line -= offset;\n            }\n            else {\n                line += offset;\n            }\n        }\n        return line;\n    },\n    parseCommandArgs_: function (inputStream, params, command) {\n        if (inputStream.eol()) {\n            return;\n        }\n        params.argString = inputStream.match(/.*/)[0];\n        var delim = command.argDelimiter || /\\s+/;\n        var args = trim(params.argString).split(delim);\n        if (args.length && args[0]) {\n            params.args = args;\n        }\n    },\n    matchCommand_: function (commandName) {\n        for (var i = commandName.length; i > 0; i--) {\n            var prefix = commandName.substring(0, i);\n            if (this.commandMap_[prefix]) {\n                var command = this.commandMap_[prefix];\n                if (command.name.indexOf(commandName) === 0) {\n                    return command;\n                }\n            }\n        }\n        return null;\n    },\n    buildCommandMap_: function () {\n        this.commandMap_ = {};\n        for (var i = 0; i < defaultExCommandMap.length; i++) {\n            var command = defaultExCommandMap[i];\n            var key = command.shortName || command.name;\n            this.commandMap_[key] = command;\n        }\n    },\n    map: function (lhs, rhs, ctx) {\n        if (lhs != ':' && lhs.charAt(0) == ':') {\n            if (ctx) {\n                throw Error('Mode not supported for ex mappings');\n            }\n            var commandName = lhs.substring(1);\n            if (rhs != ':' && rhs.charAt(0) == ':') {\n                this.commandMap_[commandName] = {\n                    name: commandName,\n                    type: 'exToEx',\n                    toInput: rhs.substring(1),\n                    user: true\n                };\n            }\n            else {\n                this.commandMap_[commandName] = {\n                    name: commandName,\n                    type: 'exToKey',\n                    toKeys: rhs,\n                    user: true\n                };\n            }\n        }\n        else {\n            if (rhs != ':' && rhs.charAt(0) == ':') {\n                var mapping = {\n                    keys: lhs,\n                    type: 'keyToEx',\n                    exArgs: { input: rhs.substring(1) }\n                };\n                if (ctx) {\n                    mapping.context = ctx;\n                }\n                defaultKeymap.unshift(mapping);\n            }\n            else {\n                var mapping = {\n                    keys: lhs,\n                    type: 'keyToKey',\n                    toKeys: rhs\n                };\n                if (ctx) {\n                    mapping.context = ctx;\n                }\n                defaultKeymap.unshift(mapping);\n            }\n        }\n    },\n    unmap: function (lhs, ctx) {\n        if (lhs != ':' && lhs.charAt(0) == ':') {\n            if (ctx) {\n                throw Error('Mode not supported for ex mappings');\n            }\n            var commandName = lhs.substring(1);\n            if (this.commandMap_[commandName] && this.commandMap_[commandName].user) {\n                delete this.commandMap_[commandName];\n                return true;\n            }\n        }\n        else {\n            var keys = lhs;\n            for (var i = 0; i < defaultKeymap.length; i++) {\n                if (keys == defaultKeymap[i].keys\n                    && defaultKeymap[i].context === ctx) {\n                    defaultKeymap.splice(i, 1);\n                    return true;\n                }\n            }\n        }\n    }\n};\nvar exCommands = {\n    colorscheme: function (cm, params) {\n        if (!params.args || params.args.length < 1) {\n            showConfirm(cm, cm.getOption('theme'));\n            return;\n        }\n        cm.setOption('theme', params.args[0]);\n    },\n    map: function (cm, params, ctx) {\n        var mapArgs = params.args;\n        if (!mapArgs || mapArgs.length < 2) {\n            if (cm) {\n                showConfirm(cm, 'Invalid mapping: ' + params.input);\n            }\n            return;\n        }\n        exCommandDispatcher.map(mapArgs[0], mapArgs[1], ctx);\n    },\n    imap: function (cm, params) { this.map(cm, params, 'insert'); },\n    nmap: function (cm, params) { this.map(cm, params, 'normal'); },\n    vmap: function (cm, params) { this.map(cm, params, 'visual'); },\n    unmap: function (cm, params, ctx) {\n        var mapArgs = params.args;\n        if (!mapArgs || mapArgs.length < 1 || !exCommandDispatcher.unmap(mapArgs[0], ctx)) {\n            if (cm) {\n                showConfirm(cm, 'No such mapping: ' + params.input);\n            }\n        }\n    },\n    move: function (cm, params) {\n        commandDispatcher.processCommand(cm, cm.state.vim, {\n            type: 'motion',\n            motion: 'moveToLineOrEdgeOfDocument',\n            motionArgs: { forward: false, explicitRepeat: true,\n                linewise: true },\n            repeatOverride: params.line + 1\n        });\n    },\n    set: function (cm, params) {\n        var setArgs = params.args;\n        var setCfg = params.setCfg || {};\n        if (!setArgs || setArgs.length < 1) {\n            if (cm) {\n                showConfirm(cm, 'Invalid mapping: ' + params.input);\n            }\n            return;\n        }\n        var expr = setArgs[0].split('=');\n        var optionName = expr[0];\n        var value = expr[1];\n        var forceGet = false;\n        if (optionName.charAt(optionName.length - 1) == '?') {\n            if (value) {\n                throw Error('Trailing characters: ' + params.argString);\n            }\n            optionName = optionName.substring(0, optionName.length - 1);\n            forceGet = true;\n        }\n        if (value === undefined && optionName.substring(0, 2) == 'no') {\n            optionName = optionName.substring(2);\n            value = false;\n        }\n        var optionIsBoolean = options[optionName] && options[optionName].type == 'boolean';\n        if (optionIsBoolean && value == undefined) {\n            value = true;\n        }\n        if (!optionIsBoolean && value === undefined || forceGet) {\n            var oldValue = getOption(optionName, cm, setCfg);\n            if (oldValue instanceof Error) {\n                showConfirm(cm, oldValue.message);\n            }\n            else if (oldValue === true || oldValue === false) {\n                showConfirm(cm, ' ' + (oldValue ? '' : 'no') + optionName);\n            }\n            else {\n                showConfirm(cm, '  ' + optionName + '=' + oldValue);\n            }\n        }\n        else {\n            var setOptionReturn = setOption(optionName, value, cm, setCfg);\n            if (setOptionReturn instanceof Error) {\n                showConfirm(cm, setOptionReturn.message);\n            }\n        }\n    },\n    setlocal: function (cm, params) {\n        params.setCfg = { scope: 'local' };\n        this.set(cm, params);\n    },\n    setglobal: function (cm, params) {\n        params.setCfg = { scope: 'global' };\n        this.set(cm, params);\n    },\n    registers: function (cm, params) {\n        var regArgs = params.args;\n        var registers = vimGlobalState.registerController.registers;\n        var regInfo = '----------Registers----------\\n\\n';\n        if (!regArgs) {\n            for (var registerName in registers) {\n                var text = registers[registerName].toString();\n                if (text.length) {\n                    regInfo += '\"' + registerName + '    ' + text + '\\n';\n                }\n            }\n        }\n        else {\n            var registerName;\n            regArgs = regArgs.join('');\n            for (var i = 0; i < regArgs.length; i++) {\n                registerName = regArgs.charAt(i);\n                if (!vimGlobalState.registerController.isValidRegister(registerName)) {\n                    continue;\n                }\n                var register = registers[registerName] || new Register();\n                regInfo += '\"' + registerName + '    ' + register.toString() + '\\n';\n            }\n        }\n        showConfirm(cm, regInfo);\n    },\n    sort: function (cm, params) {\n        var reverse, ignoreCase, unique, number, pattern;\n        function parseArgs() {\n            if (params.argString) {\n                var args = new CodeMirror.StringStream(params.argString);\n                if (args.eat('!')) {\n                    reverse = true;\n                }\n                if (args.eol()) {\n                    return;\n                }\n                if (!args.eatSpace()) {\n                    return 'Invalid arguments';\n                }\n                var opts = args.match(/([dinuox]+)?\\s*(\\/.+\\/)?\\s*/);\n                if (!opts && !args.eol()) {\n                    return 'Invalid arguments';\n                }\n                if (opts[1]) {\n                    ignoreCase = opts[1].indexOf('i') != -1;\n                    unique = opts[1].indexOf('u') != -1;\n                    var decimal = opts[1].indexOf('d') != -1 || opts[1].indexOf('n') != -1 && 1;\n                    var hex = opts[1].indexOf('x') != -1 && 1;\n                    var octal = opts[1].indexOf('o') != -1 && 1;\n                    if (decimal + hex + octal > 1) {\n                        return 'Invalid arguments';\n                    }\n                    number = decimal && 'decimal' || hex && 'hex' || octal && 'octal';\n                }\n                if (opts[2]) {\n                    pattern = new RegExp(opts[2].substr(1, opts[2].length - 2), ignoreCase ? 'i' : '');\n                }\n            }\n        }\n        var err = parseArgs();\n        if (err) {\n            showConfirm(cm, err + ': ' + params.argString);\n            return;\n        }\n        var lineStart = params.line || cm.firstLine();\n        var lineEnd = params.lineEnd || params.line || cm.lastLine();\n        if (lineStart == lineEnd) {\n            return;\n        }\n        var curStart = new Pos(lineStart, 0);\n        var curEnd = new Pos(lineEnd, lineLength(cm, lineEnd));\n        var text = cm.getRange(curStart, curEnd).split('\\n');\n        var numberRegex = pattern ? pattern :\n            (number == 'decimal') ? /(-?)([\\d]+)/ :\n                (number == 'hex') ? /(-?)(?:0x)?([0-9a-f]+)/i :\n                    (number == 'octal') ? /([0-7]+)/ : null;\n        var radix = (number == 'decimal') ? 10 : (number == 'hex') ? 16 : (number == 'octal') ? 8 : null;\n        var numPart = [], textPart = [];\n        if (number || pattern) {\n            for (var i = 0; i < text.length; i++) {\n                var matchPart = pattern ? text[i].match(pattern) : null;\n                if (matchPart && matchPart[0] != '') {\n                    numPart.push(matchPart);\n                }\n                else if (!pattern && numberRegex.exec(text[i])) {\n                    numPart.push(text[i]);\n                }\n                else {\n                    textPart.push(text[i]);\n                }\n            }\n        }\n        else {\n            textPart = text;\n        }\n        function compareFn(a, b) {\n            if (reverse) {\n                var tmp;\n                tmp = a;\n                a = b;\n                b = tmp;\n            }\n            if (ignoreCase) {\n                a = a.toLowerCase();\n                b = b.toLowerCase();\n            }\n            var anum = number && numberRegex.exec(a);\n            var bnum = number && numberRegex.exec(b);\n            if (!anum) {\n                return a < b ? -1 : 1;\n            }\n            anum = parseInt((anum[1] + anum[2]).toLowerCase(), radix);\n            bnum = parseInt((bnum[1] + bnum[2]).toLowerCase(), radix);\n            return anum - bnum;\n        }\n        function comparePatternFn(a, b) {\n            if (reverse) {\n                var tmp;\n                tmp = a;\n                a = b;\n                b = tmp;\n            }\n            if (ignoreCase) {\n                a[0] = a[0].toLowerCase();\n                b[0] = b[0].toLowerCase();\n            }\n            return (a[0] < b[0]) ? -1 : 1;\n        }\n        numPart.sort(pattern ? comparePatternFn : compareFn);\n        if (pattern) {\n            for (var i = 0; i < numPart.length; i++) {\n                numPart[i] = numPart[i].input;\n            }\n        }\n        else if (!number) {\n            textPart.sort(compareFn);\n        }\n        text = (!reverse) ? textPart.concat(numPart) : numPart.concat(textPart);\n        if (unique) { // Remove duplicate lines\n            var textOld = text;\n            var lastLine;\n            text = [];\n            for (var i = 0; i < textOld.length; i++) {\n                if (textOld[i] != lastLine) {\n                    text.push(textOld[i]);\n                }\n                lastLine = textOld[i];\n            }\n        }\n        cm.replaceRange(text.join('\\n'), curStart, curEnd);\n    },\n    vglobal: function (cm, params) {\n        this.global(cm, params);\n    },\n    global: function (cm, params) {\n        var argString = params.argString;\n        if (!argString) {\n            showConfirm(cm, 'Regular Expression missing from global');\n            return;\n        }\n        var inverted = params.commandName[0] === 'v';\n        var lineStart = (params.line !== undefined) ? params.line : cm.firstLine();\n        var lineEnd = params.lineEnd || params.line || cm.lastLine();\n        var tokens = splitBySlash(argString);\n        var regexPart = argString, cmd;\n        if (tokens.length) {\n            regexPart = tokens[0];\n            cmd = tokens.slice(1, tokens.length).join('/');\n        }\n        if (regexPart) {\n            try {\n                updateSearchQuery(cm, regexPart, true /** ignoreCase */, true /** smartCase */);\n            }\n            catch (e) {\n                showConfirm(cm, 'Invalid regex: ' + regexPart);\n                return;\n            }\n        }\n        var query = getSearchState(cm).getQuery();\n        var matchedLines = [];\n        for (var i = lineStart; i <= lineEnd; i++) {\n            var line = cm.getLineHandle(i);\n            var matched = query.test(line.text);\n            if (matched !== inverted) {\n                matchedLines.push(cmd ? line : line.text);\n            }\n        }\n        if (!cmd) {\n            showConfirm(cm, matchedLines.join('\\n'));\n            return;\n        }\n        var index = 0;\n        var nextCommand = function () {\n            if (index < matchedLines.length) {\n                var line = matchedLines[index++];\n                var lineNum = cm.getLineNumber(line);\n                if (lineNum == null) {\n                    nextCommand();\n                    return;\n                }\n                var command = (lineNum + 1) + cmd;\n                exCommandDispatcher.processCommand(cm, command, {\n                    callback: nextCommand\n                });\n            }\n        };\n        nextCommand();\n    },\n    substitute: function (cm, params) {\n        if (!cm.getSearchCursor) {\n            throw new Error('Search feature not available. Requires searchcursor.js or ' +\n                'any other getSearchCursor implementation.');\n        }\n        var argString = params.argString;\n        var tokens = argString ? splitBySeparator(argString, argString[0]) : [];\n        var regexPart, replacePart = '', trailing, flagsPart, count;\n        var confirm = false; // Whether to confirm each replace.\n        var global = false; // True to replace all instances on a line, false to replace only 1.\n        if (tokens.length) {\n            regexPart = tokens[0];\n            if (getOption('pcre') && regexPart !== '') {\n                regexPart = new RegExp(regexPart).source; //normalize not escaped characters\n            }\n            replacePart = tokens[1];\n            if (replacePart !== undefined) {\n                if (getOption('pcre')) {\n                    replacePart = unescapeRegexReplace(replacePart.replace(/([^\\\\])&/g, \"$1$$&\"));\n                }\n                else {\n                    replacePart = translateRegexReplace(replacePart);\n                }\n                vimGlobalState.lastSubstituteReplacePart = replacePart;\n            }\n            trailing = tokens[2] ? tokens[2].split(' ') : [];\n        }\n        else {\n            if (argString && argString.length) {\n                showConfirm(cm, 'Substitutions should be of the form ' +\n                    ':s/pattern/replace/');\n                return;\n            }\n        }\n        if (trailing) {\n            flagsPart = trailing[0];\n            count = parseInt(trailing[1]);\n            if (flagsPart) {\n                if (flagsPart.indexOf('c') != -1) {\n                    confirm = true;\n                }\n                if (flagsPart.indexOf('g') != -1) {\n                    global = true;\n                }\n                if (getOption('pcre')) {\n                    regexPart = regexPart + '/' + flagsPart;\n                }\n                else {\n                    regexPart = regexPart.replace(/\\//g, \"\\\\/\") + '/' + flagsPart;\n                }\n            }\n        }\n        if (regexPart) {\n            try {\n                updateSearchQuery(cm, regexPart, true /** ignoreCase */, true /** smartCase */);\n            }\n            catch (e) {\n                showConfirm(cm, 'Invalid regex: ' + regexPart);\n                return;\n            }\n        }\n        replacePart = replacePart || vimGlobalState.lastSubstituteReplacePart;\n        if (replacePart === undefined) {\n            showConfirm(cm, 'No previous substitute regular expression');\n            return;\n        }\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n        var lineStart = (params.line !== undefined) ? params.line : cm.getCursor().line;\n        var lineEnd = params.lineEnd || lineStart;\n        if (lineStart == cm.firstLine() && lineEnd == cm.lastLine()) {\n            lineEnd = Infinity;\n        }\n        if (count) {\n            lineStart = lineEnd;\n            lineEnd = lineStart + count - 1;\n        }\n        var startPos = clipCursorToContent(cm, new Pos(lineStart, 0));\n        var cursor = cm.getSearchCursor(query, startPos);\n        doReplace(cm, confirm, global, lineStart, lineEnd, cursor, query, replacePart, params.callback);\n    },\n    redo: CodeMirror.commands.redo,\n    undo: CodeMirror.commands.undo,\n    write: function (cm) {\n        if (CodeMirror.commands.save) {\n            CodeMirror.commands.save(cm);\n        }\n        else if (cm.save) {\n            cm.save();\n        }\n    },\n    nohlsearch: function (cm) {\n        clearSearchHighlight(cm);\n    },\n    yank: function (cm) {\n        var cur = copyCursor(cm.getCursor());\n        var line = cur.line;\n        var lineText = cm.getLine(line);\n        vimGlobalState.registerController.pushText('0', 'yank', lineText, true, true);\n    },\n    delmarks: function (cm, params) {\n        if (!params.argString || !trim(params.argString)) {\n            showConfirm(cm, 'Argument required');\n            return;\n        }\n        var state = cm.state.vim;\n        var stream = new CodeMirror.StringStream(trim(params.argString));\n        while (!stream.eol()) {\n            stream.eatSpace();\n            var count = stream.pos;\n            if (!stream.match(/[a-zA-Z]/, false)) {\n                showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n                return;\n            }\n            var sym = stream.next();\n            if (stream.match('-', true)) {\n                if (!stream.match(/[a-zA-Z]/, false)) {\n                    showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n                    return;\n                }\n                var startMark = sym;\n                var finishMark = stream.next();\n                if (isLowerCase(startMark) && isLowerCase(finishMark) ||\n                    isUpperCase(startMark) && isUpperCase(finishMark)) {\n                    var start = startMark.charCodeAt(0);\n                    var finish = finishMark.charCodeAt(0);\n                    if (start >= finish) {\n                        showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n                        return;\n                    }\n                    for (var j = 0; j <= finish - start; j++) {\n                        var mark = String.fromCharCode(start + j);\n                        delete state.marks[mark];\n                    }\n                }\n                else {\n                    showConfirm(cm, 'Invalid argument: ' + startMark + '-');\n                    return;\n                }\n            }\n            else {\n                delete state.marks[sym];\n            }\n        }\n    }\n};\nvar exCommandDispatcher = new ExCommandDispatcher();\nfunction doReplace(cm, confirm, global, lineStart, lineEnd, searchCursor, query, replaceWith, callback) {\n    cm.state.vim.exMode = true;\n    var done = false;\n    var lastPos, modifiedLineNumber, joined;\n    function replaceAll() {\n        cm.operation(function () {\n            while (!done) {\n                replace();\n                next();\n            }\n            stop();\n        });\n    }\n    function replace() {\n        var text = cm.getRange(searchCursor.from(), searchCursor.to());\n        var newText = text.replace(query, replaceWith);\n        var unmodifiedLineNumber = searchCursor.to().line;\n        searchCursor.replace(newText);\n        modifiedLineNumber = searchCursor.to().line;\n        lineEnd += modifiedLineNumber - unmodifiedLineNumber;\n        joined = modifiedLineNumber < unmodifiedLineNumber;\n    }\n    function findNextValidMatch() {\n        var lastMatchTo = lastPos && copyCursor(searchCursor.to());\n        var match = searchCursor.findNext();\n        if (match && !match[0] && lastMatchTo && cursorEqual(searchCursor.from(), lastMatchTo)) {\n            match = searchCursor.findNext();\n        }\n        return match;\n    }\n    function next() {\n        while (findNextValidMatch() &&\n            isInRange(searchCursor.from(), lineStart, lineEnd)) {\n            if (!global && searchCursor.from().line == modifiedLineNumber && !joined) {\n                continue;\n            }\n            cm.scrollIntoView(searchCursor.from(), 30);\n            cm.setSelection(searchCursor.from(), searchCursor.to());\n            lastPos = searchCursor.from();\n            done = false;\n            return;\n        }\n        done = true;\n    }\n    function stop(close) {\n        if (close) {\n            close();\n        }\n        cm.focus();\n        if (lastPos) {\n            cm.setCursor(lastPos);\n            var vim = cm.state.vim;\n            vim.exMode = false;\n            vim.lastHPos = vim.lastHSPos = lastPos.ch;\n        }\n        if (callback) {\n            callback();\n        }\n    }\n    function onPromptKeyDown(e, _value, close) {\n        CodeMirror.e_stop(e);\n        var keyName = CodeMirror.keyName(e);\n        switch (keyName) {\n            case 'Y':\n                replace();\n                next();\n                break;\n            case 'N':\n                next();\n                break;\n            case 'A':\n                var savedCallback = callback;\n                callback = undefined;\n                cm.operation(replaceAll);\n                callback = savedCallback;\n                break;\n            case 'L':\n                replace();\n            case 'Q':\n            case 'Esc':\n            case 'Ctrl-C':\n            case 'Ctrl-[':\n                stop(close);\n                break;\n        }\n        if (done) {\n            stop(close);\n        }\n        return true;\n    }\n    next();\n    if (done) {\n        showConfirm(cm, 'No matches for ' + query.source);\n        return;\n    }\n    if (!confirm) {\n        replaceAll();\n        if (callback) {\n            callback();\n        }\n        return;\n    }\n    showPrompt(cm, {\n        prefix: dom('span', 'replace with ', dom('strong', replaceWith), ' (y/n/a/q/l)'),\n        onKeyDown: onPromptKeyDown\n    });\n}\nCodeMirror.keyMap.vim = {\n    attach: attachVimMap,\n    detach: detachVimMap,\n    call: cmKey\n};\nfunction exitInsertMode(cm) {\n    var vim = cm.state.vim;\n    var macroModeState = vimGlobalState.macroModeState;\n    var insertModeChangeRegister = vimGlobalState.registerController.getRegister('.');\n    var isPlaying = macroModeState.isPlaying;\n    var lastChange = macroModeState.lastInsertModeChanges;\n    if (!isPlaying) {\n        cm.off('change', onChange);\n        CodeMirror.off(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n    }\n    if (!isPlaying && vim.insertModeRepeat > 1) {\n        repeatLastEdit(cm, vim, vim.insertModeRepeat - 1, true /** repeatForInsert */);\n        vim.lastEditInputState.repeatOverride = vim.insertModeRepeat;\n    }\n    delete vim.insertModeRepeat;\n    vim.insertMode = false;\n    cm.setCursor(cm.getCursor().line, cm.getCursor().ch - 1);\n    cm.setOption('keyMap', 'vim');\n    cm.setOption('disableInput', true);\n    cm.toggleOverwrite(false); // exit replace mode if we were in it.\n    insertModeChangeRegister.setText(lastChange.changes.join(''));\n    CodeMirror.signal(cm, \"vim-mode-change\", { mode: \"normal\" });\n    if (macroModeState.isRecording) {\n        logInsertModeChange(macroModeState);\n    }\n}\nfunction _mapCommand(command) {\n    defaultKeymap.unshift(command);\n}\nfunction mapCommand(keys, type, name, args, extra) {\n    var command = { keys: keys, type: type };\n    command[type] = name;\n    command[type + \"Args\"] = args;\n    for (var key in extra)\n        command[key] = extra[key];\n    _mapCommand(command);\n}\ndefineOption('insertModeEscKeysTimeout', 200, 'number');\nCodeMirror.keyMap['vim-insert'] = {\n    fallthrough: ['default'],\n    attach: attachVimMap,\n    detach: detachVimMap,\n    call: cmKey\n};\nCodeMirror.keyMap['vim-replace'] = {\n    'Backspace': 'goCharLeft',\n    fallthrough: ['vim-insert'],\n    attach: attachVimMap,\n    detach: detachVimMap,\n    call: cmKey\n};\nfunction executeMacroRegister(cm, vim, macroModeState, registerName) {\n    var register = vimGlobalState.registerController.getRegister(registerName);\n    if (registerName == ':') {\n        if (register.keyBuffer[0]) {\n            exCommandDispatcher.processCommand(cm, register.keyBuffer[0]);\n        }\n        macroModeState.isPlaying = false;\n        return;\n    }\n    var keyBuffer = register.keyBuffer;\n    var imc = 0;\n    macroModeState.isPlaying = true;\n    macroModeState.replaySearchQueries = register.searchQueries.slice(0);\n    for (var i = 0; i < keyBuffer.length; i++) {\n        var text = keyBuffer[i];\n        var match, key;\n        while (text) {\n            match = (/<\\w+-.+?>|<\\w+>|./).exec(text);\n            key = match[0];\n            text = text.substring(match.index + key.length);\n            vimApi.handleKey(cm, key, 'macro');\n            if (vim.insertMode) {\n                var changes = register.insertModeChanges[imc++].changes;\n                vimGlobalState.macroModeState.lastInsertModeChanges.changes =\n                    changes;\n                repeatInsertModeChanges(cm, changes, 1);\n                exitInsertMode(cm);\n            }\n        }\n    }\n    macroModeState.isPlaying = false;\n}\nfunction logKey(macroModeState, key) {\n    if (macroModeState.isPlaying) {\n        return;\n    }\n    var registerName = macroModeState.latestRegister;\n    var register = vimGlobalState.registerController.getRegister(registerName);\n    if (register) {\n        register.pushText(key);\n    }\n}\nfunction logInsertModeChange(macroModeState) {\n    if (macroModeState.isPlaying) {\n        return;\n    }\n    var registerName = macroModeState.latestRegister;\n    var register = vimGlobalState.registerController.getRegister(registerName);\n    if (register && register.pushInsertModeChanges) {\n        register.pushInsertModeChanges(macroModeState.lastInsertModeChanges);\n    }\n}\nfunction logSearchQuery(macroModeState, query) {\n    if (macroModeState.isPlaying) {\n        return;\n    }\n    var registerName = macroModeState.latestRegister;\n    var register = vimGlobalState.registerController.getRegister(registerName);\n    if (register && register.pushSearchQuery) {\n        register.pushSearchQuery(query);\n    }\n}\nfunction onChange(cm, changeObj) {\n    var macroModeState = vimGlobalState.macroModeState;\n    var lastChange = macroModeState.lastInsertModeChanges;\n    if (!macroModeState.isPlaying) {\n        while (changeObj) {\n            lastChange.expectCursorActivityForChange = true;\n            if (lastChange.ignoreCount > 1) {\n                lastChange.ignoreCount--;\n            }\n            else if (changeObj.origin == '+input' || changeObj.origin == 'paste'\n                || changeObj.origin === undefined /* only in testing */) {\n                var selectionCount = cm.listSelections().length;\n                if (selectionCount > 1)\n                    lastChange.ignoreCount = selectionCount;\n                var text = changeObj.text.join('\\n');\n                if (lastChange.maybeReset) {\n                    lastChange.changes = [];\n                    lastChange.maybeReset = false;\n                }\n                if (text) {\n                    if (cm.state.overwrite && !/\\n/.test(text)) {\n                        lastChange.changes.push([text]);\n                    }\n                    else {\n                        lastChange.changes.push(text);\n                    }\n                }\n            }\n            changeObj = changeObj.next;\n        }\n    }\n}\nfunction onCursorActivity(cm) {\n    var vim = cm.state.vim;\n    if (vim.insertMode) {\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isPlaying) {\n            return;\n        }\n        var lastChange = macroModeState.lastInsertModeChanges;\n        if (lastChange.expectCursorActivityForChange) {\n            lastChange.expectCursorActivityForChange = false;\n        }\n        else {\n            lastChange.maybeReset = true;\n        }\n    }\n    else if (!cm.curOp.isVimOp) {\n        handleExternalSelection(cm, vim);\n    }\n}\nfunction handleExternalSelection(cm, vim, keepHPos) {\n    var anchor = cm.getCursor('anchor');\n    var head = cm.getCursor('head');\n    if (vim.visualMode && !cm.somethingSelected()) {\n        exitVisualMode(cm, false);\n    }\n    else if (!vim.visualMode && !vim.insertMode && cm.somethingSelected()) {\n        vim.visualMode = true;\n        vim.visualLine = false;\n        CodeMirror.signal(cm, \"vim-mode-change\", { mode: \"visual\" });\n    }\n    if (vim.visualMode) {\n        var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\n        var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\n        head = offsetCursor(head, 0, headOffset);\n        anchor = offsetCursor(anchor, 0, anchorOffset);\n        vim.sel = {\n            anchor: anchor,\n            head: head\n        };\n        updateMark(cm, vim, '<', cursorMin(head, anchor));\n        updateMark(cm, vim, '>', cursorMax(head, anchor));\n    }\n    else if (!vim.insertMode && !keepHPos) {\n        vim.lastHPos = cm.getCursor().ch;\n    }\n}\nfunction InsertModeKey(keyName) {\n    this.keyName = keyName;\n}\nfunction onKeyEventTargetKeyDown(e) {\n    var macroModeState = vimGlobalState.macroModeState;\n    var lastChange = macroModeState.lastInsertModeChanges;\n    var keyName = CodeMirror.keyName(e);\n    if (!keyName) {\n        return;\n    }\n    function onKeyFound() {\n        if (lastChange.maybeReset) {\n            lastChange.changes = [];\n            lastChange.maybeReset = false;\n        }\n        lastChange.changes.push(new InsertModeKey(keyName));\n        return true;\n    }\n    if (keyName.indexOf('Delete') != -1 || keyName.indexOf('Backspace') != -1) {\n        CodeMirror.lookupKey(keyName, 'vim-insert', onKeyFound);\n    }\n}\nfunction repeatLastEdit(cm, vim, repeat, repeatForInsert) {\n    var macroModeState = vimGlobalState.macroModeState;\n    macroModeState.isPlaying = true;\n    var isAction = !!vim.lastEditActionCommand;\n    var cachedInputState = vim.inputState;\n    function repeatCommand() {\n        if (isAction) {\n            commandDispatcher.processAction(cm, vim, vim.lastEditActionCommand);\n        }\n        else {\n            commandDispatcher.evalInput(cm, vim);\n        }\n    }\n    function repeatInsert(repeat) {\n        if (macroModeState.lastInsertModeChanges.changes.length > 0) {\n            repeat = !vim.lastEditActionCommand ? 1 : repeat;\n            var changeObject = macroModeState.lastInsertModeChanges;\n            repeatInsertModeChanges(cm, changeObject.changes, repeat);\n        }\n    }\n    vim.inputState = vim.lastEditInputState;\n    if (isAction && vim.lastEditActionCommand.interlaceInsertRepeat) {\n        for (var i = 0; i < repeat; i++) {\n            repeatCommand();\n            repeatInsert(1);\n        }\n    }\n    else {\n        if (!repeatForInsert) {\n            repeatCommand();\n        }\n        repeatInsert(repeat);\n    }\n    vim.inputState = cachedInputState;\n    if (vim.insertMode && !repeatForInsert) {\n        exitInsertMode(cm);\n    }\n    macroModeState.isPlaying = false;\n}\nfunction repeatInsertModeChanges(cm, changes, repeat) {\n    function keyHandler(binding) {\n        if (typeof binding == 'string') {\n            CodeMirror.commands[binding](cm);\n        }\n        else {\n            binding(cm);\n        }\n        return true;\n    }\n    var head = cm.getCursor('head');\n    var visualBlock = vimGlobalState.macroModeState.lastInsertModeChanges.visualBlock;\n    if (visualBlock) {\n        selectForInsert(cm, head, visualBlock + 1);\n        repeat = cm.listSelections().length;\n        cm.setCursor(head);\n    }\n    for (var i = 0; i < repeat; i++) {\n        if (visualBlock) {\n            cm.setCursor(offsetCursor(head, i, 0));\n        }\n        for (var j = 0; j < changes.length; j++) {\n            var change = changes[j];\n            if (change instanceof InsertModeKey) {\n                CodeMirror.lookupKey(change.keyName, 'vim-insert', keyHandler);\n            }\n            else if (typeof change == \"string\") {\n                cm.replaceSelection(change);\n            }\n            else {\n                var start = cm.getCursor();\n                var end = offsetCursor(start, 0, change[0].length);\n                cm.replaceRange(change[0], start, end);\n                cm.setCursor(end);\n            }\n        }\n    }\n    if (visualBlock) {\n        cm.setCursor(offsetCursor(head, 0, 1));\n    }\n}\nresetVimGlobalState();\nCodeMirror.Vim = vimApi;\nvar specialKey = { 'return': 'CR', backspace: 'BS', 'delete': 'Del', esc: 'Esc',\n    left: 'Left', right: 'Right', up: 'Up', down: 'Down', space: 'Space', insert: 'Ins',\n    home: 'Home', end: 'End', pageup: 'PageUp', pagedown: 'PageDown', enter: 'CR'\n};\nfunction lookupKey(hashId, key, e) {\n    if (key.length > 1 && key[0] == \"n\") {\n        key = key.replace(\"numpad\", \"\");\n    }\n    key = specialKey[key] || key;\n    var name = '';\n    if (e.ctrlKey) {\n        name += 'C-';\n    }\n    if (e.altKey) {\n        name += 'A-';\n    }\n    if ((name || key.length > 1) && e.shiftKey) {\n        name += 'S-';\n    }\n    name += key;\n    if (name.length > 1) {\n        name = '<' + name + '>';\n    }\n    return name;\n}\nvar handleKey = vimApi.handleKey.bind(vimApi);\nvimApi.handleKey = function (cm, key, origin) {\n    return cm.operation(function () {\n        return handleKey(cm, key, origin);\n    }, true);\n};\nfunction cloneVimState(state) {\n    var n = new state.constructor();\n    Object.keys(state).forEach(function (key) {\n        var o = state[key];\n        if (Array.isArray(o))\n            o = o.slice();\n        else if (o && typeof o == \"object\" && o.constructor != Object)\n            o = cloneVimState(o);\n        n[key] = o;\n    });\n    if (state.sel) {\n        n.sel = {\n            head: state.sel.head && copyCursor(state.sel.head),\n            anchor: state.sel.anchor && copyCursor(state.sel.anchor)\n        };\n    }\n    return n;\n}\nfunction multiSelectHandleKey(cm, key, origin) {\n    var isHandled = false;\n    var vim = vimApi.maybeInitVimState_(cm);\n    var visualBlock = vim.visualBlock || vim.wasInVisualBlock;\n    var wasMultiselect = cm.ace.inMultiSelectMode;\n    if (vim.wasInVisualBlock && !wasMultiselect) {\n        vim.wasInVisualBlock = false;\n    }\n    else if (wasMultiselect && vim.visualBlock) {\n        vim.wasInVisualBlock = true;\n    }\n    if (key == '<Esc>' && !vim.insertMode && !vim.visualMode && wasMultiselect) {\n        cm.ace.exitMultiSelectMode();\n    }\n    else if (visualBlock || !wasMultiselect || cm.ace.inVirtualSelectionMode) {\n        isHandled = vimApi.handleKey(cm, key, origin);\n    }\n    else {\n        var old = cloneVimState(vim);\n        cm.operation(function () {\n            cm.ace.forEachSelection(function () {\n                var sel = cm.ace.selection;\n                cm.state.vim.lastHPos = sel.$desiredColumn == null ? sel.lead.column : sel.$desiredColumn;\n                var head = cm.getCursor(\"head\");\n                var anchor = cm.getCursor(\"anchor\");\n                var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\n                var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\n                head = offsetCursor(head, 0, headOffset);\n                anchor = offsetCursor(anchor, 0, anchorOffset);\n                cm.state.vim.sel.head = head;\n                cm.state.vim.sel.anchor = anchor;\n                isHandled = handleKey(cm, key, origin);\n                sel.$desiredColumn = cm.state.vim.lastHPos == -1 ? null : cm.state.vim.lastHPos;\n                if (cm.virtualSelectionMode()) {\n                    cm.state.vim = cloneVimState(old);\n                }\n            });\n            if (cm.curOp.cursorActivity && !isHandled)\n                cm.curOp.cursorActivity = false;\n        }, true);\n    }\n    if (isHandled && !vim.visualMode && !vim.insert && vim.visualMode != cm.somethingSelected()) {\n        handleExternalSelection(cm, vim, true);\n    }\n    return isHandled;\n}\nexports.CodeMirror = CodeMirror;\nvar getVim = vimApi.maybeInitVimState_;\nexports.handler = {\n    $id: \"ace/keyboard/vim\",\n    drawCursor: function (element, pixelPos, config, sel, session) {\n        var vim = this.state.vim || {};\n        var w = config.characterWidth;\n        var h = config.lineHeight;\n        var top = pixelPos.top;\n        var left = pixelPos.left;\n        if (!vim.insertMode) {\n            var isbackwards = !sel.cursor\n                ? session.selection.isBackwards() || session.selection.isEmpty()\n                : Range.comparePoints(sel.cursor, sel.start) <= 0;\n            if (!isbackwards && left > w)\n                left -= w;\n        }\n        if (!vim.insertMode && vim.status) {\n            h = h / 2;\n            top += h;\n        }\n        domLib.translate(element, left, top);\n        domLib.setStyle(element.style, \"width\", w + \"px\");\n        domLib.setStyle(element.style, \"height\", h + \"px\");\n    },\n    $getDirectionForHighlight: function (editor) {\n        var cm = editor.state.cm;\n        var vim = getVim(cm);\n        if (!vim.insertMode) {\n            return editor.session.selection.isBackwards() || editor.session.selection.isEmpty();\n        }\n    },\n    handleKeyboard: function (data, hashId, key, keyCode, e) {\n        var editor = data.editor;\n        var cm = editor.state.cm;\n        var vim = getVim(cm);\n        if (keyCode == -1)\n            return;\n        if (!vim.insertMode) {\n            if (hashId == -1) {\n                if (key.charCodeAt(0) > 0xFF) {\n                    if (data.inputKey) {\n                        key = data.inputKey;\n                        if (key && data.inputHash == 4)\n                            key = key.toUpperCase();\n                    }\n                }\n                data.inputChar = key;\n            }\n            else if (hashId == 4 || hashId == 0) {\n                if (data.inputKey == key && data.inputHash == hashId && data.inputChar) {\n                    key = data.inputChar;\n                    hashId = -1;\n                }\n                else {\n                    data.inputChar = null;\n                    data.inputKey = key;\n                    data.inputHash = hashId;\n                }\n            }\n            else {\n                data.inputChar = data.inputKey = null;\n            }\n        }\n        if (cm.state.overwrite && vim.insertMode && key == \"backspace\" && hashId == 0) {\n            return { command: \"gotoleft\" };\n        }\n        if (key == \"c\" && hashId == 1) { // key == \"ctrl-c\"\n            if (!useragent.isMac && editor.getCopyText()) {\n                editor.once(\"copy\", function () {\n                    if (vim.insertMode)\n                        editor.selection.clearSelection();\n                    else\n                        cm.operation(function () { exitVisualMode(cm); });\n                });\n                return { command: \"null\", passEvent: true };\n            }\n        }\n        if (key == \"esc\" && !vim.insertMode && !vim.visualMode && !cm.ace.inMultiSelectMode) {\n            var searchState = getSearchState(cm);\n            var overlay = searchState.getOverlay();\n            if (overlay)\n                cm.removeOverlay(overlay);\n        }\n        if (hashId == -1 || hashId & 1 || hashId === 0 && key.length > 1) {\n            var insertMode = vim.insertMode;\n            var name = lookupKey(hashId, key, e || {});\n            if (vim.status == null)\n                vim.status = \"\";\n            var isHandled = multiSelectHandleKey(cm, name, 'user');\n            vim = getVim(cm); // may be changed by multiSelectHandleKey\n            if (isHandled && vim.status != null)\n                vim.status += name;\n            else if (vim.status == null)\n                vim.status = \"\";\n            cm._signal(\"changeStatus\");\n            if (!isHandled && (hashId != -1 || insertMode))\n                return;\n            return { command: \"null\", passEvent: !isHandled };\n        }\n    },\n    attach: function (editor) {\n        if (!editor.state)\n            editor.state = {};\n        var cm = new CodeMirror(editor);\n        editor.state.cm = cm;\n        editor.$vimModeHandler = this;\n        CodeMirror.keyMap.vim.attach(cm);\n        getVim(cm).status = null;\n        cm.on('vim-command-done', function () {\n            if (cm.virtualSelectionMode())\n                return;\n            getVim(cm).status = null;\n            cm.ace._signal(\"changeStatus\");\n            cm.ace.session.markUndoGroup();\n        });\n        cm.on(\"changeStatus\", function () {\n            cm.ace.renderer.updateCursor();\n            cm.ace._signal(\"changeStatus\");\n        });\n        cm.on(\"vim-mode-change\", function () {\n            if (cm.virtualSelectionMode())\n                return;\n            updateInputMode();\n            cm._signal(\"changeStatus\");\n        });\n        function updateInputMode() {\n            var isIntsert = getVim(cm).insertMode;\n            cm.ace.renderer.setStyle(\"normal-mode\", !isIntsert);\n            editor.textInput.setCommandMode(!isIntsert);\n            editor.renderer.$keepTextAreaAtCursor = isIntsert;\n            editor.renderer.$blockCursor = !isIntsert;\n        }\n        updateInputMode();\n        editor.renderer.$cursorLayer.drawCursor = this.drawCursor.bind(cm);\n    },\n    detach: function (editor) {\n        var cm = editor.state.cm;\n        CodeMirror.keyMap.vim.detach(cm);\n        cm.destroy();\n        editor.state.cm = null;\n        editor.$vimModeHandler = null;\n        editor.renderer.$cursorLayer.drawCursor = null;\n        editor.renderer.setStyle(\"normal-mode\", false);\n        editor.textInput.setCommandMode(false);\n        editor.renderer.$keepTextAreaAtCursor = true;\n    },\n    getStatusText: function (editor) {\n        var cm = editor.state.cm;\n        var vim = getVim(cm);\n        if (vim.insertMode)\n            return \"INSERT\";\n        var status = \"\";\n        if (vim.visualMode) {\n            status += \"VISUAL\";\n            if (vim.visualLine)\n                status += \" LINE\";\n            if (vim.visualBlock)\n                status += \" BLOCK\";\n        }\n        if (vim.status)\n            status += (status ? \" \" : \"\") + vim.status;\n        return status;\n    }\n};\nvimApi.defineOption({\n    name: \"wrap\",\n    set: function (value, cm) {\n        if (cm) {\n            cm.ace.setOption(\"wrap\", value);\n        }\n    },\n    type: \"boolean\"\n}, false);\nvimApi.defineEx('write', 'w', function () {\n    console.log(':write is not implemented');\n});\ndefaultKeymap.push({ keys: 'zc', type: 'action', action: 'fold', actionArgs: { open: false } }, { keys: 'zC', type: 'action', action: 'fold', actionArgs: { open: false, all: true } }, { keys: 'zo', type: 'action', action: 'fold', actionArgs: { open: true } }, { keys: 'zO', type: 'action', action: 'fold', actionArgs: { open: true, all: true } }, { keys: 'za', type: 'action', action: 'fold', actionArgs: { toggle: true } }, { keys: 'zA', type: 'action', action: 'fold', actionArgs: { toggle: true, all: true } }, { keys: 'zf', type: 'action', action: 'fold', actionArgs: { open: true, all: true } }, { keys: 'zd', type: 'action', action: 'fold', actionArgs: { open: true, all: true } }, { keys: '<C-A-k>', type: 'action', action: 'aceCommand', actionArgs: { name: \"addCursorAbove\" } }, { keys: '<C-A-j>', type: 'action', action: 'aceCommand', actionArgs: { name: \"addCursorBelow\" } }, { keys: '<C-A-S-k>', type: 'action', action: 'aceCommand', actionArgs: { name: \"addCursorAboveSkipCurrent\" } }, { keys: '<C-A-S-j>', type: 'action', action: 'aceCommand', actionArgs: { name: \"addCursorBelowSkipCurrent\" } }, { keys: '<C-A-h>', type: 'action', action: 'aceCommand', actionArgs: { name: \"selectMoreBefore\" } }, { keys: '<C-A-l>', type: 'action', action: 'aceCommand', actionArgs: { name: \"selectMoreAfter\" } }, { keys: '<C-A-S-h>', type: 'action', action: 'aceCommand', actionArgs: { name: \"selectNextBefore\" } }, { keys: '<C-A-S-l>', type: 'action', action: 'aceCommand', actionArgs: { name: \"selectNextAfter\" } });\ndefaultKeymap.push({\n    keys: 'gq',\n    type: 'operator',\n    operator: 'hardWrap'\n});\nvimApi.defineOperator(\"hardWrap\", function (cm, operatorArgs, ranges, oldAnchor, newHead) {\n    var anchor = ranges[0].anchor.line;\n    var head = ranges[0].head.line;\n    if (operatorArgs.linewise)\n        head--;\n    hardWrap(cm.ace, { startRow: anchor, endRow: head });\n    return Pos(head, 0);\n});\ndefineOption('textwidth', undefined, 'number', ['tw'], function (width, cm) {\n    if (cm === undefined) {\n        return;\n    }\n    if (width === undefined) {\n        var value = cm.ace.getOption('printMarginColumn');\n        return value;\n    }\n    else {\n        var column = Math.round(width);\n        if (column > 1) {\n            cm.ace.setOption('printMarginColumn', column);\n        }\n    }\n});\nactions.aceCommand = function (cm, actionArgs, vim) {\n    cm.vimCmd = actionArgs;\n    if (cm.ace.inVirtualSelectionMode)\n        cm.ace.on(\"beforeEndOperation\", delayedExecAceCommand);\n    else\n        delayedExecAceCommand(null, cm.ace);\n};\nfunction delayedExecAceCommand(op, ace) {\n    ace.off(\"beforeEndOperation\", delayedExecAceCommand);\n    var cmd = ace.state.cm.vimCmd;\n    if (cmd) {\n        ace.execCommand(cmd.exec ? cmd : cmd.name, cmd.args);\n    }\n    ace.curOp = ace.prevOp;\n}\nactions.fold = function (cm, actionArgs, vim) {\n    cm.ace.execCommand(['toggleFoldWidget', 'toggleFoldWidget', 'foldOther', 'unfoldall'\n    ][(actionArgs.all ? 2 : 0) + (actionArgs.open ? 1 : 0)]);\n};\nexports.handler.defaultKeymap = defaultKeymap;\nexports.handler.actions = actions;\nexports.Vim = vimApi;\n\n});                (function() {\n                    ace.require([\"ace/keyboard/vim\"], function(m) {\n                        if (typeof module == \"object\" && typeof exports == \"object\" && module) {\n                            module.exports = m;\n                        }\n                    });\n                })();\n            "],"mappings":"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"},"metadata":{},"sourceType":"script"}